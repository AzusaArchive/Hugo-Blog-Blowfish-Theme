[{"content":"","date":"2023年4月18日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/.net/","section":"Categories","summary":"","title":".NET"},{"content":"","date":"2023年4月18日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/abp%E6%A1%86%E6%9E%B6/","section":"Tags","summary":"","title":"Abp框架"},{"content":"","date":"2023年4月18日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"2023年4月18日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/csharp/","section":"Tags","summary":"","title":"CSharp"},{"content":"\r","date":"2023年4月18日","permalink":"/Hugo-Blog-Blowfish-Theme/","section":"Index","summary":"","title":"Index"},{"content":"","date":"2023年4月18日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"2023年4月18日","permalink":"/Hugo-Blog-Blowfish-Theme/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"2023年4月18日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"2023年4月18日","permalink":"/Hugo-Blog-Blowfish-Theme/series/%E5%9F%BA%E4%BA%8Eabp%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/","section":"Series","summary":"","title":"基于Abp框架的博客项目"},{"content":"上一节成功地在Abp框架中定义了博客系统最基本的实体，并使用 EFCore 和 SQL Server 进行了数据库迁移，然后生成了数据库表。\n本节将使用Abp框架进行基本的增删改查（CRUD），包括创建自定义仓储，编写业务逻辑层，创建数据传输对象（DTO），打开 Swagger UI 查看Abp框架自动生成的 API 端点。\n创建自定义仓储 # 关于\rAbp中的仓储 在上一节（生成种子数据那会儿）已经有所介绍。在使用EFCore时，Abp框架会自动地为实现IAggregateRoot(聚合根)接口的实体以及 AbpDbContext 中的 DbSet\u0026lt;\u0026gt; 对应的实体生成仓储并添加到依赖注入容器中。在类中注入 IRepository\u0026lt;\u0026gt; 接口即可访问对应实体类的默认仓储。\nAbp框架也支持自定义仓储，或是在默认仓储接口上扩展，下面将介绍如何创建自定义仓储接口并提供实现类：\n自定义仓储接口 # 首先在领域层(.Domain项目)下创建名为 Abstractions 的文件夹，用于存放抽象接口，再创建名为 Repositories 的文件夹，用于存放仓储接口。接着为 Post 实体定义一个仓储接口，继承自Abp的默认仓储：\npublic interface IPostRepository : IRepository\u0026lt;Post,Guid\u0026gt; { Task\u0026lt;List\u0026lt;Post\u0026gt;\u0026gt; FindByKeywordAsync(string keyword); } 现在，领域层的项目结构如图：\n定义实现类 # 仓储的实现类应当定义在基础设施/数据访问层，即项目的 .EntityFrameworkCore 项目，在该项目中创建文件夹 Repositories 用于存放仓储接口的实现类。\n创建 PostRepository 类，实现刚才创建的 IPostRepository 接口。\npublic class PostRepository : IPostRepository { } 可以看到Abp的默认仓储接口需要实现大量的方法，这些方法不必自己编写，Abp已经提供了实现类，在使用EFCore时，将类继承自 EfCoreRepository 类即可实现大部分方法。实际上，如果使用Abp的默认仓储，框架默认就会把对应的 EfCoreRepository 类作为其实现类注入到依赖中。\npublic class PostRepository : EfCoreRepository\u0026lt;AbpBlogDbContext,Post,Guid\u0026gt;,IPostRepository { } 实现剩余的方法：\npublic class PostRepository : EfCoreRepository\u0026lt;AbpBlogDbContext,Post,Guid\u0026gt;,IPostRepository { public PostRepository(IDbContextProvider\u0026lt;AbpBlogDbContext\u0026gt; dbContextProvider) : base(dbContextProvider) { } public async Task\u0026lt;List\u0026lt;Post\u0026gt;\u0026gt; FindByKeywordAsync(string keyword) { var dbCtx = await GetDbContextAsync(); return await dbCtx.Posts.Where(post =\u0026gt; post.Markdown.Contains(keyword) || post.Title.Contains(keyword) || post.Tags.Any(tag =\u0026gt; tag.Name.Contains(keyword)) || (post.Category != null \u0026amp;\u0026amp; post.Category.Name.Contains(keyword)) ).ToListAsync(); } } 通过基类的GetDbContextAsync方法可获取到对应的 DbContext 实例，用它访问数据库并实现自定义接口中的方法。\n将自定义仓储添加至依赖注入 # Abp框架也会自动地将自定义仓储加入依赖，并且默认的仓储IRepository并不会失效，默认仓储不会使用刚才创建的自定义仓储的实现类。\nAbp框架对于不同的ORM框架会采用不同的实现类，该项目使用EFCore，所以使用的是 EfCoreRepository 类。\n如果要将默认仓储的实现替换成自定义的实现类，需要在 AbpBlogEntityFrameworkCoreModule 类的 ConfigureServices 方法中对对应实体的默认仓储实现类进行替换。\n例如：\ncontext.Services.AddAbpDbContext\u0026lt;BookStoreDbContext\u0026gt;(options =\u0026gt; { options.AddDefaultRepositories(); //将Book实体的默认仓储实现类替换为BookRepository options.AddRepository\u0026lt;Book, BookRepository\u0026gt;(); }); 访问\rAbp中的EFCore集成来了解更多关于自定义仓储的信息。\n创建数据传输对象 # 定义供表示层使用的\r数据传输对象(DTO)。\n数据传输对象(DTO)应用在应用层和表示层并用来与客户端进行数据传输。它起到隔离领域层和表示层以及隐藏重要数据的作用。DTO也对传输数据的序列化起到优化作用，避免了对某些实体的嵌套关系进行重复地序列化。\n将客户端对某个实体有需要的属性放入DTO，而对于客户端不需要或者是隐私的数据则不放入DTO。\n对于数据传输对象的更多信息，参阅\rAbp框架中的DTO。\n创建响应数据传输对象 # 首先创建用于响应客户端使用的响应数据传输对象。\n在 .Application.Contracts 项目中创建 ResponseDtos 文件夹，用于存放响应DTO，并定义数据传输类 PostDto：\npublic class PostDto : EntityDto\u0026lt;Guid\u0026gt; { public string Title { get; set; } public string MarkDown { get; set; } public CategoryDto Category { get; set; } public IEnumerable\u0026lt;TagDto\u0026gt; Tags { get; set; } public DateTime CreationTime { get; set; } public BlogUserDto Creator { get; set; } public DateTime? LastModificationTime { get; set; } public PostDto(string title, string markDown, CategoryDto? category, IEnumerable\u0026lt;TagDto\u0026gt; tags, DateTime creationTime, BlogUserDto creator, DateTime? lastModificationTime) { Title = title; MarkDown = markDown; Category = category; Tags = tags; CreationTime = creationTime; Creator = creator; LastModificationTime = lastModificationTime; } } Abp框架定义好了一些数据传输对象使用的基类/接口以减少重复工作，上面的 PostDto 类就继承自了 EntityDto\u0026lt;Guid\u0026gt; 类，它提前定义好了主键 Id 属性。\n为其余的实体定义响应DTO：\npublic class CategoryDto : EntityDto\u0026lt;Guid\u0026gt; { public string Name { get; set; } public CategoryDto(string name) { Name = name; } } public class TagDto : EntityDto\u0026lt;Guid\u0026gt; { public required string Name { get; set; } public TagDto(string name) { Name = name; } } public class BlogUserDto : EntityDto\u0026lt;Guid\u0026gt; { public required string UserName { get; set; } public required string Email { get; set; } public required string? Avatar { get; set; } public BlogUserDto(string userName, string email, string? avatar) { UserName = userName; Email = email; Avatar = avatar; } } 创建请求数据传输对象 # 对于客户端的请求（比如创建，修改）也要创建数据传输对象，同样在 .Application.Contracts 项目中创建 RequestDtos 文件夹，用于存放请求DTO，定义数据传输 CreatePostDto：\npublic class CreatePostDto { public string Title { get; set; } public string Markdown { get; set; } public Guid? CategoryId { get; set; } public IEnumerable\u0026lt;Guid\u0026gt; TagIds { get; set; } public Guid? CreatorId { get; set; } public CreatePostDto(string title, string markdown, Guid? categoryId, IEnumerable\u0026lt;Guid\u0026gt; tagIds, Guid? creatorId) { Title = title; Markdown = markdown; CategoryId = categoryId; TagIds = tagIds; CreatorId = creatorId; } } 请求传输对象没有Id属性，故不需要继承自EntityDto类。 创建其他的请求数据传输对象：\npublic class CreateCategoryDto { public string Name { get; set; } public CreateCategoryDto(string name) { Name = name; } } public class CreateTagDto { public string Name { get; set; } public CreateTagDto(string name) { Name = name; } } public class CreateBlogUserDto { public string UserName { get; set; } public string Password { get; set; } public string Email { get; set; } public string? Avatar { get; set; } public CreateBlogUserDto(string userName, string password, string email, string? avatar) { UserName = userName; Password = password; Email = email; Avatar = avatar; } } 请求数据对象校验 # 请求数据传输对象需要做数据校验，可以为DTO类标注\rSystem.ComponentModel.DataAnnotations命名空间中的特性（注解）来自动进行数据校验（在Abp框架中将由Abp进行校验而不是ASP .NET Core）。个人偏爱于使用\rFluentValidation数据校验库，Abp框架也添加了它的\r集成：\n添加Volo.Abp.FluentValidationNuget包到项目中\nInstall-Package Volo.Abp.FluentValidation 注意！ 命名空间为Volo.Abp.FluentValidation而不是Abp.FluentValidation，后者属于 ASP .NET Boilerplate 框架 (Volo.Abp的前身) ，而不是本项目使用的 Volo.Abp。 本项目中Abp框架的命名空间都应当是以 Volo.Abp 开头的，注意区分。\n在当前模块类(AbpBlogApplicationContractsModule)中添加依赖：\n[DependsOn( //...其他依赖 typeof(AbpFluentValidationModule)//Abp FluentValidation集成 )] public class AbpBlogApplicationContractsModule : AbpModule 然后按照\rFluentValidation文档创建校验器类：\npublic class CreatePostDtoValidator : AbstractValidator\u0026lt;CreatePostDto\u0026gt; { public CreatePostDtoValidator() { RuleFor(dto =\u0026gt; dto.Title).MaximumLength(64).WithMessage(\u0026#34;文章的标题过长，最大长度为64\u0026#34;); RuleFor(dto =\u0026gt; dto.Markdown).MaximumLength(20000).WithMessage(\u0026#34;文章过长，最多为20000字\u0026#34;); } } Abp框架将会自动找到这个类并在创建时进行校验。\n方便起见，该项目将Dto类的校验器类于Dto类放在了同一文件中，若有其他需求可转移至别的文件。\n创建其他的校验器类\npublic class CreateCategoryDtoValidator : AbstractValidator\u0026lt;CreateCategoryDto\u0026gt; { public CreateCategoryDtoValidator() { RuleFor(dto =\u0026gt; dto.Name).NotEmpty().WithMessage(\u0026#34;类型名不得为空\u0026#34;); RuleFor(dto =\u0026gt; dto.Name).MaximumLength(32).WithMessage(\u0026#34;类型名过长，最多为32个字\u0026#34;); } } public class CreateTagDtoValidator : AbstractValidator\u0026lt;TagDto\u0026gt; { public CreateTagDtoValidator() { RuleFor(dto =\u0026gt; dto.Name).NotEmpty().WithMessage(\u0026#34;标签名不得为空\u0026#34;); RuleFor(dto =\u0026gt; dto.Name).MaximumLength(32).WithMessage(\u0026#34;标签过长，最多为32个字\u0026#34;); } } public class CreateBlogUserDtoValidator : AbstractValidator\u0026lt;CreateBlogUserDto\u0026gt; { public CreateBlogUserDtoValidator() { RuleFor(dto =\u0026gt; dto.UserName).Length(4,24).WithMessage(\u0026#34;用户名的长度需要为4-24之间\u0026#34;); RuleFor(dto =\u0026gt; dto.Password).Length(6, 32).WithMessage(\u0026#34;密码的长度需要为6-32之间\u0026#34;); RuleFor(dto =\u0026gt; dto.Email).EmailAddress().WithMessage(\u0026#34;邮件格式错误\u0026#34;); When(dto =\u0026gt; dto.Avatar is not null, () =\u0026gt; RuleFor(dto =\u0026gt; dto.Avatar).Length(2000).WithMessage(\u0026#34;头像的URL过长\u0026#34;)); } } 实体类与数据传输对象的映射 # 在表示层和应用层之间传递数据时会频繁地将实体类与DTO类进行映射，过程重复而又繁琐，因此Abp框架使用了\rAutoMapper 库以进行自动的对象映射。\nAbp框架使用AutoMapper对DTO和实体进行映射，开发者需要提供每个实体类与其对应DTO的映射规则，Abp框架才能正常进行映射并提供CRUD操作。 更多关于Abp框架的对象映射参阅官方文档中的\r对象到对象映射。 根据\rAutoMapper文档配置对象映射方案，Abp框架已经在.Application项目中创建好了配置AutoMapper所使用的\rProfile类，只需在这个类中添加对象映射即可：\npublic AbpBlogApplicationAutoMapperProfile() { /* You can configure your AutoMapper mapping configuration here. * Alternatively, you can split your mapping configurations * into multiple profile classes for a better organization. */ CreateMap\u0026lt;Post, PostDto\u0026gt;(); CreateMap\u0026lt;Category, CategoryDto\u0026gt;(); CreateMap\u0026lt;Tag, TagDto\u0026gt;(); CreateMap\u0026lt;BlogUser, BlogUserDto\u0026gt;(); CreateMap\u0026lt;CreatePostDto, Post\u0026gt;(); CreateMap\u0026lt;CreateCategoryDto, Category\u0026gt;(); CreateMap\u0026lt;CreateTagDto, Tag\u0026gt;(); CreateMap\u0026lt;CreateBlogUserDto, BlogUser\u0026gt;(); } 定义应用程序服务 # 定义应用服务接口 # 在.Application.Contracts项目中创建AppServices文件夹，在此存放应用程序服务接口，也就是业务逻辑接口。\n创建Blog文件夹，并定义IPostAppService接口：\npublic interface IPostAppService : ICrudAppService\u0026lt;PostDto,Guid,PagedAndSortedResultRequestDto,CreatePostDto\u0026gt; {} 上述的代码创建了一个Post实体的应用服务接口，并扩展了Abp框架提供的ICrudAppService\u0026lt;\u0026gt;接口，该接口定义了常用的CRUD方法，在类型参数中填上实体对应的DTO，该接口就能提供该DTO对应的CRUD方法。\n例如上面的代码在ICrudAppService接口中提供了PostDto、Guid类型主键、*PagedAndSortedResultRequestDto*和CreatePostDto，该接口提供了GetAsync,GetListAsync,CreateAsync,UpdateAsync和DeleteAsync方法。\nICrudAppService接口有多个泛型变体，提供不同种类的DTO，它定义的方法就不一样。 PagedAndSortedResultRequestDto是Abp提供的DTO，它提供了用于分页查询和排序的属性。 ICrudAppService接口实现了IApplicationService接口，Abp将会识别实现该接口的接口并根据接口定义的方法名和相应的\r约定 生成对应的 API 控制器。 开发者也可以不使用ICrudAppService接口，而是自己定义接口以及方法，只要接口实现了IApplicationService接口并且方法的名字符合\r约定 ，Abp框架就可以自动生成API控制器。\nAbp框架生成API的配置是可以自定义的，在.HttpApi.Host项目的AbpBlogHttpApiHostModule类中定义了Abp根据应用服务生成API控制器的方法： private void ConfigureConventionalControllers() { Configure\u0026lt;AbpAspNetCoreMvcOptions\u0026gt;(options =\u0026gt; { options.ConventionalControllers.Create(typeof(AbpBlogApplicationModule).Assembly); }); } 更多关于Abp框架自动生成API控制器的信息参阅官方文档中的\r自动API控制器 定义其他实体的应用服务接口：\npublic interface ICategoryAppService : ICrudAppService\u0026lt;CategoryDto,Guid,PagedAndSortedResultRequestDto,CreateCategoryDto\u0026gt; { } public interface ITagAppService:ICrudAppService\u0026lt;TagDto,Guid,PagedAndSortedResultRequestDto,CreateTagDto\u0026gt; { } public interface IBlogUserAppService:ICrudAppService\u0026lt;BlogUserDto,Guid,PagedAndSortedResultRequestDto,CreateBlogUserDto\u0026gt; { } 实现应用服务接口 # 在应用层.Application项目中对上述接口进行实现，创建AppServices文件夹，然后编写实现类：\npublic class PostAppServices : CrudAppService\u0026lt;Post,PostDto,Guid,PagedAndSortedResultRequestDto,CreatePostDto\u0026gt; ,IPostAppService { public PostAppServices(IRepository\u0026lt;Post, Guid\u0026gt; repository) : base(repository) { } } Abp也提供了ICrudAppService接口对应的实现类，它会自动注入相应实体的\r默认仓储，以及\rIObjectMapper对对象进行映射，然后实现ICrudAppService接口中对应的CRUD方法。\nCrudAppService类与ICrudAppService类似，都拥有不同的泛型版本，确保他们俩类型参数中的DTO一致。 IObjectMapper 是Abp定义的一个可重用的对象映射接口，如果之前配置好了AutoMapper，那么Abp框架就会自动将该接口添加到依赖注入并且使用AutoMapper进行对象映射。 实现其他实体的应用服务接口：\npublic class CategoryAppService:CrudAppService\u0026lt;Category,CategoryDto,Guid,PagedAndSortedResultRequestDto,CreateCategoryDto\u0026gt; ,ICategoryAppService { public CategoryAppService(IRepository\u0026lt;Category, Guid\u0026gt; repository) : base(repository) { } } public class TagAppService:CrudAppService\u0026lt;Tag,TagDto,Guid,PagedAndSortedResultRequestDto,CreateTagDto\u0026gt; ,ITagAppService { public TagAppService(IRepository\u0026lt;Tag, Guid\u0026gt; repository) : base(repository) { } } public class BlogUserAppService : CrudAppService\u0026lt;BlogUser, BlogUserDto, Guid, PagedAndSortedResultRequestDto, CreateBlogUserDto\u0026gt;, IBlogUserAppService { public BlogUserAppService(IRepository\u0026lt;BlogUser, Guid\u0026gt; repository) : base(repository) { } } Swagger UI # Abp框架使用了SwashBukle.AspNetCore运行Swagger UI，运行.HttpApi.Host项目，打开Swagger，就可以看到刚才定义的AppService已经被Abp框架自动生成为 API 接口：\n","date":"2023年4月18日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%9F%BA%E4%BA%8Eabp%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%9A%84crud/","section":"Posts","summary":"","title":"基于Abp框架的博客项目：基本的CRUD"},{"content":"上一节安装了Abp框架并创建了解决方案，并成功运行了项目。\n本篇将会从定义实体类开始，使用 EFCore 连接数据库，并用 Code First 模式配置实体类，创建数据库DbContext并对数据库进行迁移，项目将采用SQL Server数据库。\n实体创建 # 需求分析 # 博客系统最基本的实体有 文章(Post)， 类别(Category)， 标签(Tag)，为方便今后的登录验证，先创建个用户(BlogUser)实体。\n文章(Post)，即最基本的博客文章。 类别(Category)，文章的类别，一篇文章只能有一个类别，一个类别有多个文章。 标签(Tag)，文章带有的标签，与文章为多对多关系。 用户(BlogUser)，顾名思义。 实体存放在领域层下，所以在Azusa.AbpBlog.Domain项目下新建文件夹Entities，接着创建Blog文件夹，存放博客系统的实体，创建Identity文件夹，存放用户实体。\nAbp框架中的实体 # 以 文章(Post) 为例，创建一个Abp框架实体：\nusing System; using System.Collections.Generic; using Azusa.AbpBlog.Identity; using Volo.Abp.Auditing; using Volo.Abp.Domain.Entities; namespace Azusa.AbpBlog.Entities.Blog; public class Post : IEntity\u0026lt;Guid\u0026gt;,IHasCreationTime,IMustHaveCreator\u0026lt;BlogUser\u0026gt;,IHasModificationTime,IHasDeletionTime { public Guid Id { get; } public string Title { get; set; } public string Markdown { get; set; } public Category? Category { get; set; } public ICollection\u0026lt;Tag\u0026gt; Tags { get; set; } public DateTime CreationTime { get; } public Guid CreatorId { get; } public BlogUser Creator { get; } public DateTime? LastModificationTime { get; } public bool IsDeleted { get; } public DateTime? DeletionTime { get; } public object[] GetKeys() { return new object[]{Id}; } private Post() { }//无参构造函数供EFCore使用 public Post(Guid id, BlogUser creator, string title, string markdown = \u0026#34;\u0026#34;, Category? category = null, ICollection\u0026lt;Tag\u0026gt;? tags = null) { Id = id; Title = title; Markdown = markdown; Category = category; Tags = tags ?? new List\u0026lt;Tag\u0026gt;(); Creator = creator; } } Abp框架提供了许多实体基类和接口，这里实现了：\nIEntity: 实现Id属性和GetKeys方法并使用Guid作为主键类型，GetKeys方法返回一个主键数组用于排列（Abp考虑到复合主键所以返回数组）。 IHasCreationTime: 实现创建时间(CreationTime)属性。 IMustHaveCreator\u0026lt;BlogUser\u0026gt;: 实现创建者Id(CreatorId)以及其实体类导航属性Creator（适用于EFCore），创建者的实体类型为BlogUser。 IHasModificationTime: 实现最近修改时间(LastModificationTime)属性。 IHasDeletionTime: 实现软删除，IsDeleted属性以及DeletionTime属性。 如果实体继承或是实现了这些Abp框架提供的基类或是接口，Abp框架就会尽可能的自动管理这些属性。 关于软删除 # 在使用Abp框架提供的仓储接口对实现软删除接口进行删除时，会自动将IsDeleted属性置为true，而不是删除实体，更多关于Abp框架中软删除的实现，参考\r数据过滤文档\n关于领域驱动设计 # 在Abp框架中定义了领域驱动设计所用的聚合根(AggregateRoot)基类和接口，它们提供了如并发控制，审计等各种实现聚合根所需的各种方法，并且Abp框架默认会自动为聚合根创建并注入\r仓储。该项目相对简单，为避免繁琐，实体使用贫血模型，不实现Abp提供的聚合根接口，而是手动地实现一些需要的、Abp提供的审计接口。关于Abp的聚合根和实体，参考\r实体文档。\n\u0026ldquo;ABP框架不强制你应用任何DDD规则或模式.但是,当你准备应用的DDD规则或模式时候,ABP会让这变的可能而且更简单.文档同样遵循这个原则.\u0026rdquo;\n关于Guid类型主键 # Guid类型很好地避免了主键重复的情况，但因为Guid的无序性，数据库根据Guid主键创建的索引会在插入时带来严重的性能影响(因为插入新记录可能需要对现有记录进行重新排序)。\nAbp框架提供了解决方案：\rGuid生成器，框架提供了IGuidGenerator接口，它可以生成连续的Guid值，这对数据库的聚集索引非常重要，所以不要用Guid.NewGuid方法生成Guid值，而是用Abp框架的Guid生成器。\n使用Abp的应用服务基类(ApplicationService)时无需注入IGuidGenerator，Abp框架已经将其定义在ApplicationService的GuidGenerator属性中，调用它的Create方法即可。\n关于更多实体信息以及基类和接口参考\r基类和接口的审计属性\n编写实体类 # 按照Abp框架实体类的规则，编写其他实体类：\nCategory.cs\nusing System; using System.Collections.Generic; using Volo.Abp.Domain.Entities; namespace Azusa.AbpBlog.Entities.Blog; public class Category : IEntity\u0026lt;Guid\u0026gt; { public Guid Id { get; } public string Name { get; set; } public ICollection\u0026lt;Post\u0026gt; Posts { get; set; } private Category() { }//EFCore public Category(Guid id, string name) { Id = id; Name = name; Posts = new List\u0026lt;Post\u0026gt;(); } public object[] GetKeys() { return new object[] { Id }; } } Tag.cs\nusing System; using System.Collections.Generic; using Volo.Abp.Domain.Entities; namespace Azusa.AbpBlog.Entities.Blog; public class Tag : IEntity\u0026lt;Guid\u0026gt; { public Guid Id { get; } public string Name { get; set; } public ICollection\u0026lt;Post\u0026gt; Posts { get; set; } private Tag() { }//EFCore public Tag(Guid id, string name) { Id = id; Name = name; Posts = new List\u0026lt;Post\u0026gt;(); } public object[] GetKeys() { return new object[] { Id }; } } BlogUser.cs\nusing System; using Volo.Abp.Domain.Entities.Auditing; namespace Azusa.AbpBlog.Identity; public class BlogUser : FullAuditedEntity\u0026lt;Guid\u0026gt; { public string UserName { get; set; } public string PasswordHash { get; set; } public string Email { get; set; } public string? Avatar { get; set; } private BlogUser() { }//EFCore public BlogUser(Guid id, string userName, string password, string email, string avatar) : base(id) { UserName = userName; PasswordHash = SecurePasswordHasher.Hash(password);//哈希加密密码 Email = email; Avatar = avatar; } } 使用EFCore进行数据库迁移 # 在DbContext中添加实体 # 首先在Azusa.AbpBlog.EntityFrameworkCore项目的EntityFrameworkCore文件夹中，找到AbpBlogDbContext类（这个类是根据项目名命名的），Abp框架已经自动生成了EFCore需要的DbContext类。在类中添加刚才创建的实体：\n... public class AbpBlogDbContext : AbpDbContext\u0026lt;AbpBlogDbContext\u0026gt;, IIdentityDbContext, ITenantManagementDbContext { /* Add DbSet properties for your Aggregate Roots / Entities here. */ public DbSet\u0026lt;Post\u0026gt; Posts { get; set; } public DbSet\u0026lt;Category\u0026gt; Categories { get; set; } public DbSet\u0026lt;Tag\u0026gt; Tags { get; set; } public DbSet\u0026lt;BlogUser\u0026gt; BlogUsers { get; set; } ... ### 配置表映射 在`AbpBlogDbContext`的`OnModelCreating`方法中添加实体配置： ```cs protected override void OnModelCreating(ModelBuilder builder) { ... /* Configure your own tables/entities inside here */ //从程序集中获取实体配置 builder.ApplyConfigurationsFromAssembly(GetType().Assembly); ... } 项目将实体的配置单独写在类中，在Azusa.AbpBlog.EntityFrameworkCore项目中创建EntityConiguration文件夹，用于存放配置EFCore的实体映射配置。\nEFCore配置实体\nPostConfig.cs\nusing Azusa.AbpBlog.Entities.Blog; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata.Builders; namespace Azusa.AbpBlog.EntityConfigurations.Blog; public class PostEntityConfig : IEntityTypeConfiguration\u0026lt;Post\u0026gt; { public void Configure(EntityTypeBuilder\u0026lt;Post\u0026gt; builder) { builder.ToTable(\u0026#34;T_Posts\u0026#34;); builder.Property(p =\u0026gt; p.Title).HasMaxLength(64); //Category一对多关系 builder.HasOne(p =\u0026gt; p.Category).WithMany(c =\u0026gt; c.Posts); //Tag多对多关系 builder.HasMany(p =\u0026gt; p.Tags).WithMany(t =\u0026gt; t.Posts); //BlogUser一对多关系 builder.HasOne(p =\u0026gt; p.Creator).WithMany().HasForeignKey(p =\u0026gt; p.CreatorId); } } CategoryEntityConfig.cs\nusing Azusa.AbpBlog.Entities.Blog; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata.Builders; namespace Azusa.AbpBlog.EntityConfigurations.Blog; public class CategoryEntityConfig : IEntityTypeConfiguration\u0026lt;Category\u0026gt; { public void Configure(EntityTypeBuilder\u0026lt;Category\u0026gt; builder) { builder.ToTable(\u0026#34;T_Categories\u0026#34;); builder.Property(c =\u0026gt; c.Name).HasMaxLength(64); builder.HasMany(c =\u0026gt; c.Posts).WithOne(p =\u0026gt; p.Category); } } TagEntityConfig.cs\nusing Azusa.AbpBlog.Entities.Blog; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata.Builders; namespace Azusa.AbpBlog.EntityConfigurations.Blog; public class TagEntityConfig : IEntityTypeConfiguration\u0026lt;Tag\u0026gt; { public void Configure(EntityTypeBuilder\u0026lt;Tag\u0026gt; builder) { builder.ToTable(\u0026#34;T_Tags\u0026#34;); builder.Property(t =\u0026gt; t.Name).HasMaxLength(64); builder.HasMany(t =\u0026gt; t.Posts).WithMany(p =\u0026gt; p.Tags); } } BlogUserEntityConfig.cs\nusing Azusa.AbpBlog.Entities.Identity; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata.Builders; namespace Azusa.AbpBlog.EntityConfigurations.Blog; public class BlogUserEntityConfig : IEntityTypeConfiguration\u0026lt;BlogUser\u0026gt; { public void Configure(EntityTypeBuilder\u0026lt;BlogUser\u0026gt; builder) { builder.ToTable(\u0026#34;T_BlogUsers\u0026#34;); builder.Property(user =\u0026gt; user.UserName).HasMaxLength(24); builder.Property(user =\u0026gt; user.PasswordHash).HasMaxLength(200); builder.Property(user =\u0026gt; user.Email).HasMaxLength(200); } } 配置种子数据 # 在.Domain项目中创建AbpBlogDataSeedContributor类。\nusing System; using System.Threading.Tasks; using Azusa.AbpBlog.Entities.Blog; using Azusa.AbpBlog.Entities.Identity; using Volo.Abp.Data; using Volo.Abp.DependencyInjection; using Volo.Abp.Domain.Repositories; using Volo.Abp.Guids; namespace Azusa.AbpBlog; public class AbpBlogDataSeedContributor: IDataSeedContributor,ITransientDependency { private readonly IRepository\u0026lt;Post, Guid\u0026gt; _postRepos; private readonly IRepository\u0026lt;BlogUser, Guid\u0026gt; _userRepos; private readonly IGuidGenerator _guidGenerator; public AbpBlogDataSeedContributor(IRepository\u0026lt;Post, Guid\u0026gt; postRepos, IRepository\u0026lt;BlogUser, Guid\u0026gt; userRepos, IGuidGenerator guidGenerator) { _postRepos = postRepos; _userRepos = userRepos; _guidGenerator = guidGenerator; } public async Task SeedAsync(DataSeedContext context) { if (await _postRepos.GetCountAsync() \u0026lt;= 0) { if (await _userRepos.FindAsync(user =\u0026gt; user.UserName == \u0026#34;AzusaAdmin\u0026#34;) == null) { var user = new BlogUser(_guidGenerator.Create(), \u0026#34;AzusaAdmin\u0026#34;, \u0026#34;VanitasVanitatum\u0026#34;, \u0026#34;2817212736@qq.com\u0026#34;); await _userRepos.InsertAsync(user,autoSave:true); await _postRepos.InsertAsync(new Post(_guidGenerator.Create(), user, \u0026#34;Hello World\u0026#34;, \u0026#34;初始化数据\u0026#34;),autoSave:true); } } } } Abp框架提供了\r种子数据系统用来创建数据库的初始数据，创建一个IDataSeedContributor接口的实现类来配置种子数据，Abp框架将会自动将程序集中实现IDataSeedContributor接口的实现类加入依赖注入并在.DbMigrator项目运行并应用数据库迁移时执行，由此来创建数据库的初始数据。\n上面的类在SeedAsync方法中配置了种子数据的生成，在没有任何文章存在且名为 \u0026ldquo;AzusaAdmin\u0026rdquo; 的用户不存在时，自动创建并插入数据表。类中使用了Microsoft.DependencyInjection注入了相应表的仓储以及上述的IGuidGenerator接口，Abp自动将常用的服务加入了依赖注入容器，并且，在DbContext中配置的DataSet对应实体的仓储也将默认被加入依赖注入容器。\n在.EntityFrameworkCore项目中的AbpBlogEntityFrameworkCoreModule类中，配置了该Abp模块的服务，可以看到在ConfigureServices方法中加入了DbContext依赖：\npublic override void ConfigureServices(ServiceConfigurationContext context) { context.Services.AddAbpDbContext\u0026lt;AbpBlogDbContext\u0026gt;(options =\u0026gt; { /* 该方法会将所有聚合根对应的仓储加入依赖注入， 如果方法的includeAllEntities参数设为true， 则为所有DbSet中配置实体创建仓储并加入依赖注入 */ options.AddDefaultRepositories(includeAllEntities: true); }); Configure\u0026lt;AbpDbContextOptions\u0026gt;(options =\u0026gt; { /* The main point to change your DBMS. * See also AbpBlogMigrationsDbContextFactory for EF Core tooling. */ options.UseSqlServer(); }); } Abp中的仓储\nAbp中的EFCore集成\n生成数据库迁移 # 配置完后，生成AbpBlogDbContext的数据库迁移。\nadd-migration Add_Post_Category_Tag -Context AbpBlogDbContext 使用Visual Studio包管理器命令行或是其他工具进行EFCore数据库迁移。\n注意，使用包管理器命令行生成EFCore迁移需要先安装 Microsoft.EntityFrameworkCore.Tools 包，Abp框架默认会在创建项目的时候预安装。\n然后运行.DbMigrator项目，Abp框架自动将DbContext加入了依赖，该项目会自动应用存在的数据迁移脚本，并且根据刚才的配置创建种子数据，不建议使用Update-Database或是其他迁移工具进行迁移。\n执行完后生成了一堆表，大部分是Abp框架的配置，日志，Identity框架，Tenant框架所用的表，其实用不上。 (在之后可能会对项目和表进行简化吧\u0026hellip;\nEFCore迁移文档\n至此，项目基本实体以及数据库迁移应当创建完毕。\n","date":"2023年4月14日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%9F%BA%E4%BA%8Eabp%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB/","section":"Posts","summary":"","title":"基于Abp框架的博客项目：实体和数据库迁移"},{"content":"\r开始 # 该系列文章记录ABP框架的学习过程，将使用ASP .NET Core ABP框架开发一个博客项目：数据库选用SQL Server + EFCore，前端框架选用Blazor WebAssembly，ABP框架的版本为7.1，项目将使用\r领域驱动设计分层。\nABP快速入门文档 官方文档是最好的教程\n安装ABP框架 # 首先使用.NET CLI安装ABP框架：\ndotnet tool install -g Volo.Abp.Cli 安装Redis # 参考 Redis官方文档 安装Redis客户端，\n或是访问 http://redis.com/try-free/ 可使用 Redis Cloud 免费提供的服务器（虽然只有30M容量）。\n安装NPM # 访问 Node.js官网 下载并安装Node.js客户端。\n创建ABP解决方案 # 切换到终端到项目文件夹，然后用ABP CLI创建项目：\nabp new Azusa.AbpBlog -u blazor --separate-auth-server 项目名为 Azusa.AbpBlog -u 指定前端框架，该项目使用 Blazor WASM \u0026ndash;separate-auth-server 参数用于将Identity Server应用程序与API主机应用程序分隔开. 如果未指定, 则服务器上将只有一个端点. 详细的命令见\rABP CLI 文档 执行完后目录下将会出现项目解决方案，解决方案结构为：\nAzusa.AbpBlog.Application\n应用层，包含应用服务的接口实现。\n引用 .Application.Contracts 项目，因为接口在那里。\n引用.Domain项目，它需要使用领域对象。\nAzusa.AbpBlog.Application.Contracts\n应用层契约(Contract)，主要包含应用服务的抽象接口，以及应用层的数据传输对象DTO，它用于分离应用层的接口和实现. 这种方式可以将接口项目做为约定包共享给客户端。\n引用 .Domain.Shared 项目。\nAzusa.AbpBlog.AuthServer\n独立的身份验证服务器项目，该项目有独立的配置文件以及用户界面，前端项目调用该服务器进行用户认证和登录，获取到 Bearer Token 以后再访问API服务器。该项目使用 IdentityServer ，还提供了独立的用户界面 (ASP .NET Core MVC)。\n引用 .Domain 项目\n引用 .EntityFrameworkCore 项目\nAzusa.AbpBlog.Blazor\n前端项目，提供用户界面。\n引用 .Application.Contracts 项目，获取DTO\n引用 .HttpApi.Client 项目\nAzusa.AbpBlog.DbMigrator\n控制台应用程序，可以使用它创建数据库，应用数据库迁移，初始化种子数据。\n引用 .Application.Contracts 项目，因为它需要访问权限定义在初始化种子数据时为管理员用户赋予所有权限。\n引用 .EntityFrameworkCore.DbMigrations 项目，因为它要进行迁移。\nAzusa.AbpBlog.Domain\n领域层，它主要包含实体,聚合根,领域服务,值对象,仓储接口和解决方案的其他领域对象。\n引用 .Domain.Shared 项目。\nAzusa.AbpBlog.Domain.Shared\n公共项目，包含常量，枚举或其他对象。\n不依赖于其他项目，其他项目直接或间接地引用该项目。\nAzusa.AbpBlog.EntityFrameworkCore\nEFCore的项目，定义了DbContext类，并对领域层中声明的仓储类接口进行实现。\n因为EFCore已经实现了仓储模式，在这里重新封装一次其实没有好处，在应用层直接引用EFCore项目会更加简洁，不过既然要符合ABP框架的领域驱动设计，再次封装也无妨。\nAzusa.AbpBlog.EntityFrameworkCore.DbMigrations\n这个项目不会自动创建，之后的文章会提到，该项目专门用于整合DbContext类的迁移。\n引用 .EntityFrameworkCore 项目。\nAzusa.AbpBlog.HttpApi\n用于定义API控制器，不过通常ABP框架可以根据应用层自动创建API控制器。\n引用 .Application.Contracts ，因为它需要应用服务的接口(interface)。\nAzusa.AbpBlog.HttpApi.Client\n定义C#客户端代理使用解决方案的HTTP API项目。\n引用 .Application.Contracts 项目，因为它需要使用应用服务接口和DTO。\nAzusa.AbpBlog.HttpApi.Host\n后端 Web API 启动项目，它有独立的配置文件。\n依赖于大部分项目。\n项目结构文档\n运行解决方案 # 修改配置文件 # 修改以下项目中appsettings.json里的连接字符串。\nAzusa.AbpBlog.AuthServer的连接字符串，该数据库负责认证服务。\nAzusa.AbpBlog.HttpApi.Host的连接字符串，主要的数据库。\nAzusa.AbpBlog.DbMigrator的连接字符串，该项目用于生成数据库迁移。\n项目使用的是SQL Server Express数据库。\n\u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Server=ALICIA\\\\SQLEXPRESS;User Id=Azusa;Password=12345678;Database=db_AbpBlog;Trusted_Connection=True;TrustServerCertificate=True\u0026#34; }, 分层项目使用 Redis 作为缓存服务器，首先需要安装Redis客户端。\n在Azusa.AbpBlog.HttpApi.Host项目\n以及Azusa.AbpBlog.AuthServer项目中的appsettings.json文件进行配置，\n默认情况下，ABP框架使用本机地址：\n\u0026#34;Redis\u0026#34;: { \u0026#34;Configuration\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, 如果使用远程服务器，需要修改该配置。\n数据库迁移 # 初次迁移：\n.dbMigator 应用程序在首次运行时自动创建初始迁移.\n如果你使用的是 Visual Studio, 你可以跳到 运行 dbMigrator 部分。\n但是, 其他 IDE (例如 Rider) 在首次运行时可能会遇到问题, 因为它会添加初始迁移并编译项目。\n在这种情况下, 请在 .dbMigration 项目的文件夹中打开命令行终端, 然后运行以下命令:\ndotnet run 下次, 你可以像往常一样在 IDE 中运行它.\n执行迁移\n运行Azusa.AbpBlog.DbMigrator项目，它会自动执行迁移。\n迁移执行成功后，会输出以下内容：\n运行项目 # 运行Azusa.AbpBlog.HttpApi.Host项目\n执行该项目会启动Web API项目，默认访问 https://localhost:44320/swagger/index.html 查看Swagger UI。\n运行Azusa.AbpBlog.AuthServer项目\n启动用户认证服务，默认访问 https://localhost:44326 查看用户认证页面。 运行Azusa.AbpBlog.Blazor项目\n启动Blazor客户端，默认访问 https://localhost:44373/ 查看客户端页面。 点击页面右上角的 login 按钮进行登录，该操作将会访问 .AuthServer 项目的 API。\n此页面是 AuthServer 项目提供的，可以看到页面的URL并不是Blazor项目的： 默认的用户名和密码为admin和1q2w3E*。\n异常和解决方案 # 运行.AuthServer项目时抛出 AbpException: Could not find the bundle file '/libs/abp/core/abp.css' for the bundle 'LeptonXLite.Global'! 异常：\n查看这篇文章可解决： https://stackoverflow.com/questions/70236519/invalidoperationexception-cannot-find-compilation-library-location-for-package\n运行.AuthServer项目时抛出AbpException:Could not find the bundle file '/libs/abp/core/abp.css' for the bundle 'LeptonXLite.Global'!异常：\n项目缺少 Node.js 依赖，先检查Node.js是否正常安装并添加至环境变量，确认安装后，在解决方案目录使用打开命令提示符输入:\nabp install-libs 他将自动调用 Node.js 下载项目依赖的 NPM 包，下载完毕后重新运行项目即可。\n至此，项目的创建和运行应当全部完成。\n","date":"2023年4月13日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%9F%BA%E4%BA%8Eabp%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8abp%E6%A1%86%E6%9E%B6%E5%88%9B%E5%BB%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","section":"Posts","summary":"","title":"基于Abp框架的博客项目：使用Abp框架创建解决方案"},{"content":" 本文章将举例介绍绝大多数C# 10的新特性，在.NET 6以上的项目支持这些特性。\n有些预览特性需要在项目配置文件(.csproj)中配置\u0026lt;LangVersion\u0026gt;preview\u0026lt;LangVersion/\u0026gt;才可生效\nC#10新增功能\n全局Using # 在任何一个C#类中使用global关键字修饰using指令，该using指令将会应用于整个项目\nglobalUsing.cs\n//这些using将会应用到整个项目 global using System.Collection.Generic; global using Newtonsoft.Json; ... 文件范围的命名空间 # 在C#文件中指定命名空间时可以不用花括号{}了，该命名空间将会应用于整个文件范围。但相反的，你无法在一个cs中定义多个命名空间中的内容（一般来说也不会这样做）。\nusing System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using Microsoft.IdentityModel.Tokens; namespace Azusa.Shared.Security;//不使用{}指定范围，整个文件都将被定义到该命名空间中。 public static class JwtTokenGenerator { ... } 常量内插字符串 # 你可以在const string中使用内插字符串了，你可以将用在某些只接受常量字符串的地方。\n... private const string BaseUrl = \u0026#34;localhost:7890\u0026#34;; public const string SignInUrl = $\u0026#34;{BaseUrl}/SignIn\u0026#34;;//你可以使用$内插常量字符串了 ... [HttpGet(SignInUrl)]//在这种地方适合使用常量字符串！ 泛型特性（注解） # C#特性也支持泛型了，传递类型参数更加方便，不需要typeof了。\npublic class UnitOfWorkAttribute\u0026lt;TDbContext\u0026gt; : Attribute where TDbContext : DbContext { ... } Lambda表达式改进 # var关键字可以推断lambda表达式的返回值了\nvar func = () =\u0026gt; \u0026#34;Nice\u0026#34;;//现在编译器可以推断出这个lambda是Func\u0026lt;string\u0026gt;了 var func1 = () =\u0026gt; null;//不过这样是不行的，因为null没有类型 var func2 = string? () =\u0026gt; null;//但是可以显式指定一下 特性也可以支持在lambda上标注了\nvar func3 = [UnitOfWorkAttribute\u0026lt;MyDbContext\u0026gt;()](long id) =\u0026gt; myDbCtx.Books.Find(id); 模式匹配属性扩展 # 在模式匹配的时候可以匹配对象的属性，并且用成员运算符.来匹配属性对象的属性\nif (book is Book{PubTime.Month:12})//用成员运算符来读取对象属性的属性 { ... } //以前得这样 if (book is Book { PubTime: { Month: 12 } }) { } 记录(record)结构体 # record类型也可以声明为结构体了，也是值类型。\npublic record struct Color(short Red, short Green, short Blue); 结构体的优化 # 在C#10以前，结构体的显式构造函数必须得给所有字段和自动属性赋值 比如这样一个结构体\npublic struct Color { public short Red { get; set; } public short Green { get; set; } public short Blue { get; set; } ... } 构造函数要么不写（隐式无参），要么写全（显式，并且所有自动属性和字段都得赋值）\n（很迷惑的操作，不知为何要这样设定）\n... public Color(short red, short green, short blue)//字段和自动属性都得赋值 { Red = red; Green = green; Blue = blue; } ... C#10以后，将接受赋值不完全的显式构造函数\npublic Color(short red, short green) { Red = red; Green = green; } 并且，C#10的结构体也支持with关键字\nvar color = new Color(122, 255, 255); var color1 = color with { Green = 12 }; 在同一析构中进行赋值和声明 # 可以通过析构对象来给变量赋值，或是\n(int x, int y) = point;//析构对象来初始化两个变量，注意这不是元组 int x1 = 0; int y1 = 0; (x1, y1) = point;//析构对象给现有变量赋值 在C#10以前初始化和赋值不能同时进行\nint x = 0; (x, int y) = point;//C#10以前会错误 但现在不会\n","date":"2023年4月12日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/csharp10%E6%96%B0%E7%89%B9%E6%80%A7/","section":"Posts","summary":"","title":"C#10新增功能"},{"content":"","date":"2023年4月12日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/csharp%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"CSharp基础"},{"content":"\r驾驶证 # 常规 # 年龄要求： c1,c2: 18+无上限 c6:20-60 货车：20+ 有效期： 6年-\u0026gt;10年-\u0026gt;长期 体检： 中大型公交牵引车每年体检 任何限时题目： 有90日选择90日，否则选择30日 驾驶证周期： 12月 驾驶证实习期： 12月 有效期： 准考证3年内，实习期需要3年驾龄司机陪同，延期审验3年 证件相关： # 车“登记”，证随意\n驾驶证遗失损毁补领，任意地点均可 证件带有“车”字需要在登记地处理 车辆变化除防撞杆，都需要登记 不得申请驾驶证时间 # 假1骗3毒3醉5逃逸犯罪终生\n满分教育 # 现场学习至少2天，网络学习至少3天，总计至少7天 扣满每12分学习7天，小车最多60天 扣满12分重学科目1，24-35重学科目1科目3，36+重学科目123 学习减分 # 实习期内不可以参与 酒驾处罚三个周期内不能参与 两次以上满分教育不能参与 每次参与最多减六分 网络学习30分钟减1分，现场学习1小时减2分，公益活动1小时减1分 证件车辆扣留 # 缺少 驾驶证|行驶证|保险标识|检验合格标识|车牌 扣留\n刑法 # 重大事故致人死亡 - 3年 致人死亡逃逸 - 3-7年 因逃逸致人死亡 - 7年+ 组织作弊形成犯罪 - 3-7年 其他拘役 选择题：有拘役则对，有刑结尾则错\n事故处理 # 有争议则报警 无争议则撤离，不撤离罚款200 救援 # 骨折要固定，不要移动 失血先止血，止血按压近心端 燃烧喷冷水，其他会感染 顺序通行 # 常规 # 右转让左转，左转让直行 超车从左侧 特殊路段不能超车 有特殊车辆不能超车 不走公交车道 会车时 # 山体外侧先行 环岛内先行 无障碍先行 主路车先行 下坡车先行 校车 # 两车道停车等待 三车道变最左道超车 车辆故障 # 开危险警报闪光灯 防止警报标志 50 - 100m，高速路150m+ 停车距离 # 路口5站3，题中带有“路/口”（路口，道口，危险狭窄路段）则50m，带有“站”（车站，加油站）则30m\n灯光 # 雾灯：除了雾天使用，其他都错 危险警报闪光灯：停车，故障，雾天，牵引故障车 左右转向：转弯，变道，停车时打右转向，闸道进道路打左转向 远光灯：照明不足 闪烁：超车，通过路口，通过人行道，急弯道路 其他情况均为近光灯 切换远近灯光距离为150m 速度和距离 # 特殊道路 # 无标识情况，特殊道路全部为30km/h 普通道路 # 无线：“城3公4”，有线：“城5公7”\n有中心线：城市50，公路70 无中心线：城市30，公路40 高速行驶能见度 # 能见度200m：车速小于60，行车距离100m 能见度100m：车速小于40，行车距离50m 能见度小于50m：车速小于20，尽快离开 高速速度 # 100km/h：距离100m \u0026lt;100km/h：距离50m 高速限速 # 有标识优先按标识\n3车道：左11-12，中9-11，右6-9 2车道：左10-12，右6-10 停车 # 停车 # 单条斜杠：禁止长时间停车 叉：禁止停车 地面标识 # 路沿上黄线：虚线禁止长时间停车，实线禁止停车 计分 # 扣分值仅为3分的幂\n超速 # 普通道路 # 超速20%-50%，扣3分 超速50%+，扣6分 高速公路翻倍 # 超速20%-50%，扣6分 超速50%+，口12分 其他 # 大型车在高速以外超速10%-20%，扣1分 高速低于最低时速，扣3分 超员 # 大型汽车 # 超出核定人数20%以下，扣6分 超出核定人数20%以上，扣12分 七座以上载客汽车 # 超出核定人数50%以下，扣6分 超出核定人数50%-100%，扣9分 超出核定人数100%以上，扣12分 其他载客汽车 # 超出核定人数20%-50%，扣3分 超出核定人数50%-100%，扣6分 超出核定人数100%以上，扣12分 超载 # 超载30%以下，扣1分 超载30%-50%以下，扣3分 超载50%以上，扣6分 安全检验 # 校车，大型车未定期安全检查，扣3分 其他车辆扣1分 道路行驶 # 普通道路 # 不按规定回车，掉头，逆行：3分 不规避行人：3分 不规避校车：3分 借道占道：3分 闯红灯：6分 高速公路 # 不按规定车道行驶：3分 倒车，逆行：12分 违法停车：9分 占用应急车道：6分 车牌 # 不按规定安装车牌号（并非伪造遮挡）：3分 故意遮挡，伪造车牌号：9分 驾驶证 # 驾驶证被暂扣期间驾驶机动车：6分 驾驶车型不符：9分 疲劳驾驶 # 载货汽车：6分 载客汽车：9分 其他1分考点 # 违反标线 不按规定使用灯光 未系安全带 载货车长宽高超出规定 擅自改装 其他3分考点 # 接听手机 故障，事故后没有摆放标识和使用灯光 没有对校车安全隐患检查 其他6分考点 # 事故逃逸，无死亡，轻伤 ","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%85%B3%E9%94%AE%E8%AF%8D%E8%AE%B0%E5%BD%95/","section":"Posts","summary":"","title":"科目一关键词记录"},{"content":"","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/%E5%85%B6%E4%BB%96/","section":"Categories","summary":"","title":"其他"},{"content":"","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/oop/","section":"Tags","summary":"","title":"OOP"},{"content":" 在阅读前你需要先掌握C#类的语法并了解类与对象的基本概念。\n概念 # 顾名思义面向对象编程即是将真实事物在代码中抽象地表达出来，以现实世界中解决问题的思路来解决程序上的问题。在C#中，事物的类型即为类(class)，类中定义了该事物的数据和操作数据的方法，每个事物对应着一个对象(object)。面向着对象编程即为OOP(Object-Oriented Programing)。\nOOP最大的特点即“面向对象”，整个编程的流程都是围绕着类与对象的。\n举例说明： 以经典的银行存取款例子来讲，假定一个文件中保存着你银行的余额，当你需要编写一个程序对该文件进行操作，提供存取款的功能时，传统面向过程编程的流程应该是：\n打开文件，读取余额并创建一个变量来缓存。 若要存款，则输入金额 在余额变量上加上输入的金额 将余额写入到文件 若要取款，则输入金额 在余额变量上减去输入的金额 将余额写入到文件 面向对象编程的流程应该是：\n定义一个ATM类，拥有余额字段，存款方法，取款方法 完善类方法，存款方法将输入的金额加到余额字段上，然后写入文件。取款方法将余额减去输入的金额，然后写入文件 打开文件，读取余额并创建一个ATM对象，使用余额初始化该对象。 若要存款，则调用ATM对象的存款方法 若要取款，则调用ATM对象的取款方法 OOP的优点：\n面向对象编程所作的流程明显更符合人类实际思考方式，这样能提高代码的可读性，使代码更容易理解和维护。 类与对象的封装增强了代码的复用性，减少重复的工作和开发。 面向对象增强了程序的模块化程度，减少模块之间的耦合性，提高程序灵活性和扩展性。 类的多态性实现了不同对象对同一事件的不同响应，增强了程序的多样性。 面向对象的特征 # 抽象 # 定义 # 抽象指将同类对象中提取出共性的特性，然后形成一个类(class)\n在C#中，类与类直接只能单一继承，不能继承多个类。\n例子 # 下面的代码提供了一个类的示例，将一个姓名属性和更改姓名的方法封装到一个Person类中：\npublic class Person { //姓名属性 public string Name { get; } //方法 public void ChangeName(string name) { Name = name; } } 在编程时，可以使用该类作为一个Person对象，并可以读取和更改其姓名\n抽象的好处 # 抽象化模拟了现实世界的事物和行为，提高了代码可读性。 增强了代码模块化程度 降低了代码的耦合和复杂度 封装 # 定义 # 封装指隐藏类/对象内部的状态和功能，仅通过一组公共的成员来进行访问\n对类中的成员添加访问修饰符以指定成员的访问级别。\nC#中访问修饰符有四种:\nprivate:私有，只有当前类内部的才能访问\npublic:共有，公开访问，类的内外都可以访问\nprotected:保护，只有继承自该类的类可以访问\ninternal:内部，类的内外都可以访问，但仅限当前程序集\n其中，internal修饰符可以与其他三个叠加使用，如internal public即是在当前程序集中的类内外都可以访问。\n不指定访问修饰符的类默认为private\n例子 # 下面的代码举出了访问修饰符的例子：\npublic class Person { //私有修饰符 private string name; public string GetName() { //在类的内部可以访问 return name; } } public class Program { static void Main(string[] args) { Person p = new Person(); p.name; } } 使用访问修饰符限制了类中成员的访问级别，实现隐藏成员的效果，达到封装的目的。\n封装的好处 # 类的封装可以保护类内部的数据和代码不被外部访问，提高代码的安全性 封装隐藏了类中方法/属性的实现细节，只向外暴露简单的成员，外部调用时只需要知道该成员是干什么用的，而无需知道如何实现的，简化了操作。 在修改一个类的代码时，不会影响到其他类，除非修改的是公共成员并且该成员被其他类所调用 继承 # 定义 # 根据现有抽象创建新的抽象，说人话就是在原有类的基础上进行拓展，保留原有类的所有能力，在新的一个类上创建新的功能，此操作被称为 “继承”，原有的类被称为 “父类” 或 “基类” ，继承父类的新类被称为 “子类” 或 “派生类” ，子类继承父类的行为被称为 “派生”，可以说 “子类”继承自“父类”，而“父类”派生出“子类”。\n一般，定义复杂且多种类对象时，会把它们共性的特征集成到一个父类中，将它们独有的特征划分到子类。\n在C#中，类只能有一个基类，不能多重继承。\n例子 # 下面的代码展示了类的继承关系：\n//基类 public class Person { public string Name { get; } public void ChangeName(string name) { Name = name; } } //派生类，继承了Person类 public class Employee : Person { public string Company { get; } public void ChangeCompany(string company) { Company = company; } } //派生类，继承了Person类 public class Student : Person { public string School { get; set; } } 上述代码的Employee类继承自Person类，Studnet类也继承自了Person类，它们都会继承Person类的Name属性和ChangeName方法，但它们也有自己独有的属性和方法。\nbase关键字 # 在子类中使用base关键字可以访问到父类的公开或保护内容\npublic class Employee : Person { ... public string GetName() { //使用base关键字访问父类的公开属性 return base.Name; } //使用base关键字访问父类的构造函数，如果父类的构造函数有参数，可以在这里传递 public Employee() : base() {} } sealed关键字 # 如果不想让某个类被继承，在声明类时添加sealed关键字，它阻止其他类继承该类。\n//其他类若尝试继承Boss类将会有编译错误 public sealed class Boss : Person { ... } 继承的好处 # 优化类之间的关系，减少冗余，提高代码的复用性，减少错误的可能。 提供 “多态性” 多态 # 定义 # 多态也是面向对象的核心，它指跨多个抽象以不同方式实现继承属性或方法的能力。多态的实现依赖于继承，所以必须要定义多个类并有继承关系，派生类可以各自对父类的方法实现进行修改，在调用时表现出不同的行为，大大增加编程的灵活度。在使用类时，使用多个派生类实例化出多个对象，对这些对象调用同样的基类方法，但却表现出不同的行为，这便是多态。\n下面是实现多态必要的一些概念：\n抽象类 # 将对象或已有的类更加抽象化成为一个新的类，以至于无法具体化（无法创建出该类的对象，因为过于抽象而缺少某些创建类所必要的数据或方法）。这样的类被称为抽象类，在类修饰符class前加上abstract修饰符将定义的类转换为抽象类，抽象类无法被实例化，只能称为其他类的基类。\n抽象类可以有构造函数，但是不能够使用new实例化，构造函数仅供子类使用。 虚方法 # 有时将已有类的提取成基类后，会遇到部分子类对与某些方法的实现方式不一致。在类中定义方法时加上virtual关键字，可让子类使用override关键字重写基类方法的实现。\n举一个现实中的例子：以前的所有轿车都是由燃油驱动的，它们有着“移动”行为，并且该都是以\u0026quot;燃油驱动\u0026quot;。但随着时代变化，出现了电力驱动的轿车，即使驱动原理不一样了，但它们还是有着“移动”行为。\n从编程方面来看，轿车类Car有着Move方法，该方法是“由燃油驱动的”，但出现了新的类ElectricCar电动车类，它继承自Car类，但是它对Move方法的实现却不一样，它是“电力驱动的”。此时，可以将Car类中的Move方法标记为虚方法virtual，然后在派生类中重写该方法。\n下面的类定义了一个轿车类，有着用燃油驱动的Move方法：\npublic class Car { //使用virtual关键字定义虚方法 public virtual void Move() { //用燃油驱动 ... } } 有一个类ElectricCar继承了Car类，并重写了父类的Move方法：\npublic class ElectricCar : Car { //使用override关键字重写父类的虚方法 public override void Move() { //用电力驱动 ... } } 此时使用Car类和ElectricCar类分别实例化出对象，调用Move方法，它们表现出的行为将不一致。\n... Car c = new Car(); //燃油驱动 c.Move(); ElectricCar ec = new ElectricCar(); //电力驱动，该派生类重写了Move方法 ec.Move(); ... 在类中使用virtual关键字在方法前标注，来声明一个虚方法。 在派生类中使用override关键字对父类中的虚方法进行重写，修改方法的实现过程。 如果不想完全重写虚方法，只是想要在父类的方法基础上添加代码，可以在重写时用base关键字调用父类方法。 sealed关键字也适用于虚方法，它阻止派生类重写方法。 抽象方法 # 抽象方法类似于虚方法，子类可以重写方法的实现。但是有时子类对方法的实现各不相同，无法统一出一个父类的实现方法，这个方法便被抽象化成为一个抽象方法。\n抽象方法在类的方法前使用abstract关键字定义，抽象方法没有方法体，仅定义了方法名，返回值和参数。在子类同样使用override对父类的抽象方法进行重写。\n定义了抽象方法的类必须为抽象类，因为这个类有方法没有被实现，无法实例化。\n若一个类的基类是带有抽象方法的抽象类，除非该派生类也是一个抽象类，不然就必须重写所有的抽象方法。\n再举一个例子：三角形和矩形都属于“形状”，都可以求出其面积，但它们计算面积的公式是不一样的。\n从编程方面来看，三角形和矩形可以提取出一个父类Shape（形状）类，Shape类中有一虚方法Area用于计算形状的面积。三角形Triangle类和矩形Rectangle类都继承自Shape，并且重写了Area方法。\n但这样设计的问题是，Shape类过于抽象，创建成对象是没有意义的，而且无法实现Area方法，只能留空。\n此时就可以将Shape类的Area方法标记为抽象方法，并且将Shape类标记为抽象类。抽象类无法实例化，只能用来继承，抽象方法也不需要实现，只能用来重写。\n下面的代码对抽象方法进行了示例：\n//带有抽象方法的类必须为抽象类 public abstract class Shape { //使用abstract关键字声明了一个抽象方法，没有方法体。 public abstract float Area(); } public class Triangle : Shape { //使用override关键字重写了父类的抽象方法，如果没有重写该方法，将会有编译错误 public override float Area() { ... } } public class Rectangle : Shape { public override float Area() { ... } } 抽象方法不需要方法实现，只需要定义名称，参数和返回值即可，但该类的派生类必须提供重写该抽象方法。 抽象方法的访问修饰符不能为private，因为抽象方法需要子类的实现。 若一个类拥有抽象方法，它就必须被修饰为抽象类，因为抽象方法需要一个子类提供实现。 接口 # 类抽象的极限是只包含方法，类中没有任何数据，只定义了该类的行为，这样抽象到极限的类被称为 “接口”。而继承了该类的类也不叫派生类了，它们被称为 “实现类”，而继承这一操作名也变为了 “实现”，即某类实现了某接口，定义接口的关键字不是class，变为了interface。\n接口类似于抽象类，但比抽象类更加抽象，无法定义数据，只能定义行为，而且实现接口的类都必须实现接口中定义的所有成员。\n接口一般用来定义某些行为，而不是一类事物，比如C#中的IEnumerable（可枚举）接口。某个类实现了接口，就代表它能够实现这些行为。\n在C#中，接口只能定义方法，属性，索引器和事件。 在C#中，类只能继承一个类，但允许实现多个接口，在程序中可以让类实现多个接口，以表现出各类不同的行为。在对类的功能进行拓展时，也可以添加实现的接口来让类实现相应的方法。 在C#中，接口的命名应当以字母I开头。 下面的代码展示了接口和实现类的定义：\n//使用interface关键字定义接口 public interface IMoveable { //定义接口属性 Vector2 Position { get; } //定义接口方法，无需方法体 void Move(int x, int y); } public class Car : IMoveable { //实现接口中的属性和方法 public Vector2 Position { get; } public void Move(int x, int y) { Position.x = x; Position.y = y; } } 接口定义的成员都不需要实现，实现类必须实现接口的所有成员。 接口成员可以不加访问修饰符，默认会赋予public，接口成员的访问修饰符不能为private，因为私有的接口方法没有意义。 新版本特性\n在高版本的C#，接口中的方法可以有方法体，接口中也可以定义静态抽象成员和虚拟成员，具体参考官方文档：\r接口\n替换 # 向上转换(upcasting)\n在对对象进行操作时，派生类对象的引用可以替换基类的引用：\nPerson p1 = new Person();//实例化Person对象 Employee e1 = new Employee();//实例化Employee对象 p1 = e1;//替换 上述代码演示了替换的过程，Employee类是Person类的派生，将其分别实例化出p1对象和e1对象，并将p1对象的引用替换成了e1对象。\n虽然两对象是不同类型的，但这样的替换操作是合法的，并不会有错误或警告，像这样使用派生类引用替换成基类引用的操作称为向上转换(Upcasting)。因为Employee类继承了Person类的所有数据，所以对p1对象进行的任何操作，都适用于e1对象，而不会导致任何问题。向上转换是可传递的，也就是说如果有一个类继承了Employee类，该类的对象也可以替换p1对象，因为该类也间接地继承了Person类。\n向下转换 ***向下转换(Downcasting)***和向上转换相反，即基类的引用替换派生类的引用：\nPerson p2 = new Person(); Employee e2 = new Employee(); e2 = (Employee)p2;//向下转换 上述代码演示了向下转换，向下转换是强制转换，代码中使用括号来进行强制转换，这个操作通常来说是不允许的。一个派生类可以在基类的基础上派生出新的数据成员，但这些成员并不能适用于基类对象，例如Employee类有一属性为Company，而使用Person类实例化的对象是访问不到该属性的，所以向下转换是不安全的，上述代码在运行时会报运行时错误。\n但有一种情况例外，如果转换对象是向上转换过来的，那么就不会报运行错误，例如：\nPerson e3 = new Employee();//在实例化时进行向上转换 Employee e4 = (Employee)e3;//向下转换 代码中的e3对象本身是Employee类型，但通过向上转换成了Person类型的引用，向上转换并不会清除派生类中的数据成员，所以向下转换回Employee类型时并不会报错。\n向上和向下转换也适用于抽象类和接口。\nis和as关键字\n在有些情况，向下转换操作是不可避免的。若要进行向下强制转换，可以使用C语言风格的()来强制转换，如e2 = (Employee)p2;，要是p2无法转换成e2，则会抛出异常。所以在向下转换前，通常要进行检查。\nC#提供is关键字判断对象类型，并返回true或false，在转换前使用is进行判断：\n//检查p2的类型是否是`Employee` if(p2 is Employee) { e2 = (Employee)p2; ... } C#还提供了as关键字来进行向下转换，和()的不同是，使用as转换失败并不会报错，而是返回null：\ne2 = p2 as Employee;//使用as关键字进行转换，如果失败则会返回null if(e2 == null) ...//转换失败 else ...转换成功 替换带来的多态性\n在对象向上转换过后，如果调用的方法被转换前的类型重写过，则会调用重写后的方法：\nShape t1 = new Triangle(); Shape r1 = new Rectangle(); Console.WriteLine(t1.Area()); Console.WriteLine(r1.Area()); 代码中使用Triangle类型和Rectangle类型实例化出s1和r1对象，并上转型成Shape类型，因为两个类型都重写了基类的Area方法，在调用两个对象的Area方法时，将会各自调用转换前类型调用重写后的方法，即使它们转换成了Shape类型。\n替换操作看起来会导致方法调用的混乱，但这样其实很好地运用了类的多态性。里氏替换原则提到：\n\u0026ldquo;如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致。\u0026rdquo;\n替换操作对类的通用性提升是巨大的。例如，你可以对一组继承自同一个类型的对象进行操作，它们将表现出不同的行为：\nobject[] data = { 100, \u0026#34;Alice\u0026#34;, 0.98f, Math.PI, DateTime.Now }; foreach (var obj in data) { Console.WriteLine(obj); } 上述代码使用了多个不同类型的对象初始化一个object类型的数组，在循环中，Console.WriteLine方法接收一个object类型对象，并调用对象的ToString方法，因为数组中对象的类型都各自重写了ToString方法，它们的输出将会表现出不同的效果。\n多态性的好处 # 增强了代码的通用性和简洁性，因为多态允许不同的对象执行相同的操作，但调用的方法却是同一个，这意味着程序员不需要写多个专门针对不同对象类型的方法。 增强了代码的可扩展性，当在一个较为完整的程序中添加新的对象类型，只需要选择要继承的类，实现需要的接口即可，不需要花费大量的事件思考类中有哪些成员。 面向对象五大原则（SOLID原则） # 单一职责原则，Single Responsibility Principle (SRP) # \u0026ldquo;每个模块都只有一个引起它变化的原因。\u0026rdquo;\n即一个类只负责一个功能领域的职责。单一职责原则是实现高内聚低耦合的关键，不要把太多的功能封装到类中，否则将会增加耦合度，大大降低可维护性。\n单一职责是程序设计阶段时划分类的一个好方法，只有全面了解程序的功能，才能很好地分离职责。\n开闭原则，Open/Closed Principle # “开”指对扩展开放，“闭”指对修改关闭。\n编写模块时应当尽量设计出不需要修改的模块，在扩展新功能的时候，只需要编写新的代码而无需修改旧的代码。\n满足开闭原则可以最大化模块的复用性和扩展性。\n一些设计模式很好地实现了开闭原则：如面向接口编程(Interface Based Programming)，将功能抽象成稳定的接口，在扩展代码时添加接口和实现方法即可。或是面向切面编程(AOP)，将模块分为多个层，使用事件回调等方法在层直接注入处理的代码，在添加功能时只需在需要的层中添加代码即可。\n里氏替换原则，Liskov Substitution Principle (LSP) # \u0026ldquo;如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致。\u0026rdquo;\n换句话说，派生类必须可以替换其基类。\n什么叫“与期望的行为一致”?\n“在不了解派生类的情况下，仅通过接口或基类的方法，即可清楚的知道方法的行为，而不管哪种派生类的实现，都与接口或基类方法的期望行为一致。或者说接口或基类的方法是一种契约，使用方按照这个契约来使用，派生类也按照这个契约来实现。这就是与期望行为一致的替换。”\n在运用类的多态性时，不应当违背里氏替换原则。在派生类中重写方法时，应当保证每个派生类重写方法的最终目的都是一致的，即“与期望的行为一致”。\n例如Triangle类和Rectangle类都重写了Shape类的Area方法，它们都应当保证重写后能正确返回图形的面积，而不是返回周长。\n接口隔离原则，Interface Segregation Principle (ISP) # \u0026ldquo;客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。\u0026rdquo;\n接口不应过于臃肿，尽量细化接口，减少接口中方法的数量，降低类对单个接口的依赖性。\n接口越大，它越有可能包含并非所有实现类都能使用的到的方法。如果一个类和某个接口没有一致的目的，那就不要实现那个接口。\n依赖倒置原则，Dependency Inversion Principle (DIP) # \u0026ldquo;高级模块/类不应当依赖于低级的模块/类，首先两者都应当依赖于其抽象。其次，抽象不应当依赖于实现。最后，实现应当取决于抽象。\n说人话就是，当两个模块/类有依赖关系时，首先它们都应当继承自某个类或实现某个接口。然后，在对一个派生程度较低的类进行设计时，不应当依赖于一个派生程度较高的类，应该使用其基类或是接口等派生程度较低的类进行依赖。\n当一个类依赖于另一个类的一个明确的实现时，如果依赖类的实现改变了，当前类可能会被破坏。因此，在对一个功能进行依赖时，应当面向抽象编程，而不是面向实现。\n总结 # 面向对象为编程提供了一个很好的思路，遵循SOLID原则可以构建一个代码整洁，可读性高，且易于维护的应用程序，但过于追求这些繁文缛节可能会大幅增加代码量。规则是死的人是活的，在进行编程时必须权衡这些规则带来的代码质量和代码数量，毕竟，20行代码可比200行代码要少得多。\n参考内容\n类继承：Stephen Prata. C++ Primer Plus.\nC#面向对象：\rhttps://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/oop\nC#接口：\rhttps://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface\nC#默认接口方法：\rhttps://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods SOLID原则：\rhttps://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/\n里氏替换原则：\rhttps://zhuanlan.zhihu.com/p/268574641\n","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B-csharp/","section":"Posts","summary":"","title":"面向对象的编程（C#）"},{"content":"\r.NET 表达式树 # https://zhuanlan.zhihu.com/p/247937380 https://cloud.tencent.com/developer/article/1817790\n.NET Expression表达式树将代码抽象成了一颗对象树，树上的每一个节点都是一个代码表达式，它的构造类似编译原理中的抽象语法树（AST）。\n可以使用lambda表达式进行声明表达式树，编译器将会自动转换，但是该lambda表达式不能是语句（即表达式只能有一句，不能用{}组成多句）。\n表达式树可以转换为委托，在一些linq场景可以通过构建表达式树来动态拼接一些linq查询条件。\n表达式树入门 # 一个表达式树是类似以下的结构\n表达式C | +-----+-----+ | | 表达式A 表达式B 比如简单的lambda表达式x =\u0026gt; x + 1可以用转化为以下表达式\nx + 1 | +---+---+ | | x 1 其中叶子节点x为变量表达式，叶子节点1为常量表达式，x+1节点为二叉表达式，使用了+运算符\n在C#中，表达式树可以通过Expression及其派生类的各种方法手动构建，Exression类常用的静态方法如下：\nExpression.Constant() 创建一个常量表达式。 Expression.Variable() 创建一个变量表达式。 Expression.New() 创建一个实例化表达式。 Expression.Assaign() 创建一个赋值表达式。 Expression.Equal() 创建一个相等比较表达式。 Expression.Call() 创建一个方法调用表达式。 Expression.Condition() 创建一个分支逻辑表达式。 Expression.Loop() 创建一个循环逻辑表达式。 Expression.Add()/Subtract()/Multiply()/Divide() 加/减/乘/除表达式\n\u0026hellip; 使用C#代码构造简单的表达式树 # x =\u0026gt; x + 1\npublic static void Example1() { var param1 = Expression.Variable(typeof(int), \u0026#34;x\u0026#34;);//声明变量表达式，类型为int，参数名为\u0026#34;x\u0026#34; var const1 = Expression.Constant(1);//常量表达式 var biExpr = Expression.Add(param1, const1);//声明进行加法运算的二叉表达式，左节点为x,右节点为1 //x =\u0026gt; x + 1表达式树就构成了 //使用Expression.Lambda方法可以将表达式树转换为lambda表达式树，在类型参数中可以指定转换的委托类型 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;int, int\u0026gt;\u0026gt;(biExpr, param1);//lambda输入参数为x变量 //使用LambdaExpression.Compile方法将转换好的lambda表达式树编译成委托 Func\u0026lt;int,int\u0026gt; func = lambdaExpr.Compile(); //调用编译出的委托 Console.WriteLine(func(5)); } 更复杂一些的表达式树 # (a,b,c) =\u0026gt; (a + b + c) / 3\npublic static void Example2() { var param1 = Expression.Variable(typeof(int), \u0026#34;a\u0026#34;); var param2 = Expression.Variable(typeof(int), \u0026#34;b\u0026#34;); var param3 = Expression.Variable(typeof(int), \u0026#34;c\u0026#34;); var const1 = Expression.Constant(3.0f,typeof(float)); var biExpr1 = Expression.Add(param1, param2);//构造参数1，2，生成加法表达式树1 var biExpr2 = Expression.Add(biExpr1, param3);//构造加法表达式树1和参数3，生成加法表达式树2 var biExpr3 = Expression.Convert(biExpr2, typeof(float));//两整形相除不会保留小数，转化为浮点型 var biExpr4 = Expression.Divide(biExpr3, const1);//构造加法表达式树2和常量表达式1，生成除法表达式树3 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;int,int,int,float\u0026gt;\u0026gt;(biExpr4, param1,param2,param3);//根据表达式树3和三个参数，将表达式树转换为lambda表达式树 var func = lambdaExpr.Compile(); Console.WriteLine(func(2, 3, 3)); } 方法调用表达式 # (str,value) =\u0026gt; !str.IsNullOrWhiteSpace(str) \u0026amp;\u0026amp; str.Contains(value)\npublic static void Example3() { var param1 = Expression.Variable(typeof(string), \u0026#34;str\u0026#34;); var param2 = Expression.Variable(typeof(string), \u0026#34;value\u0026#34;); //使用反射获取静态方法，并与参数表达式构造成方法调用表达式 var callExpr1 = Expression.Not(Expression.Call(typeof(string).GetMethod(nameof(string.IsNullOrWhiteSpace), new Type[]{typeof(string)})!, param2)); //使用反射获取实例方法，实例方法需要指定调用实例的表达式 var callExpr2 = Expression.Call(param1, typeof(string).GetMethod(nameof(string.Contains), new[] {typeof(string)} )!, param2); var biExpr1 = Expression.AndAlso(callExpr1, callExpr2);//与运算 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;string,string,bool\u0026gt;\u0026gt;(biExpr1, param1,param2); var func = lambdaExpr.Compile(); Console.WriteLine(func(\u0026#34;Azusa\u0026#34;, \u0026#34;s\u0026#34;)); } 未完待续。。。\n","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/net-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E5%85%A5%E9%97%A8/","section":"Posts","summary":"","title":".NET 表达式树入门"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/linq/","section":"Tags","summary":"","title":"Linq"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/asp-.net-core/","section":"Tags","summary":"","title":"ASP .NET Core"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/swagger/","section":"Tags","summary":"","title":"Swagger"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/web-api/","section":"Tags","summary":"","title":"Web API"},{"content":"\rSwagger文档 # 在ASP .NET Core项目中配置Swagger服务，在Swagger页面的接口中显示C#代码的注释。\nSwagger上的注释\r微软官方文档\n先决条件： 项目需要在Nuget中安装Swashbuckle.AspNetCore包（一般会在ASP .NET Core项目创建时自动安装）\n生成并导出XML文档 # 首先需要生成项目的XML文档。以 Visual Studio 为例，在项目属性-输出中勾选“生成包含API文档的文件”，并指定输出目录：\nVS中生成XML文档\r接着生成项目，会在指定目录下输出XML文档：\n输出的XML文档\r配置Swagger服务 # 在 StartUp 中配置服务\nprogram.cs\n//安装Nuget包后即可使用AddSwaggerGen方法添加Swagger服务 services.AddSwaggerGen(options =\u0026gt; { //定义Swagger文档，可多次定义以区分版本 //此时定义的文档名为v1 options.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo() { //添加一些API信息，将会呈现在Swagger页面上 Version = \u0026#34;v1\u0026#34;, Title = \u0026#34;用户信息控制器\u0026#34;, }); //指定XML文档的目录 options.IncludeXmlComments($\u0026#34;{Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}\\\\{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;, true); ... }); 配置Swagger中间件 # 在ASP .NET Core入口函数中配置中间件\nprogram.cs\n... var app = builder.Build(); //此时在开发环境下才会添加Swagger中间件 if (app.Environment.IsDevelopment()) { //添加Swagger中间件 app.UseSwagger(); //添加SwaggerUI中间件，在参数中指定Swagger终结点，终结点错误将会导致接口无法正常显示 //此时使用终结点是步骤2中声明的名为\u0026#34;v1\u0026#34;文档，如果定义了多个文档版本，则需要指定多个终结点 app.UseSwaggerUI(c =\u0026gt; c.SwaggerEndpoint(\u0026#34;/swagger/v1/swagger.json\u0026#34;, \u0026#34;Gehenna.WebAPI v1\u0026#34;)); } 如果使用IIS 或反向代理的路径，请使用 ./ 前缀将 Swagger 终结点设置为相对路径。 例如 ./swagger/v1/swagger.json。\n使用 /swagger/v1/swagger.json 指示应用在 URL 的真实根目录中查找 JSON 文件（如果使用，加上路由前缀）。例如，请使用 https://localhost:\u0026lt;port\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/v1/swagger.json 而不是 https://localhost:\u0026lt;port\u0026gt;/\u0026lt;virtual_directory\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/v1/swagger.json。\n配置完成 # 在API控制器类或终结点方法上添加XML注释。\n给控制器上添加注释\r给控制器操作方法添加注释\r配置完成后，访问https://localhost:\u0026lt;port\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/index.html页面上即可进入Swagger界面。\n页面的标题文字将显示配置Swagger服务时提供的数据。\nSwagger页面标题\r页面右上方的下拉框可以选择在步骤2/3中定义的Swagger的版本\nSwagger版本\r页面中将会显示控制器，API终结点方法的注释 接口注释\r如果给方法参数添加了注释，Swagger也会显示出来 方法参数的注释\r如果请求/响应的数据模型有添加注释，点击scheme显示 请求/响应模型注释\r在使用泛型作为API响应数据模型时显示注释 # //待补充\n参考文章：https://learn.microsoft.com/zh-cn/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-7.0\u0026amp;tabs=visual-studio\n","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%9C%A8asp-.net-core%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEswagger%E6%96%87%E6%A1%A3/","section":"Posts","summary":"","title":"在ASP .NET Core项目配置Swagger文档"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/javascript/","section":"Tags","summary":"","title":"Javascript"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/signalr/","section":"Tags","summary":"","title":"SignalR"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/websocket/","section":"Tags","summary":"","title":"Websocket"},{"content":"在使用SignalR向.NET后端进行实时通信时，时常会使用 AccessToken 进行用户授权。提供用户认证可以提高后端接口的安全性，并且可以利用SignalR的用户认证机制来向指定用户的所有SignalR连接发送消息。\n后端用户授权服务 # 在 ASP.NET Core 中添加授权机制： # Program.cs ... services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //此处使用JWTBearer进行授权验证 .AddJwtBearer(options =\u0026gt; { var secretKey = configurations.GetRequiredSection(\u0026#34;Jwt\u0026#34;).Get\u0026lt;JwtOption\u0026gt;().SecretKey??throw new ConfigurationErrorsException(\u0026#34;Jwt密钥未配置\u0026#34;); options.TokenValidationParameters = new() { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)), }; }); ... //添加认证机制需要引用Authentication与Authorization两个中间件 app.UseAuthentication(); app.UseAuthorization(); ... 在SignalR集线器类上添加Authorize特性 # 详细的授权信息与不同的授权规则参考\rASP.NET Core授权\n//添加授权 [Authorize] public class ChatHub : Hub { public override async Task OnConnectedAsync() { await base.OnConnectedAsync(); //在Hub类的Context.User属性中可以获取到SignalR通过websocket握手获取到的用户授权信息 await Console.Out.WriteLineAsync(Context.User.Identity.Name); } ... } 这样就为ASP .NET Core提供了基本的用户授权机制，在应用的终结点(endPoints)上添加[Autorize]特性来对此终结点进行用户授权。\n在客户端配置SignalR连接的访问令牌 # C#客户端 # ... _connection = new HubConnectionBuilder() .WithAutomaticReconnect() //在WithUrl方法的configureHttpConnection参数中配置 .WithUrl(HubUrl, options =\u0026gt; { //为AccessTokenProvider提供获取访问令牌的委托 //此处为应当查找并获取用户访问令牌的逻辑 options.AccessTokenProvider = () =\u0026gt; Task.FromResult(authorizationToken); }); .ConfigureLogging(builder =\u0026gt; builder.AddConsole()) .Build(); await _connection.StartAsync(); ... Javascript客户端 # ... this.hubConnection = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;this.hubUrl\u0026#34;,{ //为withUrl方法参数2的accessTokenFactory属性提供获取访问令牌的方法 accessTokenFactory: () =\u0026gt; this.getAccessToken(), skipNegotiation: true, transport: signalR.HttpTransportType.WebSockets }) .build(); await this.hubConnection.start(); ... 踩坑注意 # 在Javascript客户端，即使配置了访问令牌，在对后端SignalR集线器进行访问时服务器仍然会响应 401 Unauthorized 或是客户端抛出 SignalR Error: Failed to complete negotiation with the server 异常，若排除了Javascript客户端配置问题或是CORS跨域访问问题，则有可能是因为Javascript websocket API不支持设置请求报文头的原因。\n客户端使用HTTP协议向服务器进行访问令牌验证常用的方式是在报文头中添加 Authorization 标头，并提供访问令牌字符串。 请求标头中的Authorization项\r在SignalR进行Websocket连接前会进行协商(negotiation)，若客户端在建立SignalR连接时配置了访问令牌，则会在请求时附带上访问令牌。\n但在SignalR Javascript客户端进行协商时，访问令牌并不是添加在报文头中，而是以查询字符串的形式发送请求。 访问令牌放在了查询字符串中\rASP.NET Core并不会自动对查询字符串中的访问令牌进行授权，所以此时服务器将会返回 401 Unauthorized ，而Javascript客户端会抛出 SignalR Error: Failed to complete negotiation with the server (无法完成与服务器的协商） 异常。\n解决方法： # 在服务器端配置授权机制，在收到请求消息时手动进行授权处理。配置的方式有多种，较为简单的方式是直接在Authorization服务中添加事件：\nprogram.cs ... services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //使用JwtBearer作为认证令牌 .AddJwtBearer(options =\u0026gt; { var secretKey = configurations.GetRequiredSection(\u0026#34;Jwt\u0026#34;).Get\u0026lt;JwtOption\u0026gt;().SecretKey??throw new ConfigurationErrorsException(\u0026#34;Jwt密钥未配置\u0026#34;); options.TokenValidationParameters = new() { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)), }; //添加授权事件，在收到请求消息时进行处理 options.Events = new JwtBearerEvents() { OnMessageReceived = context =\u0026gt; { //从请求查询字符串中取出访问令牌 var accessToken = context.Request.Query[\u0026#34;access_token\u0026#34;]; //请求条件不符合则返回 if (!string.IsNullOrEmpty(accessToken) \u0026amp;\u0026amp; context.Request.Headers[\u0026#34;Upgrade\u0026#34;] == \u0026#34;websocket\u0026#34;) { //手动对上下文中的令牌属性赋值，剩下的授权由.NET自动完成 context.Token = accessToken; } return Task.CompletedTask; } }; }); ... 参考文章\nhttps://stackoverflow.com/questions/21260384/signalr-authenticating-with-access-token#comment32085907_21260384\n","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E4%B8%BAsignalr%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/","section":"Posts","summary":"","title":"为SignalR的连接配置用户认证"},{"content":"\r测试帖子 # 使用Hugo超快速建站\nHugo首页\nhugo new site Azusa\u0026rsquo;s Archive\n","date":"2023年3月10日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/hellow-world/hello-world/","section":"Posts","summary":"","title":"Hello World"},{"content":"","date":"0001年1月 1日","permalink":"/Hugo-Blog-Blowfish-Theme/authors/","section":"Authors","summary":"","title":"Authors"}]