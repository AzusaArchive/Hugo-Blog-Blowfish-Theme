[{"content":"","date":"2023年3月15日","permalink":"/categories/.net/","section":"Categories","summary":"","title":".NET"},{"content":"","date":"2023年3月15日","permalink":"/tags/asp-.net-core/","section":"Tags","summary":"","title":"ASP .NET Core"},{"content":"","date":"2023年3月15日","permalink":"/","section":"AzusaArchive","summary":"","title":"AzusaArchive"},{"content":"","date":"2023年3月15日","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"2023年3月15日","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"2023年3月15日","permalink":"/tags/swagger/","section":"Tags","summary":"","title":"Swagger"},{"content":"","date":"2023年3月15日","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"2023年3月15日","permalink":"/tags/web-api/","section":"Tags","summary":"","title":"Web API"},{"content":"Swagger文档\u003e\rSwagger文档 # 在ASP .NET Core项目中配置Swagger服务，在Swagger页面的接口中显示C#代码的注释。\nSwagger上的注释\r微软官方文档\n先决条件： 项目需要在Nuget中安装Swashbuckle.AspNetCore包（Visual Studio中一般会在ASP .NET Core项目中自动安装）\n生成并导出XML文档\u003e\r生成并导出XML文档 # 首先需要生成项目的XML文档。以 Visual Studio 为例，在项目属性-输出中勾选“生成包含API文档的文件”，并指定输出目录：\nVS中生成XML文档\r接着生成项目，会在指定目录下输出XML文档：\n输出的XML文档\r配置Swagger服务\u003e\r配置Swagger服务 # 在ASP .NET Core入口函数中配置服务\nprogram.cs\r//安装Nuget包后即可使用AddSwaggerGen方法添加Swagger服务\rservices.AddSwaggerGen(options =\u0026gt;\r{\r//定义Swagger文档，可多次定义以区分版本\r//此时定义的文档名为v1\roptions.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo()\r{\r//添加一些API信息，将会呈现在Swagger页面上\rVersion = \u0026#34;v1\u0026#34;,\rTitle = \u0026#34;用户信息控制器\u0026#34;,\r});\r//指定XML文档的目录\roptions.IncludeXmlComments($\u0026#34;{Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}\\\\{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;, true);\r...\r}); 配置Swagger中间件\u003e\r配置Swagger中间件 # 在ASP .NET Core入口函数中配置中间件\nprogram.cs ...\rvar app = builder.Build();\r//此时在开发环境下才会添加Swagger中间件\rif (app.Environment.IsDevelopment())\r{\r//添加Swagger中间件\rapp.UseSwagger();\r//添加SwaggerUI中间件，在参数中指定Swagger终结点，终结点错误将会导致接口无法正常显示\r//此时使用终结点是步骤2中声明的名为\u0026#34;v1\u0026#34;文档，如果定义了多个文档版本，则需要指定多个终结点\rapp.UseSwaggerUI(c =\u0026gt; c.SwaggerEndpoint(\u0026#34;/swagger/v1/swagger.json\u0026#34;, \u0026#34;Gehenna.WebAPI v1\u0026#34;));\r} 如果使用目录及 IIS 或反向代理，请使用 ./ 前缀将 Swagger 终结点设置为相对路径。 例如 ./swagger/v1/swagger.json。\n使用 /swagger/v1/swagger.json 指示应用在 URL 的真实根目录中查找 JSON 文件（如果使用，加上路由前缀）。例如，请使用 https://localhost:\u0026lt;port\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/v1/swagger.json 而不是 https://localhost:\u0026lt;port\u0026gt;/\u0026lt;virtual_directory\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/v1/swagger.json。\n配置完成\u003e\r配置完成 # 在API控制器类或终结点方法上添加XML注释。\n给控制器上添加注释\r给控制器操作方法添加注释\r配置完成后，访问https://localhost:\u0026lt;port\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/index.html页面上即可进入Swagger界面。\n页面的标题文字将显示配置Swagger服务时提供的数据。\nSwagger页面标题\r页面右上方的下拉框可以选择在步骤2/3中定义的Swagger的版本\nSwagger版本\r页面中将会显示控制器，API终结点方法的注释 接口注释\r如果给方法参数添加了注释，Swagger也会显示出来 方法参数的注释\r如果请求/响应的数据模型有添加注释，点击scheme显示 请求/响应模型注释\r在使用泛型作为API响应数据模型时显示注释\u003e\r在使用泛型作为API响应数据模型时显示注释 # //待补充\n参考文章：https://learn.microsoft.com/zh-cn/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-7.0\u0026amp;tabs=visual-studio\n","date":"2023年3月15日","permalink":"/posts/%E5%9C%A8asp-.net-core%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEswagger%E6%96%87%E6%A1%A3/","section":"Posts","summary":"Swagger文档\u003e\rSwagger文档 # 在ASP .","title":"在ASP .NET Core项目配置Swagger文档"},{"content":"","date":"2023年3月11日","permalink":"/tags/javascript/","section":"Tags","summary":"","title":"Javascript"},{"content":"","date":"2023年3月11日","permalink":"/tags/signalr/","section":"Tags","summary":"","title":"SignalR"},{"content":"","date":"2023年3月11日","permalink":"/tags/websocket/","section":"Tags","summary":"","title":"Websocket"},{"content":"在使用SignalR向.NET后端进行实时通信时，时常会使用 AccessToken 进行用户授权。提供用户认证可以提高后端接口的安全性，并且可以利用SignalR的用户认证机制来向指定用户的所有SignalR连接发送消息。\n后端用户授权服务\u003e\r后端用户授权服务 # 在 ASP.NET Core 中添加授权机制：\u003e\r在 ASP.NET Core 中添加授权机制： # Program.cs ... services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //此处使用JWTBearer进行授权验证 .AddJwtBearer(options =\u0026gt; { var secretKey = configurations.GetRequiredSection(\u0026#34;Jwt\u0026#34;).Get\u0026lt;JwtOption\u0026gt;().SecretKey??throw new ConfigurationErrorsException(\u0026#34;Jwt密钥未配置\u0026#34;); options.TokenValidationParameters = new() { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)), }; }); ... //添加认证机制需要引用Authentication与Authorization两个中间件 app.UseAuthentication(); app.UseAuthorization(); ... 在SignalR集线器类上添加Authorize特性\u003e\r在SignalR集线器类上添加Authorize特性 # 详细的授权信息与不同的授权规则参考\rASP.NET Core授权\n//添加授权 [Authorize] public class ChatHub : Hub { public override async Task OnConnectedAsync() { await base.OnConnectedAsync(); //在Hub类的Context.User属性中可以获取到SignalR通过websocket握手获取到的用户授权信息 await Console.Out.WriteLineAsync(Context.User.Identity.Name); } ... } 这样就为ASP .NET Core提供了基本的用户授权机制，在应用的终结点(endPoints)上添加[Autorize]特性来对此终结点进行用户授权。\n在客户端配置SignalR连接的访问令牌\u003e\r在客户端配置SignalR连接的访问令牌 # C#客户端\u003e\rC#客户端 # ... _connection = new HubConnectionBuilder() .WithAutomaticReconnect() //在WithUrl方法的configureHttpConnection参数中配置 .WithUrl(HubUrl, options =\u0026gt; { //为AccessTokenProvider提供获取访问令牌的委托 //此处为应当查找并获取用户访问令牌的逻辑 options.AccessTokenProvider = () =\u0026gt; Task.FromResult(authorizationToken); }); .ConfigureLogging(builder =\u0026gt; builder.AddConsole()) .Build(); await _connection.StartAsync(); ... Javascript客户端\u003e\rJavascript客户端 # ... this.hubConnection = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;this.hubUrl\u0026#34;,{ //为withUrl方法参数2的accessTokenFactory属性提供获取访问令牌的方法 accessTokenFactory: () =\u0026gt; this.getAccessToken(), skipNegotiation: true, transport: signalR.HttpTransportType.WebSockets }) .build(); await this.hubConnection.start(); ... 踩坑注意\u003e\r踩坑注意 # 在Javascript客户端，即使配置了访问令牌，在对后端SignalR集线器进行访问时服务器仍然会响应 401 Unauthorized 或是客户端抛出 SignalR Error: Failed to complete negotiation with the server 异常，若排除了Javascript客户端配置问题或是CORS跨域访问问题，则有可能是因为Javascript websocket API不支持设置请求报文头的原因。\n客户端使用HTTP协议向服务器进行访问令牌验证常用的方式是在报文头中添加 Authorization 标头，并提供访问令牌字符串。 请求标头中的Authorization项\r在SignalR进行Websocket连接前会进行协商(negotiation)，若客户端在建立SignalR连接时配置了访问令牌，则会在请求时附带上访问令牌。\n但在SignalR Javascript客户端进行协商时，访问令牌并不是添加在报文头中，而是以查询字符串的形式发送请求。 访问令牌放在了查询字符串中\rASP.NET Core并不会自动对查询字符串中的访问令牌进行授权，所以此时服务器将会返回 401 Unauthorized ，而Javascript客户端会抛出 SignalR Error: Failed to complete negotiation with the server (无法完成与服务器的协商） 异常。\n解决方法：\u003e\r解决方法： # 在服务器端配置授权机制，在收到请求消息时手动进行授权处理。配置的方式有多种，较为简单的方式是直接在Authorization服务中添加事件：\nprogram.cs ... services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //使用JwtBearer作为认证令牌 .AddJwtBearer(options =\u0026gt; { var secretKey = configurations.GetRequiredSection(\u0026#34;Jwt\u0026#34;).Get\u0026lt;JwtOption\u0026gt;().SecretKey??throw new ConfigurationErrorsException(\u0026#34;Jwt密钥未配置\u0026#34;); options.TokenValidationParameters = new() { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)), }; //添加授权事件，在收到请求消息时进行处理 options.Events = new JwtBearerEvents() { OnMessageReceived = context =\u0026gt; { //从请求查询字符串中取出访问令牌 var accessToken = context.Request.Query[\u0026#34;access_token\u0026#34;]; //请求条件不符合则返回 if (!string.IsNullOrEmpty(accessToken) \u0026amp;\u0026amp; context.Request.Headers[\u0026#34;Upgrade\u0026#34;] == \u0026#34;websocket\u0026#34;) { //手动对上下文中的令牌属性赋值，剩下的授权由.NET自动完成 context.Token = accessToken; } return Task.CompletedTask; } }; }); ... 参考文章\nhttps://stackoverflow.com/questions/21260384/signalr-authenticating-with-access-token#comment32085907_21260384\n","date":"2023年3月11日","permalink":"/posts/%E4%B8%BAsignalr%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/","section":"Posts","summary":"在使用SignalR向.NET后端进行实时通信时，时常会使用 AccessToken 进行用户授权。提供用户认证可以提高后端接口的安全性，并且可以利用SignalR的用户认证机制来向指定用户的所有SignalR连接发送消息。","title":"为SignalR的连接配置用户认证"},{"content":"测试帖子\u003e\r测试帖子 # 使用Hugo超快速建站\nHugo首页\nhugo new site Azusa\u0026rsquo;s Archive\n","date":"2023年3月10日","permalink":"/posts/hellow-world/hello-world/","section":"Posts","summary":"测试帖子\u003e\r测试帖子 # 使用Hugo超快速建站","title":"Hello World"},{"content":"","date":"0001年1月 1日","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001年1月 1日","permalink":"/series/","section":"Series","summary":"","title":"Series"}]