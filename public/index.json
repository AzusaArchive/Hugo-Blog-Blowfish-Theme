[{"content":"","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/.net/","section":"Categories","summary":"","title":".NET"},{"content":"","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/c#/","section":"Tags","summary":"","title":"C#"},{"content":"详见 官方文档\nSpan\u0026lt;T\u0026gt; # Span是一种\r引用结构体(ref struct)，它提供任意内存的连续区域的类型安全和内存安全表示形式。Span通常用于充当数组，但与数组不同的是，Span 实例可以指向堆栈上托管的内存、本机内存或托管的内存。\n// 创建一个数组，并用Span指向这个数组。 // 注意这里的Span仅是指向了array的地址，并没有在堆上创建内存。 var array = new int[]{1,2,3,4,5}; var arraySpan = new Span\u0026lt;int\u0026gt;(array); for (int ctr = 0; ctr \u0026lt; arraySpan.Length; ctr++)//使用Length获取这串内存的长度，单位是int arraySpan[ctr] = 0; //使用[]运算符对特定位置的内存进行访问 foreach (var num in array) Console.Write(num); // 输出：00000 上面的例子声明了一个内容为 {1,2,3,4,5} 的int数组，并定义了一个Span\u0026lt;int\u0026gt;指向该数组。此时Span起到了类似于指针的作用，对一段连续的内存进行直接访问。\nSpan\u0026lt;T\u0026gt;和内存 # Span\u0026lt;T\u0026gt;不仅可以指向某个数组（即.NET运行时托管的内存），还可以指向本地内存或是堆栈，如以下代码所示：\n使用Marshal类分配一块本地内存（并非.NET运行时中的内存），并使用Span\u0026lt;byte\u0026gt;指向它：\n// 创建一块本机内存，并用Span指向它，对非.NET运行时托管内存进行操作是不安全代码，使用unsafe块 var native = Marshal.AllocHGlobal(100); Span\u0026lt;byte\u0026gt; nativeSpan; unsafe { nativeSpan = new Span\u0026lt;byte\u0026gt;(native.ToPointer(), 100); //将Span指向分配的本机内存 } byte data = 0; for (int ctr = 0; ctr \u0026lt; nativeSpan.Length; ctr++) nativeSpan[ctr] = data++; // 直接对内存进行操作 int nativeSum = 0; foreach (var value in nativeSpan) nativeSum += value; Console.WriteLine($\u0026#34;The sum is {nativeSum}\u0026#34;); Marshal.FreeHGlobal(native); //释放内存 // Output: The sum is 4950 使用\rstackalloc关键字在堆栈上分配一块内存，并用Span指向它：\nSpan\u0026lt;int\u0026gt; arraySpan = stackalloc int[5]; // 使用stackalloc关键字在堆栈上分配一个int数组 var n = 0; for (int ctr = 0; ctr \u0026lt; arraySpan.Length; ctr++) arraySpan[ctr] = n++; // 访问数组内的元素 foreach (var num in arraySpan) Console.Write(num); // 输出：01234 Span\u0026lt;T\u0026gt;和切片 # 使用Span\u0026lt;T\u0026gt;的构造函数，或是Span\u0026lt;T\u0026gt;对象的Slice方法，可以对连续内存的中的一部分区域进行操作：\nvar array = new int[]{1,2,3,4,5}; var arraySpan = new Span\u0026lt;int\u0026gt;(array, 1,3); //指向 array[1]~array[3]的内存 for (int ctr = 0; ctr \u0026lt; arraySpan.Length; ctr++) arraySpan[ctr] = 0; foreach (var num in array) Console.Write(num); // 输出：10005 Span\u0026lt;T\u0026gt;的切片操作常用于字符串，因为C#字符串的\r不可变性，对字符串的修改操作（如分割、拼接、修改内容、提取子串）并不是直接在原有字符串上进行操作，而是会返回新的字符串对象。因此频繁对字符串的修改操作会产生大量冗余内存给\r垃圾回收期(GC)增加压力，从而对性能产生影响。\npublic static (int year, int month, int day) StringToDate(string str) { var year = str.Substring(0,4); var month = str.Substring(4,2); var day = str.Substring(6,2); return (int.Parse(year), int.Parse(month), int.Parse(day)); } 上述的代码对一段 yyyyMMdd 格式的日期字符串进行分割处理，并返回包含整型 (年，月，日) 的元组。\n通过SubString方法分割字符串，并用int.Parse方法转换为整形。\n这个方法多次对字符串进行提取子串的操作，由于字符串不可变的特性，每次提取子串时都会产生新的字符串实例，在内存分析器中可以看出产生了三个新的字符串：\nSubString产生的新字符串对象\r所以，如果有大量与上述类似的字符串处理操作被执行，将会产生非常多的无用内存，而GC回收这些内存时会对性能产生大幅影响。所以对于大量的字符串处理操作，往往会选择使用\rStringBuilder类来避免产生过多垃圾。\n但因为string对象也是一段连续的内存，此时也可以使用Span\u0026lt;char\u0026gt;来对直接对字符串进行操作：\npublic static (int year, int month, int day) StringToDate(ReadOnlySpan\u0026lt;char\u0026gt; str) { var year = str.Slice(0,4); var month = str.Slice(4,2); var day = str.Slice(6,2); return (int.Parse(year), int.Parse(month), int.Parse(day)); } 方法将输入的字符串隐式转换为ReadOnlySpan\u0026lt;char\u0026gt;，并用Slice方法对这段内存进行切片，将切片的结果转换为int类型。\nSpan\u0026lt;T\u0026gt;的是对该段内存的直接操作，所以不像SubString，Slice方法并不会在堆上分配任何的内存，仅仅是返回一个指向了该段内存的Span\u0026lt;T\u0026gt;对象而已。\n可以看到内存中没有产生多余的字符串对象：\nSlice方法并不会产生新的字符串\r直接对对象的内存进行操作避免产生垃圾，这对大量的字符串处理操作有非常可观的性能优化。\n缺陷 # 虽然使用Span\u0026lt;T\u0026gt;可以对性能有很大的提升，但因为它是\r引用结构体类型，所以使用起来有较多的限制，比如：\nref struct 不能是数组的元素类型。 ref struct 不能是类或非 ref struct 的字段的声明类型。 ref struct 不能实现接口。 ref struct 不能被装箱为 System.ValueType 或 System.Object。 ref struct 不能是类型参数。 ref struct 变量不能由 Lambda 表达式或本地函数捕获。 ref struct 变量不能在 async 方法中使用。 但是，可以在同步方法中使用 ref struct 变量，例如，在返回 Task 或 Task 的方法中。 ref struct 变量不能在迭代器中使用。 这些限制决定了Span\u0026lt;T\u0026gt;不能在大多数场景中使用，但如果在编写某些方法时，对性能或是内存要求十分苛刻，那么使用Span\u0026lt;T\u0026gt;是个很不错的选择。\n","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/csharpspan%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"Posts","summary":"","title":"C# Span\u003cT\u003e的使用"},{"content":"","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/c#%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"C#基础"},{"content":"","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"\r","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/","section":"Index","summary":"","title":"Index"},{"content":"","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"\rnull检查 # object? obj = null; if (obj == null) { Console.WriteLine(\u0026#34;object is null\u0026#34;); } 上述的代码是C#最基本，也是最常用的null检查，但在.NET更新了这么多版本之后，这种做法并不是最好的。\n被重载的==运算符 # 使用==或是!=运算符进行null检查时，如果遇到对象类型的==和!=运算符被重载的情况，可能得到意料之外的结果：\nclass User { public string Name { get; set; } public static bool operator ==(User left, User right) =\u0026gt; left.Name == right.Name; public static bool operator !=(User left, User right) =\u0026gt; !(left == right); } static void Main(string[] args) { var user1 = new User { Name = \u0026#34;Azusa\u0026#34; }; var user2 = new User { Name = \u0026#34;Hina\u0026#34; }; Console.WriteLine(user1 != null); //此时会抛出空引用异常，因为在 != 运算符中引用了 null 的 Name 属性 } 这样的行为可能会导致程序中隐藏的漏洞，比如上述的情况只有在运行时抛出异常才能察觉。（如果使用了C# 8.0的空引用类型，则会有编译器警告。实际上在主流的IDE中，重载前后的==运算符显示在编辑器中的颜色是不一致的，不过这不是很容易察觉到）\nReferenceEquals # 如果要确保我们的意图是“检查对象的引用是否为空”，而不是通过==或!=运算符来检查，则需要使用Object.ReferenceEquals()函数：\nif (ReferenceEquals(user1,null)) ... 使用ReferenceEquals函数保证了null检查不会被影响，因为这个函数真的就是检查两参数的引用是否相等，且不会被重载。\n有趣的是，当转到Object.ReferenceEquals()函数的实现时，发现内部还是调用了==运算符：\n[NonVersionable] public static bool ReferenceEquals(object? objA, object? objB) { return objA == objB; } 但因为接受的两个参数都被转换为了可空的object类型，所以调用的==运算符依然是没被重载的，object类型中定义的==运算符。\n既然如此，在使用==进行null检查时，可以加一步转换，来防止运算符被重载的情况。\nif ((object?)user1 == null) { Console.WriteLine(\u0026#34;object is null\u0026#34;); } 但这样的代码不够美观。\n模式匹配 # C# 7.0出现了模式匹配后，null检查出现了新的方法。使用is运算符进行\r常量模式匹配时可以接收null值，所以null检查变成了这样：\nif (user1 is null) { Console.WriteLine(\u0026#34;object is null\u0026#34;); } 如果使用的C#是9.0版本之后，则可以加上not运算符来实现非null检查：\nif (user1 is not null) { Console.WriteLine(\u0026#34;object is not null\u0026#34;); } 这样的代码看起来更直观了。实际上，这也是微软官方推荐的做法：\rnull检查\n在C#内部，实际上使用is进行null检查时，也是先把对象转换为了object类型。\n总结 # 所以，在进行null检查时，模式匹配obj is null是最推荐的做法，但如果语言版本不满足(\u0026lt;7.0)，进行null检查则要更加谨慎，object.ReferenceEquals()函数是最安全的做法，而使用==运算符进行检查是比较危险的，因为运算符可能被重载，得到意料之外的结果。\n","date":"2023年6月14日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/csharp%E6%AD%A3%E7%A1%AE%E7%9A%84null%E6%A3%80%E6%9F%A5/","section":"Posts","summary":"","title":"CSharp正确的null检查"},{"content":"\r第一章 # 图形与图像的区别 # 内容 图形 图像 基本元素 点、线、面等几何元素，比如直线，圆，多边形。。。 像素 存储数据 各个矢量的参数 哥哥像素的灰度或颜色 处理方式 旋转，扭曲或拉伸等 对比度增强，边缘检测等 缩放结果 不会失真，适应不同分辨率 放大会失真 其他 图形不是客观存在的，是根据客观事物而主观形成 对客观事物的真实描述 实例 工程图纸 照片 应用领域 计算机辅助设计 图像处理 计算机图形学概念 # 研究通过计算机将信息、数据转换为图形，并在专门显示设备上显示的原理、方法和技术的学科。\nOpenGL中基本的图元，常用的函数 # 基本函数 # glutInit(int *argc,char **argv)// 使用外部参数初始化GLUT glutInitDisplayMode(unsigned int mode) // 使用GLUT的枚举值初始化显示模式，指定缓冲区模式和颜色格式，使用按位或来同时设置 glutInitWindowPosition(int x,int y) //指定了窗口左上角的屏幕位置 glutInitWindowSize(int width,int size) //指定了窗口的大小（以像素为单位） glutCreateWindow(char *string) //创建一个支持OpenGL渲染环境的窗口。在调用glutMainLoop()函数之前，这个窗口并没有显示。 glutDisplayFunc(void(*func)(void)) //OpenGL绘制回调函数，将绘制函数作为参数 glutMainLoop(void) //开始OpenGL绘制循环 输入事件处理 # glutReshapeFunc(void(*func)int w,int h) //注册当前窗口大小变化时的回调函数 glutKeyboardFunc(void(*func)(unsigned char key,int x,int y)) //注册当前窗口的键盘回调函数 glutMouseFunc(void (*func) (int button, int state, int x, int y)); glutMouseFunc为注册当前窗口的鼠标回调函数，func为注册的鼠标回调函数,这个函数完成鼠标事件的处理，button为鼠标的按键,为以下定义的常量：\nGLUT_LEFT_BUTTON 鼠标左键 GLUT_MIDDLE_BUTTON 鼠标中键 GLUT_RIGHT_BUTTON 鼠标右键 state为鼠标按键的动作：\nGLUT_UP 鼠标释放 GLUT_DOWN 鼠标按下 绘制函数 # 清除窗口 下面两行代码把一个RGBA模式的窗口清除为黑色\nglClearColor(0.0, 0.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT); 指定绘制颜色 在绘制前使用下列函数指定绘制颜色\nglColor3f(float r, float g, float b); //三个参数的范围为0-1 glColor3ub(unsigned char r, unsigned char g, unsigned char b) // 三个参数的范围为0-255 完成绘制\nglFlush() 如果使用双缓冲区模式，则需要交换缓冲区\nglutSwapBuffers() 绘制\n使用glBegin(unsigned int mode)函数指定图元并开始绘制\n使用glVertex..函数绘制顶点，满足了顶点的数量则会自动根据顶点生成图元对应的图形\n使用glEnd()函数结束绘制\nOpenGL几何图元\n模式 图元类型 GL_POINTS 将每个顶点绘制为点 GL_LINES 将每两个顶点绘制为一条线 GL_LINE_STRIP 将指定的顶点用于创建线条。第一个顶点之后的每个顶点指定的是线条延伸到的下一个点 GL_LINE_LOOP 与GL_LINE_STRIP类似，但是绘制完后起始顶点会和终结顶点连接 GL_TRIANGLES 将每三个顶点绘制为一个三角形 GL_TRIANGLE_STRIP 将指定的顶点用于创建三角条。指定前三个顶点之后，后继的每个顶点与它前面两个顶点一起用来构造下一个三角形。每个顶点三元组（在最初的组之后）会自动重新排列以确保三角形绕法的一致性 GL_TRIANGLE_FAN 将指定的顶点用于构造三角扇形。第一个顶点充当原点，第三个顶点之后的每个顶点与它的前一个顶点还有原点一起组合 GL_QUADS 将每四个顶点绘制为一个四边形 GL_QUADS_STRIP 将指定的顶点用于构造四条形边。在第一对顶点之后，每对顶点定义一个四边形。和GL_QUADS的顶点顺序不一样，每对顶点以指定顺序的逆序使用，以便保证绕法的一致 GL_POLYGON 将指定的顶点用于构造一个凸多边形。多边形的边缘决不能相交。最后一个顶点会自动连接到第一个顶点以确保多边形是封闭的 图元示例\r第二章 # 一个交互式计算机图形系统应具有计算、存储、对话、输入和输出等5个方面的功能 图形系统分为图形硬件和图形软件。 图形显示设备主要有彩色阴极射线管CRT和液晶显示器LCD。 图形显示方式随机扫描（画线设备）和光栅扫描（画点设备）。 光栅扫描显示系统主要包括：显示器，帧缓冲器和视频控制器。 计算 颜色数K 和 帧缓存器(显存)V(单位bit) 的大小之间的关系，分辨率为m*n，公式为：𝑉\u0026gt;=m×n×log2(K) ","date":"2023年6月13日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/","section":"Posts","summary":"","title":"复习 计算机图形学基础"},{"content":"","date":"2023年6月13日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/","section":"Categories","summary":"","title":"计算机图形学"},{"content":"","date":"2023年6月13日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","section":"Tags","summary":"","title":"期末复习"},{"content":" 本文内容参考\r微软官方文档\n“模式匹配”是一种测试表达式是否具有特定特征的方法。在代码中使用模式匹配可以有效提高开发效率和代码可读性。C#从7.0开始支持模式匹配，并支持以下匹配方式：\n声明模式：用于检查表达式的运行时类型，如果匹配成功，则将表达式结果分配给声明的变量。 类型模式：用于检查表达式的运行时类型。 在 C# 9.0 中引入。 常量模式：用于测试表达式结果是否等于指定常量。 关系模式：用于将表达式结果与指定常量进行比较。 在 C# 9.0 中引入。 逻辑模式：用于测试表达式是否与模式的逻辑组合匹配。 在 C# 9.0 中引入。 属性模式：用于测试表达式的属性或字段是否与嵌套模式匹配。 位置模式：用于解构表达式结果并测试结果值是否与嵌套模式匹配。 var 模式：用于匹配任何表达式并将其结果分配给声明的变量。 弃元模式：用于匹配任何表达式。 列表模式：测试序列元素是否与相应的嵌套模式匹配。 在 C# 11 中引入。 在C#代码中，可以使用is,or,not,and和switch表达式进行模板匹配，详见：\n模式匹配 - 模式中的 is 和 switch 表达式，以及 and、or 和 not 运算符\n声明和类型模式 # 条件语句 # 检查对象的类型是否与给定的一致（C# 9.0以上）：\nobject greeting = \u0026#34;Hello, World!\u0026#34;; if (greeting is string) // 如果greeting是string类型 { Console.WriteLine((string)greeting); } 声明模式，匹配时进行声明，省去了一步类型转换：\nif (greeting is string message) // 如果greeting类型为string，则将其以string类型赋值到message上 { Console.WriteLine(message); } (其实是做了这一步转换\nvar message = greeting as string; if (message is not null) ... 可以对其进行null检查，在进行上述的类型匹配也会自动进行null检查\nstring? str = \u0026#34;hello world!\u0026#34;; if (str is not null) { Console.WriteLine(str); } 使用模式匹配来进行null检查可以有效避免==和!=运算符被对象的类型重载而返回不正确值的情况\n加上与或表达式：\nobject a = 1; object b = 1.22f; if (a is int and b is float) ...//true if (a is float or b is float) ...//true 注意，如果对象派生，实现，或是存在任何到匹配类型的\r隐式引用转换，表达式都会为true\nvar list = new List\u0026lt;int\u0026gt;{1,2,3}; if (list is IEnumerable) // list实现IEnumerable接口 { Console.WriteLine(\u0026#34;list is Enumerable!\u0026#34;); } Switch表达式 # 使用\rswitch 关键字的模式匹配表达式\nC#将Switch语句融合进了模板匹配，上述的类型匹配可以使用Switch表达式来实现：\nobject obj = DateTime.Now; string type = obj switch { int =\u0026gt; \u0026#34;int\u0026#34;, string =\u0026gt; \u0026#34;string\u0026#34;, float =\u0026gt; \u0026#34;float\u0026#34;, DateTime =\u0026gt; \u0026#34;DateTime\u0026#34;, null =\u0026gt; \u0026#34;null\u0026#34;, _ =\u0026gt; \u0026#34;Unknown Type\u0026#34; }; Console.WriteLine(\u0026#34;object type is \u0026#34; + type); 并非switch表达式，正常的switch语句也是可行的\nstring type; switch (obj) { case int: type = \u0026#34;int\u0026#34;; break; case string: type = \u0026#34;string\u0026#34;; break; case float: type = \u0026#34;float\u0026#34;; break; case DateTime: type = \u0026#34;DateTime\u0026#34;; break; case null: type = \u0026#34;null\u0026#34;; break; default: type = \u0026#34;Unknown type\u0026#34;; break; } 但很显然switch表达式更加精练\n常量模式 # 模板匹配可以对常量值进行匹配\nstring str = \u0026#34;hello\u0026#34;; if (str is \u0026#34;hello\u0026#34;) { Console.WriteLine(\u0026#34;str is \\\u0026#34;hello\\\u0026#34;\u0026#34;); } 关系模式 # 从 C# 9.0 开始，可使用关系模式将表达式结果与常量进行比较\nint i = Random.Shared.Next(10); if (i is \u0026gt; 5) { Console.WriteLine(\u0026#34;i \u0026gt; 5\u0026#34;); } 感觉有点蠢？用上switch就不一样了\nConsole.WriteLine(Classify(13)); // output: Too high Console.WriteLine(Classify(double.NaN)); // output: Unknown Console.WriteLine(Classify(2.4)); // output: Acceptable static string Classify(double measurement) =\u0026gt; measurement switch { \u0026lt; -4.0 =\u0026gt; \u0026#34;Too low\u0026#34;, \u0026gt; 10.0 =\u0026gt; \u0026#34;Too high\u0026#34;, double.NaN =\u0026gt; \u0026#34;Unknown\u0026#34;, _ =\u0026gt; \u0026#34;Acceptable\u0026#34;, }; \u0026ldquo;在关系模式中，可使用关系运算符\u0026lt;、\u0026gt;、\u0026lt;= 或 \u0026gt;= 中的任何一个。 关系模式的右侧部分必须是常数表达式。 常数表达式可以是 integer、floating-point、char 或 enum 类型。\u0026rdquo;\n逻辑模式 # C# 9.0 以上，可以使用and,or,not关键字来创造\u0026rsquo;与\u0026rsquo;，\u0026lsquo;或\u0026rsquo;，\u0026lsquo;非\u0026rsquo;的逻辑\nif (input is not null) { // ... } 运行的优先级也是 not \u0026gt; and \u0026gt; or，并且从右开始扫描\n括号模式 # 使用括号强调或改变模式匹配优先级：\nif (input is not (float or double)) { return; } 属性模式 # 将对象的属性或是字段进行匹配：\nstatic bool IsConferenceDay(DateTime date) =\u0026gt; date is { Year: 2020, Month: 5, Day: 19 or 20 or 21 }; 属性模式可以用一串优雅的模式匹配代替复杂的条件语句，还能结合声明模式和类型模式：\nstatic string TakeFive(object input) =\u0026gt; input switch { string { Length: \u0026gt;= 5 } s =\u0026gt; s.Substring(0, 5), //结合了声明模式，类型模式，逻辑模式，常量模式和属性模式 string s =\u0026gt; s, ICollection\u0026lt;char\u0026gt; { Count: \u0026gt;= 5 } symbols =\u0026gt; new string(symbols.Take(5).ToArray()), ICollection\u0026lt;char\u0026gt; symbols =\u0026gt; new string(symbols.ToArray()), null =\u0026gt; throw new ArgumentNullException(nameof(input)), _ =\u0026gt; throw new ArgumentException(\u0026#34;Not supported input type.\u0026#34;), }; 属性模式是可以嵌套的，对于匹配的属性类型，还可以继续进行模式匹配：\npublic record Point(int X, int Y); public record Segment(Point Start, Point End); static bool IsAnyEndOnXAxis(Segment segment) =\u0026gt; segment is { Start: { Y: 0 } } or { End: { Y: 0 } }; 对属性嵌套进行模式匹配有些麻烦，C# 10.0 以上可以使用\u0026quot;扩展属性模式\u0026quot;，即成员运算符来对属性进行匹配，可将上述示例中的方法重构为以下等效代码：\nstatic bool IsAnyEndOnXAxis(Segment segment) =\u0026gt; segment is { Start.Y: 0 } or { End.Y: 0 }; “优雅，实在太优雅了\u0026quot;（指属性模式\n位置模式 # 位置模式可以匹配\r元组中的元素：\nvar location = (5, 10); if (location is (5, 10)) ... 位置模式也可以和其他各种模式结合：\nif (location is (\u0026gt;5, \u0026lt;10)) ... 这使得switch表达式可以结合元组一次匹配任意个对象：\nstatic int[] Encode(int x, int y) =\u0026gt; (x, y) switch { (\u0026lt; left, \u0026gt; top) =\u0026gt; new[] { 1, 0, 0, 1 }, (\u0026lt; left, \u0026lt; bottom) =\u0026gt; new[] { 0, 1, 0, 1 }, (\u0026gt; right, \u0026gt; top) =\u0026gt; new[] { 1, 0, 1, 0 }, (\u0026gt; right, \u0026lt; bottom) =\u0026gt; new[] { 0, 1, 1, 0 }, (_, \u0026gt; top) =\u0026gt; new[] { 1, 0, 0, 0 }, (_, \u0026lt; bottom) =\u0026gt; new[] { 0, 1, 0, 0 }, (\u0026lt; left, _) =\u0026gt; new[] { 0, 0, 0, 1 }, (\u0026gt; right, _) =\u0026gt; new[] { 0, 0, 1, 0 }, _ =\u0026gt; new[] { 0, 0, 0, 0 } }; 如果对象声明了\r解构函数，可以直接对其使用位置匹配：\npublic readonly struct Point { public int X { get; } public int Y { get; } public Point(int x, int y) =\u0026gt; (X, Y) = (x, y); public void Deconstruct(out int x, out int y) =\u0026gt; (x, y) = (X, Y); // 声明解构函数 static string Classify(Point point) =\u0026gt; point switch //对对象解构出的元组进行匹配 { (0, 0) =\u0026gt; \u0026#34;Origin\u0026#34;, //使用位置模式匹配point对象解构出的元组 (1, 0) =\u0026gt; \u0026#34;positive X basis end\u0026#34;, (0, 1) =\u0026gt; \u0026#34;positive Y basis end\u0026#34;, _ =\u0026gt; \u0026#34;Just a point\u0026#34;, }; } 结合关系模式，使用元组内元素的名称：\nvar numbers = new List\u0026lt;int\u0026gt; { 1, 2, 3 }; if (SumAndCount(numbers) is (Sum: var sum, Count: \u0026gt; 0)) //返回元组可以使用关系模式访问其元素 { Console.WriteLine($\u0026#34;Sum of [{string.Join(\u0026#34; \u0026#34;, numbers)}] is {sum}\u0026#34;); // output: Sum of [1 2 3] is 6 } static (double Sum, int Count) SumAndCount(IEnumerable\u0026lt;int\u0026gt; numbers) { int sum = 0; int count = 0; foreach (int number in numbers) { sum += number; count++; } return (sum, count); } var模式 # 可使用 var 模式来匹配任何表达式（包括 null），并将其结果分配给新的局部变量\nstatic bool IsAcceptable(int id, int absLimit) =\u0026gt; SimulateDataFetch(id) is var results \u0026amp;\u0026amp; results.Min() \u0026gt;= -absLimit \u0026amp;\u0026amp; results.Max() \u0026lt;= absLimit; static int[] SimulateDataFetch(int id) { var rand = new Random(); return Enumerable .Range(start: 0, count: 5) .Select(s =\u0026gt; rand.Next(minValue: -10, maxValue: 11)) .ToArray(); } 需要布尔表达式中的临时变量来保存中间计算的结果时，var 模式很有用。 当需要在 switch 表达式或语句的 when 大小写临界子句中执行更多检查时，也可使用 var 模式，如以下示例所示：\npublic record Point(int X, int Y); static Point Transform(Point point) =\u0026gt; point switch { var (x, y) when x \u0026lt; y =\u0026gt; new Point(-x, y), var (x, y) when x \u0026gt; y =\u0026gt; new Point(x, -y), var (x, y) =\u0026gt; new Point(x, y), }; static void TestTransform() { Console.WriteLine(Transform(new Point(1, 2))); // output: Point { X = -1, Y = 2 } Console.WriteLine(Transform(new Point(5, 2))); // output: Point { X = 5, Y = -2 } } 弃元模式 # 用_符号来在\rswitch表达式中充当default开关\n列表模式 # 从C# 11开始，可以使用列表模式匹配列表中的内容：\nint[] numbers = { 1, 2, 3 }; Console.WriteLine(numbers is [1, 2, 3]); // True Console.WriteLine(numbers is [1, 2, 4]); // False Console.WriteLine(numbers is [1, 2, 3, 4]); // False Console.WriteLine(numbers is [0 or 1, \u0026lt;= 2, \u0026gt;= 3]); // True 如前面的示例所示，当每个嵌套模式与输入序列的相应元素匹配时，列表模式就会匹配。 可使用列表模式中的任何模式。 若要匹配任何元素，请使用弃元模式，或者，如果还想捕获元素，请使用 var 模式，如以下示例所示：\nList\u0026lt;int\u0026gt; numbers = new() { 1, 2, 3 }; if (numbers is [var first, _, _]) //捕获第一个元素，丢弃后两个元素 { Console.WriteLine($\u0026#34;The first element of a three-item list is {first}.\u0026#34;); } 如果无需匹配整个序列，而是只需要匹配列表的头尾，可以使用切片模式..：\nConsole.WriteLine(new[] { 1, 2, 3, 4, 5 } is [\u0026gt; 0, \u0026gt; 0, ..]); // True 匹配前两个 Console.WriteLine(new[] { 1, 1 } is [_, _, ..]); // True 匹配前两个并弃元 Console.WriteLine(new[] { 1 } is [1, 2, ..]); // False 数量不一致，匹配错误 Console.WriteLine(new[] { 1, 2, 3, 4 } is [.., \u0026gt; 0, \u0026gt; 0]); // True 匹配最后两个 Console.WriteLine(new[] { 2, 4 } is [.., \u0026gt; 0, 2, 4]); // False 匹配最后三个 Console.WriteLine(new[] { 2, 4 } is [.., 2, 4]); // True Console.WriteLine(new[] { 1, 2, 3, 4 } is [\u0026gt;= 0, .., 2 or 4]); // True 匹配第一个和最后一个 Console.WriteLine(new[] { 1, 0, 0, 1 } is [1, 0, .., 0, 1]); // True 匹配前两个和最后两个 Console.WriteLine(new[] { 1, 0, 1 } is [1, 0, .., 0, 1]); // False 嵌套其他模式：\nvoid Validate(int[] numbers) { var result = numbers is [\u0026lt; 0, .. { Length: 2 or 4 }, \u0026gt; 0] ? \u0026#34;valid\u0026#34; : \u0026#34;not valid\u0026#34;; Console.WriteLine(result); } Validate(new[] { -1, 0, 1 }); // output: not valid Validate(new[] { -1, 0, 0, 1 }); // output: valid ","date":"2023年6月13日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/csharp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A6%82%E8%BF%B0/","section":"Posts","summary":"","title":"C#模式匹配概述"},{"content":" 本文章将举例介绍绝大多数C# 10的新特性，在.NET 6以上的项目支持这些特性。\n有些预览特性需要在项目配置文件(.csproj)中配置\u0026lt;LangVersion\u0026gt;preview\u0026lt;LangVersion/\u0026gt;才可生效\nC#10新增功能\n全局Using # 在任何一个C#类中使用global关键字修饰using指令，该using指令将会应用于整个项目\nglobalUsing.cs\n//这些using将会应用到整个项目 global using System.Collection.Generic; global using Newtonsoft.Json; ... 文件范围的命名空间 # 在C#文件中指定命名空间时可以不用花括号{}了，该命名空间将会应用于整个文件范围。但相反的，你无法在一个cs中定义多个命名空间中的内容（一般来说也不会这样做）。\nusing System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using Microsoft.IdentityModel.Tokens; namespace Azusa.Shared.Security;//不使用{}指定范围，整个文件都将被定义到该命名空间中。 public static class JwtTokenGenerator { ... } 常量内插字符串 # 你可以在const string中使用内插字符串了，你可以将用在某些只接受常量字符串的地方。\n... private const string BaseUrl = \u0026#34;localhost:7890\u0026#34;; public const string SignInUrl = $\u0026#34;{BaseUrl}/SignIn\u0026#34;;//你可以使用$内插常量字符串了 ... [HttpGet(SignInUrl)]//在这种地方适合使用常量字符串！ 泛型特性（注解） # C#特性也支持泛型了，传递类型参数更加方便，不需要typeof了。\npublic class UnitOfWorkAttribute\u0026lt;TDbContext\u0026gt; : Attribute where TDbContext : DbContext { ... } Lambda表达式改进 # var关键字可以推断lambda表达式的返回值了\nvar func = () =\u0026gt; \u0026#34;Nice\u0026#34;;//现在编译器可以推断出这个lambda是Func\u0026lt;string\u0026gt;了 var func1 = () =\u0026gt; null;//不过这样是不行的，因为null没有类型 var func2 = string? () =\u0026gt; null;//但是可以显式指定一下 特性也可以支持在lambda上标注了\nvar func3 = [UnitOfWorkAttribute\u0026lt;MyDbContext\u0026gt;()](long id) =\u0026gt; myDbCtx.Books.Find(id); 模式匹配属性扩展 # 在模式匹配的时候可以匹配对象的属性，并且用成员运算符.来匹配属性对象的属性\nif (book is Book{PubTime.Month:12})//用成员运算符来读取对象属性的属性 { ... } //以前得这样 if (book is Book { PubTime: { Month: 12 } }) { } 记录(record)结构体 # record类型也可以声明为结构体了，也是值类型。\npublic record struct Color(short Red, short Green, short Blue); 结构体的优化 # 在C#10以前，结构体的显式构造函数必须得给所有字段和自动属性赋值 比如这样一个结构体\npublic struct Color { public short Red { get; set; } public short Green { get; set; } public short Blue { get; set; } ... } 构造函数要么不写（隐式无参），要么写全（显式，并且所有自动属性和字段都得赋值）\n（很迷惑的操作，不知为何要这样设定）\n... public Color(short red, short green, short blue)//字段和自动属性都得赋值 { Red = red; Green = green; Blue = blue; } ... C#10以后，将接受赋值不完全的显式构造函数\npublic Color(short red, short green) { Red = red; Green = green; } 并且，C#10的结构体也支持with关键字\nvar color = new Color(122, 255, 255); var color1 = color with { Green = 12 }; 在同一析构中进行赋值和声明 # 可以通过析构对象来给变量赋值，或是\n(int x, int y) = point;//析构对象来初始化两个变量，注意这不是元组 int x1 = 0; int y1 = 0; (x1, y1) = point;//析构对象给现有变量赋值 在C#10以前初始化和赋值不能同时进行\nint x = 0; (x, int y) = point;//C#10以前会错误 但现在不会\n","date":"2023年4月12日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/csharp10%E6%96%B0%E7%89%B9%E6%80%A7/","section":"Posts","summary":"","title":"C#10新增功能"},{"content":"\r驾驶证 # 常规 # 年龄要求： c1,c2: 18+无上限 c6:20-60 货车：20+ 有效期： 6年-\u0026gt;10年-\u0026gt;长期 体检： 中大型公交牵引车每年体检 任何限时题目： 有90日选择90日，否则选择30日 驾驶证周期： 12月 驾驶证实习期： 12月 有效期： 准考证3年内，实习期需要3年驾龄司机陪同，延期审验3年 证件相关： # 车“登记”，证随意\n驾驶证遗失损毁补领，任意地点均可 证件带有“车”字需要在登记地处理 车辆变化除防撞杆，都需要登记 不得申请驾驶证时间 # 假1骗3毒3醉5逃逸犯罪终生\n满分教育 # 现场学习至少2天，网络学习至少3天，总计至少7天 扣满每12分学习7天，小车最多60天 扣满12分重学科目1，24-35重学科目1科目3，36+重学科目123 学习减分 # 实习期内不可以参与 酒驾处罚三个周期内不能参与 两次以上满分教育不能参与 每次参与最多减六分 网络学习30分钟减1分，现场学习1小时减2分，公益活动1小时减1分 证件车辆扣留 # 缺少 驾驶证|行驶证|保险标识|检验合格标识|车牌 扣留\n刑法 # 重大事故致人死亡 - 3年 致人死亡逃逸 - 3-7年 因逃逸致人死亡 - 7年+ 组织作弊形成犯罪 - 3-7年 其他拘役 选择题：有拘役则对，有刑结尾则错\n事故处理 # 有争议则报警 无争议则撤离，不撤离罚款200 救援 # 骨折要固定，不要移动 失血先止血，止血按压近心端 燃烧喷冷水，其他会感染 顺序通行 # 常规 # 右转让左转，左转让直行 超车从左侧 特殊路段不能超车 有特殊车辆不能超车 不走公交车道 会车时 # 山体外侧先行 环岛内先行 无障碍先行 主路车先行 下坡车先行 校车 # 两车道停车等待 三车道变最左道超车 车辆故障 # 开危险警报闪光灯 防止警报标志 50 - 100m，高速路150m+ 停车距离 # 路口5站3，题中带有“路/口”（路口，道口，危险狭窄路段）则50m，带有“站”（车站，加油站）则30m\n灯光 # 雾灯：除了雾天使用，其他都错 危险警报闪光灯：停车，故障，雾天，牵引故障车 左右转向：转弯，变道，停车时打右转向，闸道进道路打左转向 远光灯：照明不足 闪烁：超车，通过路口，通过人行道，急弯道路 其他情况均为近光灯 切换远近灯光距离为150m 速度和距离 # 特殊道路 # 无标识情况，特殊道路全部为30km/h 普通道路 # 无线：“城3公4”，有线：“城5公7”\n有中心线：城市50，公路70 无中心线：城市30，公路40 高速行驶能见度 # 能见度200m：车速小于60，行车距离100m 能见度100m：车速小于40，行车距离50m 能见度小于50m：车速小于20，尽快离开 高速速度 # 100km/h：距离100m \u0026lt;100km/h：距离50m 高速限速 # 有标识优先按标识\n3车道：左11-12，中9-11，右6-9 2车道：左10-12，右6-10 停车 # 停车 # 单条斜杠：禁止长时间停车 叉：禁止停车 地面标识 # 路沿上黄线：虚线禁止长时间停车，实线禁止停车 计分 # 扣分值仅为3分的幂\n超速 # 普通道路 # 超速20%-50%，扣3分 超速50%+，扣6分 高速公路翻倍 # 超速20%-50%，扣6分 超速50%+，口12分 其他 # 大型车在高速以外超速10%-20%，扣1分 高速低于最低时速，扣3分 超员 # 大型汽车 # 超出核定人数20%以下，扣6分 超出核定人数20%以上，扣12分 七座以上载客汽车 # 超出核定人数50%以下，扣6分 超出核定人数50%-100%，扣9分 超出核定人数100%以上，扣12分 其他载客汽车 # 超出核定人数20%-50%，扣3分 超出核定人数50%-100%，扣6分 超出核定人数100%以上，扣12分 超载 # 超载30%以下，扣1分 超载30%-50%以下，扣3分 超载50%以上，扣6分 安全检验 # 校车，大型车未定期安全检查，扣3分 其他车辆扣1分 道路行驶 # 普通道路 # 不按规定回车，掉头，逆行：3分 不规避行人：3分 不规避校车：3分 借道占道：3分 闯红灯：6分 高速公路 # 不按规定车道行驶：3分 倒车，逆行：12分 违法停车：9分 占用应急车道：6分 车牌 # 不按规定安装车牌号（并非伪造遮挡）：3分 故意遮挡，伪造车牌号：9分 驾驶证 # 驾驶证被暂扣期间驾驶机动车：6分 驾驶车型不符：9分 疲劳驾驶 # 载货汽车：6分 载客汽车：9分 其他1分考点 # 违反标线 不按规定使用灯光 未系安全带 载货车长宽高超出规定 擅自改装 其他3分考点 # 接听手机 故障，事故后没有摆放标识和使用灯光 没有对校车安全隐患检查 其他6分考点 # 事故逃逸，无死亡，轻伤 ","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%85%B3%E9%94%AE%E8%AF%8D%E8%AE%B0%E5%BD%95/","section":"Posts","summary":"","title":"科目一关键词记录"},{"content":"","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/%E5%85%B6%E4%BB%96/","section":"Categories","summary":"","title":"其他"},{"content":"","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/oop/","section":"Tags","summary":"","title":"OOP"},{"content":" 在阅读前你需要先掌握C#类的语法并了解类与对象的基本概念。\n概念 # 顾名思义面向对象编程即是将真实事物在代码中抽象地表达出来，以现实世界中解决问题的思路来解决程序上的问题。在C#中，事物的类型即为类(class)，类中定义了该事物的数据和操作数据的方法，每个事物对应着一个对象(object)。面向着对象编程即为OOP(Object-Oriented Programing)。\nOOP最大的特点即“面向对象”，整个编程的流程都是围绕着类与对象的。\n举例说明： 以经典的银行存取款例子来讲，假定一个文件中保存着你银行的余额，当你需要编写一个程序对该文件进行操作，提供存取款的功能时，传统面向过程编程的流程应该是：\n打开文件，读取余额并创建一个变量来缓存。 若要存款，则输入金额 在余额变量上加上输入的金额 将余额写入到文件 若要取款，则输入金额 在余额变量上减去输入的金额 将余额写入到文件 面向对象编程的流程应该是：\n定义一个ATM类，拥有余额字段，存款方法，取款方法 完善类方法，存款方法将输入的金额加到余额字段上，然后写入文件。取款方法将余额减去输入的金额，然后写入文件 打开文件，读取余额并创建一个ATM对象，使用余额初始化该对象。 若要存款，则调用ATM对象的存款方法 若要取款，则调用ATM对象的取款方法 OOP的优点：\n面向对象编程所作的流程明显更符合人类实际思考方式，这样能提高代码的可读性，使代码更容易理解和维护。 类与对象的封装增强了代码的复用性，减少重复的工作和开发。 面向对象增强了程序的模块化程度，减少模块之间的耦合性，提高程序灵活性和扩展性。 类的多态性实现了不同对象对同一事件的不同响应，增强了程序的多样性。 面向对象的特征 # 抽象 # 定义 # 抽象指将同类对象中提取出共性的特性，然后形成一个类(class)\n在C#中，类与类直接只能单一继承，不能继承多个类。\n例子 # 下面的代码提供了一个类的示例，将一个姓名属性和更改姓名的方法封装到一个Person类中：\npublic class Person { //姓名属性 public string Name { get; } //方法 public void ChangeName(string name) { Name = name; } } 在编程时，可以使用该类作为一个Person对象，并可以读取和更改其姓名\n抽象的好处 # 抽象化模拟了现实世界的事物和行为，提高了代码可读性。 增强了代码模块化程度 降低了代码的耦合和复杂度 封装 # 定义 # 封装指隐藏类/对象内部的状态和功能，仅通过一组公共的成员来进行访问\n对类中的成员添加访问修饰符以指定成员的访问级别。\nC#中访问修饰符有四种:\nprivate:私有，只有当前类内部的才能访问\npublic:共有，公开访问，类的内外都可以访问\nprotected:保护，只有继承自该类的类可以访问\ninternal:内部，类的内外都可以访问，但仅限当前程序集\n其中，internal修饰符可以与其他三个叠加使用，如internal public即是在当前程序集中的类内外都可以访问。\n不指定访问修饰符的类默认为private\n例子 # 下面的代码举出了访问修饰符的例子：\npublic class Person { //私有修饰符 private string name; public string GetName() { //在类的内部可以访问 return name; } } public class Program { static void Main(string[] args) { Person p = new Person(); p.name; } } 使用访问修饰符限制了类中成员的访问级别，实现隐藏成员的效果，达到封装的目的。\n封装的好处 # 类的封装可以保护类内部的数据和代码不被外部访问，提高代码的安全性 封装隐藏了类中方法/属性的实现细节，只向外暴露简单的成员，外部调用时只需要知道该成员是干什么用的，而无需知道如何实现的，简化了操作。 在修改一个类的代码时，不会影响到其他类，除非修改的是公共成员并且该成员被其他类所调用 继承 # 定义 # 根据现有抽象创建新的抽象，说人话就是在原有类的基础上进行拓展，保留原有类的所有能力，在新的一个类上创建新的功能，此操作被称为 “继承”，原有的类被称为 “父类” 或 “基类” ，继承父类的新类被称为 “子类” 或 “派生类” ，子类继承父类的行为被称为 “派生”，可以说 “子类”继承自“父类”，而“父类”派生出“子类”。\n一般，定义复杂且多种类对象时，会把它们共性的特征集成到一个父类中，将它们独有的特征划分到子类。\n在C#中，类只能有一个基类，不能多重继承。\n例子 # 下面的代码展示了类的继承关系：\n//基类 public class Person { public string Name { get; } public void ChangeName(string name) { Name = name; } } //派生类，继承了Person类 public class Employee : Person { public string Company { get; } public void ChangeCompany(string company) { Company = company; } } //派生类，继承了Person类 public class Student : Person { public string School { get; set; } } 上述代码的Employee类继承自Person类，Studnet类也继承自了Person类，它们都会继承Person类的Name属性和ChangeName方法，但它们也有自己独有的属性和方法。\nbase关键字 # 在子类中使用base关键字可以访问到父类的公开或保护内容\npublic class Employee : Person { ... public string GetName() { //使用base关键字访问父类的公开属性 return base.Name; } //使用base关键字访问父类的构造函数，如果父类的构造函数有参数，可以在这里传递 public Employee() : base() {} } sealed关键字 # 如果不想让某个类被继承，在声明类时添加sealed关键字，它阻止其他类继承该类。\n//其他类若尝试继承Boss类将会有编译错误 public sealed class Boss : Person { ... } 继承的好处 # 优化类之间的关系，减少冗余，提高代码的复用性，减少错误的可能。 提供 “多态性” 多态 # 定义 # 多态也是面向对象的核心，它指跨多个抽象以不同方式实现继承属性或方法的能力。多态的实现依赖于继承，所以必须要定义多个类并有继承关系，派生类可以各自对父类的方法实现进行修改，在调用时表现出不同的行为，大大增加编程的灵活度。在使用类时，使用多个派生类实例化出多个对象，对这些对象调用同样的基类方法，但却表现出不同的行为，这便是多态。\n下面是实现多态必要的一些概念：\n抽象类 # 将对象或已有的类更加抽象化成为一个新的类，以至于无法具体化（无法创建出该类的对象，因为过于抽象而缺少某些创建类所必要的数据或方法）。这样的类被称为抽象类，在类修饰符class前加上abstract修饰符将定义的类转换为抽象类，抽象类无法被实例化，只能称为其他类的基类。\n抽象类可以有构造函数，但是不能够使用new实例化，构造函数仅供子类使用。 虚方法 # 有时将已有类的提取成基类后，会遇到部分子类对与某些方法的实现方式不一致。在类中定义方法时加上virtual关键字，可让子类使用override关键字重写基类方法的实现。\n举一个现实中的例子：以前的所有轿车都是由燃油驱动的，它们有着“移动”行为，并且该都是以\u0026quot;燃油驱动\u0026quot;。但随着时代变化，出现了电力驱动的轿车，即使驱动原理不一样了，但它们还是有着“移动”行为。\n从编程方面来看，轿车类Car有着Move方法，该方法是“由燃油驱动的”，但出现了新的类ElectricCar电动车类，它继承自Car类，但是它对Move方法的实现却不一样，它是“电力驱动的”。此时，可以将Car类中的Move方法标记为虚方法virtual，然后在派生类中重写该方法。\n下面的类定义了一个轿车类，有着用燃油驱动的Move方法：\npublic class Car { //使用virtual关键字定义虚方法 public virtual void Move() { //用燃油驱动 ... } } 有一个类ElectricCar继承了Car类，并重写了父类的Move方法：\npublic class ElectricCar : Car { //使用override关键字重写父类的虚方法 public override void Move() { //用电力驱动 ... } } 此时使用Car类和ElectricCar类分别实例化出对象，调用Move方法，它们表现出的行为将不一致。\n... Car c = new Car(); //燃油驱动 c.Move(); ElectricCar ec = new ElectricCar(); //电力驱动，该派生类重写了Move方法 ec.Move(); ... 在类中使用virtual关键字在方法前标注，来声明一个虚方法。 在派生类中使用override关键字对父类中的虚方法进行重写，修改方法的实现过程。 如果不想完全重写虚方法，只是想要在父类的方法基础上添加代码，可以在重写时用base关键字调用父类方法。 sealed关键字也适用于虚方法，它阻止派生类重写方法。 抽象方法 # 抽象方法类似于虚方法，子类可以重写方法的实现。但是有时子类对方法的实现各不相同，无法统一出一个父类的实现方法，这个方法便被抽象化成为一个抽象方法。\n抽象方法在类的方法前使用abstract关键字定义，抽象方法没有方法体，仅定义了方法名，返回值和参数。在子类同样使用override对父类的抽象方法进行重写。\n定义了抽象方法的类必须为抽象类，因为这个类有方法没有被实现，无法实例化。\n若一个类的基类是带有抽象方法的抽象类，除非该派生类也是一个抽象类，不然就必须重写所有的抽象方法。\n再举一个例子：三角形和矩形都属于“形状”，都可以求出其面积，但它们计算面积的公式是不一样的。\n从编程方面来看，三角形和矩形可以提取出一个父类Shape（形状）类，Shape类中有一虚方法Area用于计算形状的面积。三角形Triangle类和矩形Rectangle类都继承自Shape，并且重写了Area方法。\n但这样设计的问题是，Shape类过于抽象，创建成对象是没有意义的，而且无法实现Area方法，只能留空。\n此时就可以将Shape类的Area方法标记为抽象方法，并且将Shape类标记为抽象类。抽象类无法实例化，只能用来继承，抽象方法也不需要实现，只能用来重写。\n下面的代码对抽象方法进行了示例：\n//带有抽象方法的类必须为抽象类 public abstract class Shape { //使用abstract关键字声明了一个抽象方法，没有方法体。 public abstract float Area(); } public class Triangle : Shape { //使用override关键字重写了父类的抽象方法，如果没有重写该方法，将会有编译错误 public override float Area() { ... } } public class Rectangle : Shape { public override float Area() { ... } } 抽象方法不需要方法实现，只需要定义名称，参数和返回值即可，但该类的派生类必须提供重写该抽象方法。 抽象方法的访问修饰符不能为private，因为抽象方法需要子类的实现。 若一个类拥有抽象方法，它就必须被修饰为抽象类，因为抽象方法需要一个子类提供实现。 接口 # 类抽象的极限是只包含方法，类中没有任何数据，只定义了该类的行为，这样抽象到极限的类被称为 “接口”。而继承了该类的类也不叫派生类了，它们被称为 “实现类”，而继承这一操作名也变为了 “实现”，即某类实现了某接口，定义接口的关键字不是class，变为了interface。\n接口类似于抽象类，但比抽象类更加抽象，无法定义数据，只能定义行为，而且实现接口的类都必须实现接口中定义的所有成员。\n接口一般用来定义某些行为，而不是一类事物，比如C#中的IEnumerable（可枚举）接口。某个类实现了接口，就代表它能够实现这些行为。\n在C#中，接口只能定义方法，属性，索引器和事件。 在C#中，类只能继承一个类，但允许实现多个接口，在程序中可以让类实现多个接口，以表现出各类不同的行为。在对类的功能进行拓展时，也可以添加实现的接口来让类实现相应的方法。 在C#中，接口的命名应当以字母I开头。 下面的代码展示了接口和实现类的定义：\n//使用interface关键字定义接口 public interface IMoveable { //定义接口属性 Vector2 Position { get; } //定义接口方法，无需方法体 void Move(int x, int y); } public class Car : IMoveable { //实现接口中的属性和方法 public Vector2 Position { get; } public void Move(int x, int y) { Position.x = x; Position.y = y; } } 接口定义的成员都不需要实现，实现类必须实现接口的所有成员。 接口成员可以不加访问修饰符，默认会赋予public，接口成员的访问修饰符不能为private，因为私有的接口方法没有意义。 新版本特性\n在高版本的C#，接口中的方法可以有方法体，接口中也可以定义静态抽象成员和虚拟成员，具体参考官方文档：\r接口\n替换 # 向上转换(upcasting)\n在对对象进行操作时，派生类对象的引用可以替换基类的引用：\nPerson p1 = new Person();//实例化Person对象 Employee e1 = new Employee();//实例化Employee对象 p1 = e1;//替换 上述代码演示了替换的过程，Employee类是Person类的派生，将其分别实例化出p1对象和e1对象，并将p1对象的引用替换成了e1对象。\n虽然两对象是不同类型的，但这样的替换操作是合法的，并不会有错误或警告，像这样使用派生类引用替换成基类引用的操作称为向上转换(Upcasting)。因为Employee类继承了Person类的所有数据，所以对p1对象进行的任何操作，都适用于e1对象，而不会导致任何问题。向上转换是可传递的，也就是说如果有一个类继承了Employee类，该类的对象也可以替换p1对象，因为该类也间接地继承了Person类。\n向下转换 ***向下转换(Downcasting)***和向上转换相反，即基类的引用替换派生类的引用：\nPerson p2 = new Person(); Employee e2 = new Employee(); e2 = (Employee)p2;//向下转换 上述代码演示了向下转换，向下转换是强制转换，代码中使用括号来进行强制转换，这个操作通常来说是不允许的。一个派生类可以在基类的基础上派生出新的数据成员，但这些成员并不能适用于基类对象，例如Employee类有一属性为Company，而使用Person类实例化的对象是访问不到该属性的，所以向下转换是不安全的，上述代码在运行时会报运行时错误。\n但有一种情况例外，如果转换对象是向上转换过来的，那么就不会报运行错误，例如：\nPerson e3 = new Employee();//在实例化时进行向上转换 Employee e4 = (Employee)e3;//向下转换 代码中的e3对象本身是Employee类型，但通过向上转换成了Person类型的引用，向上转换并不会清除派生类中的数据成员，所以向下转换回Employee类型时并不会报错。\n向上和向下转换也适用于抽象类和接口。\nis和as关键字\n在有些情况，向下转换操作是不可避免的。若要进行向下强制转换，可以使用C语言风格的()来强制转换，如e2 = (Employee)p2;，要是p2无法转换成e2，则会抛出异常。所以在向下转换前，通常要进行检查。\nC#提供is关键字判断对象类型，并返回true或false，在转换前使用is进行判断：\n//检查p2的类型是否是`Employee` if(p2 is Employee) { e2 = (Employee)p2; ... } C#还提供了as关键字来进行向下转换，和()的不同是，使用as转换失败并不会报错，而是返回null：\ne2 = p2 as Employee;//使用as关键字进行转换，如果失败则会返回null if(e2 == null) ...//转换失败 else ...转换成功 替换带来的多态性\n在对象向上转换过后，如果调用的方法被转换前的类型重写过，则会调用重写后的方法：\nShape t1 = new Triangle(); Shape r1 = new Rectangle(); Console.WriteLine(t1.Area()); Console.WriteLine(r1.Area()); 代码中使用Triangle类型和Rectangle类型实例化出s1和r1对象，并上转型成Shape类型，因为两个类型都重写了基类的Area方法，在调用两个对象的Area方法时，将会各自调用转换前类型调用重写后的方法，即使它们转换成了Shape类型。\n替换操作看起来会导致方法调用的混乱，但这样其实很好地运用了类的多态性。里氏替换原则提到：\n\u0026ldquo;如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致。\u0026rdquo;\n替换操作对类的通用性提升是巨大的。例如，你可以对一组继承自同一个类型的对象进行操作，它们将表现出不同的行为：\nobject[] data = { 100, \u0026#34;Alice\u0026#34;, 0.98f, Math.PI, DateTime.Now }; foreach (var obj in data) { Console.WriteLine(obj); } 上述代码使用了多个不同类型的对象初始化一个object类型的数组，在循环中，Console.WriteLine方法接收一个object类型对象，并调用对象的ToString方法，因为数组中对象的类型都各自重写了ToString方法，它们的输出将会表现出不同的效果。\n多态性的好处 # 增强了代码的通用性和简洁性，因为多态允许不同的对象执行相同的操作，但调用的方法却是同一个，这意味着程序员不需要写多个专门针对不同对象类型的方法。 增强了代码的可扩展性，当在一个较为完整的程序中添加新的对象类型，只需要选择要继承的类，实现需要的接口即可，不需要花费大量的事件思考类中有哪些成员。 面向对象五大原则（SOLID原则） # 单一职责原则，Single Responsibility Principle (SRP) # \u0026ldquo;每个模块都只有一个引起它变化的原因。\u0026rdquo;\n即一个类只负责一个功能领域的职责。单一职责原则是实现高内聚低耦合的关键，不要把太多的功能封装到类中，否则将会增加耦合度，大大降低可维护性。\n单一职责是程序设计阶段时划分类的一个好方法，只有全面了解程序的功能，才能很好地分离职责。\n开闭原则，Open/Closed Principle # “开”指对扩展开放，“闭”指对修改关闭。\n编写模块时应当尽量设计出不需要修改的模块，在扩展新功能的时候，只需要编写新的代码而无需修改旧的代码。\n满足开闭原则可以最大化模块的复用性和扩展性。\n一些设计模式很好地实现了开闭原则：如面向接口编程(Interface Based Programming)，将功能抽象成稳定的接口，在扩展代码时添加接口和实现方法即可。或是面向切面编程(AOP)，将模块分为多个层，使用事件回调等方法在层直接注入处理的代码，在添加功能时只需在需要的层中添加代码即可。\n里氏替换原则，Liskov Substitution Principle (LSP) # \u0026ldquo;如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致。\u0026rdquo;\n换句话说，派生类必须可以替换其基类。\n什么叫“与期望的行为一致”?\n“在不了解派生类的情况下，仅通过接口或基类的方法，即可清楚的知道方法的行为，而不管哪种派生类的实现，都与接口或基类方法的期望行为一致。或者说接口或基类的方法是一种契约，使用方按照这个契约来使用，派生类也按照这个契约来实现。这就是与期望行为一致的替换。”\n在运用类的多态性时，不应当违背里氏替换原则。在派生类中重写方法时，应当保证每个派生类重写方法的最终目的都是一致的，即“与期望的行为一致”。\n例如Triangle类和Rectangle类都重写了Shape类的Area方法，它们都应当保证重写后能正确返回图形的面积，而不是返回周长。\n接口隔离原则，Interface Segregation Principle (ISP) # \u0026ldquo;客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。\u0026rdquo;\n接口不应过于臃肿，尽量细化接口，减少接口中方法的数量，降低类对单个接口的依赖性。\n接口越大，它越有可能包含并非所有实现类都能使用的到的方法。如果一个类和某个接口没有一致的目的，那就不要实现那个接口。\n依赖倒置原则，Dependency Inversion Principle (DIP) # \u0026ldquo;高级模块/类不应当依赖于低级的模块/类，首先两者都应当依赖于其抽象。其次，抽象不应当依赖于实现。最后，实现应当取决于抽象。\n说人话就是，当两个模块/类有依赖关系时，首先它们都应当继承自某个类或实现某个接口。然后，在对一个派生程度较低的类进行设计时，不应当依赖于一个派生程度较高的类，应该使用其基类或是接口等派生程度较低的类进行依赖。\n当一个类依赖于另一个类的一个明确的实现时，如果依赖类的实现改变了，当前类可能会被破坏。因此，在对一个功能进行依赖时，应当面向抽象编程，而不是面向实现。\n总结 # 面向对象为编程提供了一个很好的思路，遵循SOLID原则可以构建一个代码整洁，可读性高，且易于维护的应用程序，但过于追求这些繁文缛节可能会大幅增加代码量。规则是死的人是活的，在进行编程时必须权衡这些规则带来的代码质量和代码数量，毕竟，20行代码可比200行代码要少得多。\n参考内容\n类继承：Stephen Prata. C++ Primer Plus.\nC#面向对象：\rhttps://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/oop\nC#接口：\rhttps://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface\nC#默认接口方法：\rhttps://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods SOLID原则：\rhttps://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/\n里氏替换原则：\rhttps://zhuanlan.zhihu.com/p/268574641\n","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B-csharp/","section":"Posts","summary":"","title":"面向对象的编程（C#）"},{"content":"\r.NET 表达式树 # .NET Expression表达式树将代码抽象成了一颗对象树，树上的每一个节点都是一个代码表达式，它的构造类似编译原理中的抽象语法树（AST）。\n可以使用lambda表达式进行声明表达式树，编译器将会自动转换，但是该lambda表达式不能是语句（即表达式只能有一句，不能用{}组成多句）。\n表达式树可以转换为委托，在一些linq场景可以通过构建表达式树来动态拼接一些linq查询条件。\n表达式树入门 # 一个表达式树是类似以下的结构\n表达式C\r| +-----+-----+\r| |\r表达式A 表达式B 比如简单的lambda表达式x =\u0026gt; x + 1可以用转化为以下表达式\nx + 1\r|\r+---+---+\r| |\rx 1 其中叶子节点x为变量表达式，叶子节点1为常量表达式，x+1节点为二叉表达式，使用了+运算符\n在C#中，表达式树可以通过Expression及其派生类的各种方法手动构建，Exression类常用的静态方法如下：\nExpression.Constant() 创建一个常量表达式。 Expression.Variable() 创建一个变量表达式。 Expression.New() 创建一个实例化表达式。 Expression.Assaign() 创建一个赋值表达式。 Expression.Equal() 创建一个相等比较表达式。 Expression.Call() 创建一个方法调用表达式。 Expression.Condition() 创建一个分支逻辑表达式。 Expression.Loop() 创建一个循环逻辑表达式。 Expression.Add()/Subtract()/Multiply()/Divide() 加/减/乘/除表达式\n\u0026hellip; 使用C#代码构造简单的表达式树 # x =\u0026gt; x + 1\npublic static void Example1() { var param1 = Expression.Variable(typeof(int), \u0026#34;x\u0026#34;);//声明变量表达式，类型为int，参数名为\u0026#34;x\u0026#34; var const1 = Expression.Constant(1);//常量表达式 var biExpr = Expression.Add(param1, const1);//声明进行加法运算的二叉表达式，左节点为x,右节点为1 //x =\u0026gt; x + 1表达式树就构成了 //使用Expression.Lambda方法可以将表达式树转换为lambda表达式树，在类型参数中可以指定转换的委托类型 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;int, int\u0026gt;\u0026gt;(biExpr, param1);//lambda输入参数为x变量 //使用LambdaExpression.Compile方法将转换好的lambda表达式树编译成委托 Func\u0026lt;int,int\u0026gt; func = lambdaExpr.Compile(); //调用编译出的委托 Console.WriteLine(func(5)); } 更复杂一些的表达式树 # (a,b,c) =\u0026gt; (a + b + c) / 3\npublic static void Example2() { var param1 = Expression.Variable(typeof(int), \u0026#34;a\u0026#34;); var param2 = Expression.Variable(typeof(int), \u0026#34;b\u0026#34;); var param3 = Expression.Variable(typeof(int), \u0026#34;c\u0026#34;); var const1 = Expression.Constant(3.0f,typeof(float)); var biExpr1 = Expression.Add(param1, param2);//构造参数1，2，生成加法表达式树1 var biExpr2 = Expression.Add(biExpr1, param3);//构造加法表达式树1和参数3，生成加法表达式树2 var biExpr3 = Expression.Convert(biExpr2, typeof(float));//两整形相除不会保留小数，转化为浮点型 var biExpr4 = Expression.Divide(biExpr3, const1);//构造加法表达式树2和常量表达式1，生成除法表达式树3 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;int,int,int,float\u0026gt;\u0026gt;(biExpr4, param1,param2,param3);//根据表达式树3和三个参数，将表达式树转换为lambda表达式树 var func = lambdaExpr.Compile(); Console.WriteLine(func(2, 3, 3)); } 方法调用表达式 # (str,value) =\u0026gt; !string.IsNullOrWhiteSpace(str) \u0026amp;\u0026amp; str.Contains(value)\npublic static void Example3() { var param1 = Expression.Variable(typeof(string), \u0026#34;str\u0026#34;); var param2 = Expression.Variable(typeof(string), \u0026#34;value\u0026#34;); //使用反射获取静态方法，并与参数表达式构造成方法调用表达式 var callExpr1 = Expression.Not(Expression.Call(typeof(string).GetMethod(nameof(string.IsNullOrWhiteSpace), new Type[]{typeof(string)})!, param2)); //使用反射获取实例方法，实例方法需要指定调用实例的表达式 var callExpr2 = Expression.Call(param1, typeof(string).GetMethod(nameof(string.Contains), new[] {typeof(string)} )!, param2); var biExpr1 = Expression.AndAlso(callExpr1, callExpr2);//与运算 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;string,string,bool\u0026gt;\u0026gt;(biExpr1, param1,param2); var func = lambdaExpr.Compile(); Console.WriteLine(func(\u0026#34;Azusa\u0026#34;, \u0026#34;s\u0026#34;)); } 一些实际的应用 # /// \u0026lt;summary\u0026gt; /// 推断实体属性的特性和名称，并根据搜索关键字构建过滤器表达式树 /// 注意，反射推断比较消耗性能 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;keyword\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; BuildKeywordSearchExpression(string keyword) { //获取实体类所有公用|实例属性 var propInfos = typeof(TEntity).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.GetProperty); //获取所有具有SearchKeywordAttribute特性的属性，作为目标属性 var targetProps = propInfos.Where(info =\u0026gt; info.GetCustomAttribute\u0026lt;SearchKeywordAttribute\u0026gt;() is not null); //如果没有任何属性带SearchKeywordAttribute则按照属性名匹配，如果符合\u0026#34;name\u0026#34;或是\u0026#34;title\u0026#34;或是\u0026#34;content\u0026#34;，那就作为目标属性 if (!targetProps.Any()) targetProps = propInfos.Where(info =\u0026gt; info.Name.ToUpper() is \u0026#34;NAME\u0026#34; or \u0026#34;TITLE\u0026#34; or \u0026#34;CONTENT\u0026#34;); //没有任何属性能够匹配则异常 if (!targetProps.Any()) throw new ServerErrorException(\u0026#34;没有任何能够进行过滤查询的属性，请在属性上添加[SearchKeywordAttribute]启用过滤\u0026#34;); //检查属性是否为字符串类型 if (!targetProps.All(info =\u0026gt; info.PropertyType == typeof(string))) throw new ServerErrorException(\u0026#34;过滤属性必须是字符串\u0026#34;); //构建 e =\u0026gt; (e.Name || Title || Content || [property with attribute]).Contain(keyword) 表达式树 //参数e表达式 var entityExpr = Expression.Parameter(typeof(TEntity),\u0026#34;entity\u0026#34;); //常量关键词表达式 var keywordExpr = Expression.Constant(keyword); //所有目标属性的表达式 var propExprs = targetProps.Select(info =\u0026gt; Expression.Property(entityExpr,info)).ToArray(); //所有的属性调用.Contain(keyword)并且进行或运算 var firstProp = propExprs.First(); Expression resultExpr = Expression.Call(firstProp, typeof(string).GetMethod(nameof(string.Contains), new[] { typeof(string) })!, keywordExpr); for (int i = 1; i \u0026lt; propExprs.Length; i++) { var containsExpr = Expression.Call(propExprs[i], typeof(string).GetMethod(nameof(string.Contains), new[] { typeof(string) })!, keywordExpr); resultExpr = Expression.Or(resultExpr,containsExpr); } //构造成委托 var lambda = Expression.Lambda\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt;(resultExpr, entityExpr); Console.WriteLine(lambda.ToString()); return lambda; } 上述代码根据所给的关键词，使用反射搜索类型参数中的TEntity类型的属性，探测带有SearchKeywordAttribute特性或是名为\u0026quot;Name\u0026quot;,\u0026quot;Title\u0026ldquo;或是\u0026rdquo;Content\u0026ldquo;的属性，并使用它们构造一个用于多个属性模糊查询的表达式树，返回一个Expression\u0026lt;Func\u0026lt;TEntity,bool\u0026gt;\u0026gt;表达式委托。\n这样的一个表达式可以自动地识别某个实体类的属性，并且根据这些属性通过Linq对IQuerable进行模糊查询，例如：\npublic class Post : IEntity\u0026lt;Guid\u0026gt;,IHasCreationTime,IHasModificationTime { public Guid Id { get; set; } [SearchKeyword] public string Title { get; set; } [SearchKeyword] public string Markdown { get; set; } public Guid? CategoryId { get; set; } public Category? Category { get; set; } public ICollection\u0026lt;Tag\u0026gt; Tags { get; set; } public DateTime CreationTime { get; set; } public DateTime? LastModificationTime { get; set; } private Post() { }//EFCore public Post(string title, string markdown = \u0026#34;\u0026#34;, Category? category = null, ICollection\u0026lt;Tag\u0026gt;? tags = null) { Id = SequentialGuidGenerator.Create(); Title = title; Markdown = markdown; Category = category; Tags = tags ?? new List\u0026lt;Tag\u0026gt;(); } } public Task\u0026lt;List\u0026lt;Post\u0026gt;\u0026gt; SearchAsync(string keyword) { return dbContext.Posts.Where(BuildKeywordSearchExpression(keyword)).ToListAsync(); } 方法中将根据实体属性上的特性自动生成 post =\u0026gt; post.Title.Contains(keyword) || post.Markdown.Contains(keyword) 表达式，并通过IQuerable和EFCore生成SQL语句对实体进行查询。\ninfo: 2023/4/24 23:30:37.812 RelationalEventId.CommandExecuted[20101] (Microsoft.EntityFrameworkCore.Database.Command) Executed DbCommand (22ms) [Parameters=[], CommandType=\u0026#39;Text\u0026#39;, CommandTimeout=\u0026#39;30\u0026#39;] SELECT [t].[Id], [t].[CategoryId], [t].[CreationTime], [t].[LastModificationTime], [t].[Markdown], [t].[Title] FROM [T_Posts] AS [t] WHERE (CASE WHEN [t].[Title] LIKE N\u0026#39;%net%\u0026#39; THEN CAST(1 AS bit) ELSE CAST(0 AS bit) END | CASE WHEN [t].[Markdown] LIKE N\u0026#39;%net%\u0026#39; THEN CAST(1 AS bit) ELSE CAST(0 AS bit) END) = CAST(1 AS bit) 参考文章\nhttps://masuit.com/1795?t=vou0ts7ora4g#%CE%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95 https://cloud.tencent.com/developer/article/1817790 ","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/net-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E5%85%A5%E9%97%A8/","section":"Posts","summary":"","title":".NET 表达式树入门"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/linq/","section":"Tags","summary":"","title":"Linq"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/asp-.net-core/","section":"Tags","summary":"","title":"ASP .NET Core"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/swagger/","section":"Tags","summary":"","title":"Swagger"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/web-api/","section":"Tags","summary":"","title":"Web API"},{"content":"\rSwagger文档 # 在ASP .NET Core项目中配置Swagger服务，在Swagger页面的接口中显示C#代码的注释。\nSwagger上的注释\r微软官方文档\n先决条件： 项目需要在Nuget中安装Swashbuckle.AspNetCore包（一般会在ASP .NET Core项目创建时自动安装）\n生成并导出XML文档 # 首先需要生成项目的XML文档。以 Visual Studio 为例，在项目属性-输出中勾选“生成包含API文档的文件”，并指定输出目录：\nVS中生成XML文档\r接着生成项目，会在指定目录下输出XML文档：\n输出的XML文档\r配置Swagger服务 # 在 StartUp 中配置服务\nprogram.cs\n//安装Nuget包后即可使用AddSwaggerGen方法添加Swagger服务 services.AddSwaggerGen(options =\u0026gt; { //定义Swagger文档，可多次定义以区分版本 //此时定义的文档名为v1 options.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo() { //添加一些API信息，将会呈现在Swagger页面上 Version = \u0026#34;v1\u0026#34;, Title = \u0026#34;用户信息控制器\u0026#34;, }); //指定XML文档的目录 options.IncludeXmlComments($\u0026#34;{Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}\\\\{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;, true); ... }); 配置Swagger中间件 # 在ASP .NET Core入口函数中配置中间件\nprogram.cs\n... var app = builder.Build(); //此时在开发环境下才会添加Swagger中间件 if (app.Environment.IsDevelopment()) { //添加Swagger中间件 app.UseSwagger(); //添加SwaggerUI中间件，在参数中指定Swagger终结点，终结点错误将会导致接口无法正常显示 //此时使用终结点是步骤2中声明的名为\u0026#34;v1\u0026#34;文档，如果定义了多个文档版本，则需要指定多个终结点 app.UseSwaggerUI(c =\u0026gt; c.SwaggerEndpoint(\u0026#34;/swagger/v1/swagger.json\u0026#34;, \u0026#34;Gehenna.WebAPI v1\u0026#34;)); } 如果使用IIS 或反向代理的路径，请使用 ./ 前缀将 Swagger 终结点设置为相对路径。 例如 ./swagger/v1/swagger.json。\n使用 /swagger/v1/swagger.json 指示应用在 URL 的真实根目录中查找 JSON 文件（如果使用，加上路由前缀）。例如，请使用 https://localhost:\u0026lt;port\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/v1/swagger.json 而不是 https://localhost:\u0026lt;port\u0026gt;/\u0026lt;virtual_directory\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/v1/swagger.json。\n配置完成 # 在API控制器类或终结点方法上添加XML注释。\n给控制器上添加注释\r给控制器操作方法添加注释\r配置完成后，访问https://localhost:\u0026lt;port\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/index.html页面上即可进入Swagger界面。\n页面的标题文字将显示配置Swagger服务时提供的数据。\nSwagger页面标题\r页面右上方的下拉框可以选择在步骤2/3中定义的Swagger的版本\nSwagger版本\r页面中将会显示控制器，API终结点方法的注释 接口注释\r如果给方法参数添加了注释，Swagger也会显示出来 方法参数的注释\r如果请求/响应的数据模型有添加注释，点击scheme显示 请求/响应模型注释\r在使用泛型作为API响应数据模型时显示注释 # //待补充\n参考文章：https://learn.microsoft.com/zh-cn/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-7.0\u0026amp;tabs=visual-studio\n","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%9C%A8asp-.net-core%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEswagger%E6%96%87%E6%A1%A3/","section":"Posts","summary":"","title":"在ASP .NET Core项目配置Swagger文档"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/javascript/","section":"Tags","summary":"","title":"Javascript"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/signalr/","section":"Tags","summary":"","title":"SignalR"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/websocket/","section":"Tags","summary":"","title":"Websocket"},{"content":"在使用SignalR向.NET后端进行实时通信时，时常会使用 AccessToken 进行用户授权。提供用户认证可以提高后端接口的安全性，并且可以利用SignalR的用户认证机制来向指定用户的所有SignalR连接发送消息。\n后端用户授权服务 # 在 ASP.NET Core 中添加授权机制： # Program.cs ... services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //此处使用JWTBearer进行授权验证 .AddJwtBearer(options =\u0026gt; { var secretKey = configurations.GetRequiredSection(\u0026#34;Jwt\u0026#34;).Get\u0026lt;JwtOption\u0026gt;().SecretKey??throw new ConfigurationErrorsException(\u0026#34;Jwt密钥未配置\u0026#34;); options.TokenValidationParameters = new() { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)), }; }); ... //添加认证机制需要引用Authentication与Authorization两个中间件 app.UseAuthentication(); app.UseAuthorization(); ... 在SignalR集线器类上添加Authorize特性 # 详细的授权信息与不同的授权规则参考\rASP.NET Core授权\n//添加授权 [Authorize] public class ChatHub : Hub { public override async Task OnConnectedAsync() { await base.OnConnectedAsync(); //在Hub类的Context.User属性中可以获取到SignalR通过websocket握手获取到的用户授权信息 await Console.Out.WriteLineAsync(Context.User.Identity.Name); } ... } 这样就为ASP .NET Core提供了基本的用户授权机制，在应用的终结点(endPoints)上添加[Autorize]特性来对此终结点进行用户授权。\n在客户端配置SignalR连接的访问令牌 # C#客户端 # ... _connection = new HubConnectionBuilder() .WithAutomaticReconnect() //在WithUrl方法的configureHttpConnection参数中配置 .WithUrl(HubUrl, options =\u0026gt; { //为AccessTokenProvider提供获取访问令牌的委托 //此处为应当查找并获取用户访问令牌的逻辑 options.AccessTokenProvider = () =\u0026gt; Task.FromResult(authorizationToken); }); .ConfigureLogging(builder =\u0026gt; builder.AddConsole()) .Build(); await _connection.StartAsync(); ... Javascript客户端 # ... this.hubConnection = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;this.hubUrl\u0026#34;,{ //为withUrl方法参数2的accessTokenFactory属性提供获取访问令牌的方法 accessTokenFactory: () =\u0026gt; this.getAccessToken(), skipNegotiation: true, transport: signalR.HttpTransportType.WebSockets }) .build(); await this.hubConnection.start(); ... 踩坑注意 # 在Javascript客户端，即使配置了访问令牌，在对后端SignalR集线器进行访问时服务器仍然会响应 401 Unauthorized 或是客户端抛出 SignalR Error: Failed to complete negotiation with the server 异常，若排除了Javascript客户端配置问题或是CORS跨域访问问题，则有可能是因为Javascript websocket API不支持设置请求报文头的原因。\n客户端使用HTTP协议向服务器进行访问令牌验证常用的方式是在报文头中添加 Authorization 标头，并提供访问令牌字符串。 请求标头中的Authorization项\r在SignalR进行Websocket连接前会进行协商(negotiation)，若客户端在建立SignalR连接时配置了访问令牌，则会在请求时附带上访问令牌。\n但在SignalR Javascript客户端进行协商时，访问令牌并不是添加在报文头中，而是以查询字符串的形式发送请求。 访问令牌放在了查询字符串中\rASP.NET Core并不会自动对查询字符串中的访问令牌进行授权，所以此时服务器将会返回 401 Unauthorized ，而Javascript客户端会抛出 SignalR Error: Failed to complete negotiation with the server (无法完成与服务器的协商） 异常。\n解决方法： # 在服务器端配置授权机制，在收到请求消息时手动进行授权处理。配置的方式有多种，较为简单的方式是直接在Authorization服务中添加事件：\nprogram.cs ... services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //使用JwtBearer作为认证令牌 .AddJwtBearer(options =\u0026gt; { var secretKey = configurations.GetRequiredSection(\u0026#34;Jwt\u0026#34;).Get\u0026lt;JwtOption\u0026gt;().SecretKey??throw new ConfigurationErrorsException(\u0026#34;Jwt密钥未配置\u0026#34;); options.TokenValidationParameters = new() { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)), }; //添加授权事件，在收到请求消息时进行处理 options.Events = new JwtBearerEvents() { OnMessageReceived = context =\u0026gt; { //从请求查询字符串中取出访问令牌 var accessToken = context.Request.Query[\u0026#34;access_token\u0026#34;]; //请求条件不符合则返回 if (!string.IsNullOrEmpty(accessToken) \u0026amp;\u0026amp; context.Request.Headers[\u0026#34;Upgrade\u0026#34;] == \u0026#34;websocket\u0026#34;) { //手动对上下文中的令牌属性赋值，剩下的授权由.NET自动完成 context.Token = accessToken; } return Task.CompletedTask; } }; }); ... 参考文章\nhttps://stackoverflow.com/questions/21260384/signalr-authenticating-with-access-token#comment32085907_21260384\n","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E4%B8%BAsignalr%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/","section":"Posts","summary":"","title":"为SignalR的连接配置用户认证"},{"content":"\r测试帖子 # 使用Hugo超快速建站\nHugo首页\nhugo new site Azusa\u0026rsquo;s Archive\n","date":"2023年3月10日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/hellow-world/hello-world/","section":"Posts","summary":"","title":"Hello World"},{"content":"","date":"0001年1月 1日","permalink":"/Hugo-Blog-Blowfish-Theme/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001年1月 1日","permalink":"/Hugo-Blog-Blowfish-Theme/series/","section":"Series","summary":"","title":"Series"}]