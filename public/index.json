[{"content":"","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"\r","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/","section":"Index","summary":"\r","title":"Index"},{"content":"","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"驾驶证\u003e\r驾驶证 # 常规\u003e\r常规 # 年龄要求： c1,c2: 18+无上限 c6:20-60 货车：20+ 有效期： 6年-\u0026gt;10年-\u0026gt;长期 体检： 中大型公交牵引车每年体检 任何限时题目： 有90日选择90日，否则选择30日 驾驶证周期： 12月 驾驶证实习期： 12月 有效期： 准考证3年内，实习期需要3年驾龄司机陪同，延期审验3年 证件相关：\u003e\r证件相关： # 车“登记”，证随意\n驾驶证遗失损毁补领，任意地点均可 证件带有“车”字需要在登记地处理 车辆变化除防撞杆，都需要登记 不得申请驾驶证时间\u003e\r不得申请驾驶证时间 # 假1骗3毒3醉5逃逸犯罪终生\n满分教育\u003e\r满分教育 # 现场学习至少2天，网络学习至少3天，总计至少7天 扣满每12分学习7天，小车最多60天 扣满12分重学科目1，24-35重学科目1科目3，36+重学科目123 学习减分\u003e\r学习减分 # 实习期内不可以参与 酒驾处罚三个周期内不能参与 两次以上满分教育不能参与 每次参与最多减六分 网络学习30分钟减1分，现场学习1小时减2分，公益活动1小时减1分 证件车辆扣留\u003e\r证件车辆扣留 # 缺少 驾驶证|行驶证|保险标识|检验合格标识|车牌 扣留\n刑法\u003e\r刑法 # 重大事故致人死亡 - 3年 致人死亡逃逸 - 3-7年 因逃逸致人死亡 - 7年+ 组织作弊形成犯罪 - 3-7年 其他拘役 选择题：有拘役则对，有刑结尾则错\n事故处理\u003e\r事故处理 # 有争议则报警 无争议则撤离，不撤离罚款200 救援\u003e\r救援 # 骨折要固定，不要移动 失血先止血，止血按压近心端 燃烧喷冷水，其他会感染 顺序通行\u003e\r顺序通行 # 常规\u003e\r常规 # 右转让左转，左转让直行 超车从左侧 特殊路段不能超车 有特殊车辆不能超车 不走公交车道 会车时\u003e\r会车时 # 山体外侧先行 环岛内先行 无障碍先行 主路车先行 下坡车先行 校车\u003e\r校车 # 两车道停车等待 三车道变最左道超车 车辆故障\u003e\r车辆故障 # 开危险警报闪光灯 防止警报标志 50 - 100m，高速路150m+ 停车距离\u003e\r停车距离 # 路口5站3，题中带有“路/口”（路口，道口，危险狭窄路段）则50m，带有“站”（车站，加油站）则30m\n灯光\u003e\r灯光 # 雾灯：除了雾天使用，其他都错 危险警报闪光灯：停车，故障，雾天，牵引故障车 左右转向：转弯，变道，停车时打右转向，闸道进道路打左转向 远光灯：照明不足 闪烁：超车，通过路口，通过人行道，急弯道路 其他情况均为近光灯 切换远近灯光距离为150m 速度和距离\u003e\r速度和距离 # 特殊道路\u003e\r特殊道路 # 无标识情况，特殊道路全部为30km/h 普通道路\u003e\r普通道路 # 无线：“城3公4”，有线：“城5公7”\n有中心线：城市50，公路70 无中心线：城市30，公路40 高速行驶能见度\u003e\r高速行驶能见度 # 能见度200m：车速小于60，行车距离100m 能见度100m：车速小于40，行车距离50m 能见度小于50m：车速小于20，尽快离开 高速速度\u003e\r高速速度 # 100km/h：距离100m \u0026lt;100km/h：距离50m 高速限速\u003e\r高速限速 # 有标识优先按标识\n3车道：左11-12，中9-11，右6-9 2车道：左10-12，右6-10 停车\u003e\r停车 # 停车\u003e\r停车 # 单条斜杠：禁止长时间停车 叉：禁止停车 地面标识\u003e\r地面标识 # 路沿上黄线：虚线禁止长时间停车，实线禁止停车 计分\u003e\r计分 # 扣分值仅为3分的幂\n超速\u003e\r超速 # 普通道路\u003e\r普通道路 # 超速20%-50%，扣3分 超速50%+，扣6分 高速公路翻倍\u003e\r高速公路翻倍 # 超速20%-50%，扣6分 超速50%+，口12分 其他\u003e\r其他 # 大型车在高速以外超速10%-20%，扣1分 高速低于最低时速，扣3分 超员\u003e\r超员 # 大型汽车\u003e\r大型汽车 # 超出核定人数20%以下，扣6分 超出核定人数20%以上，扣12分 七座以上载客汽车\u003e\r七座以上载客汽车 # 超出核定人数50%以下，扣6分 超出核定人数50%-100%，扣9分 超出核定人数100%以上，扣12分 其他载客汽车\u003e\r其他载客汽车 # 超出核定人数20%-50%，扣3分 超出核定人数50%-100%，扣6分 超出核定人数100%以上，扣12分 超载\u003e\r超载 # 超载30%以下，扣1分 超载30%-50%以下，扣3分 超载50%以上，扣6分 安全检验\u003e\r安全检验 # 校车，大型车未定期安全检查，扣3分 其他车辆扣1分 道路行驶\u003e\r道路行驶 # 普通道路\u003e\r普通道路 # 不按规定回车，掉头，逆行：3分 不规避行人：3分 不规避校车：3分 借道占道：3分 闯红灯：6分 高速公路\u003e\r高速公路 # 不按规定车道行驶：3分 倒车，逆行：12分 违法停车：9分 占用应急车道：6分 车牌\u003e\r车牌 # 不按规定安装车牌号（并非伪造遮挡）：3分 故意遮挡，伪造车牌号：9分 驾驶证\u003e\r驾驶证 # 驾驶证被暂扣期间驾驶机动车：6分 驾驶车型不符：9分 疲劳驾驶\u003e\r疲劳驾驶 # 载货汽车：6分 载客汽车：9分 其他1分考点\u003e\r其他1分考点 # 违反标线 不按规定使用灯光 未系安全带 载货车长宽高超出规定 擅自改装 其他3分考点\u003e\r其他3分考点 # 接听手机 故障，事故后没有摆放标识和使用灯光 没有对校车安全隐患检查 其他6分考点\u003e\r其他6分考点 # 事故逃逸，无死亡，轻伤 ","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%85%B3%E9%94%AE%E8%AF%8D%E8%AE%B0%E5%BD%95/","section":"Posts","summary":"驾驶证\u003e\r驾驶证 # 常规\u003e\r常规 # 年龄要求： c1,c2: 18+无上限 c6:20-60 货车：20+ 有效期： 6年-\u0026gt;10年-\u0026gt;长期 体检： 中大型公交牵引车每年体检 任何限时题目： 有90日选择90日，否则选择30日 驾驶证周期： 12月 驾驶证实习期： 12月 有效期： 准考证3年内，实习期需要3年驾龄司机陪同，延期审验3年 证件相关：\u003e\r证件相关： # 车“登记”，证随意","title":"科目一关键词记录"},{"content":"","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/%E5%85%B6%E4%BB%96/","section":"Categories","summary":"","title":"其他"},{"content":"","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/c#/","section":"Categories","summary":"","title":"C#"},{"content":"","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/c#%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"C#基础"},{"content":"","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/oop/","section":"Tags","summary":"","title":"OOP"},{"content":"","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"面向对象的编程\u003e\r面向对象的编程 # 概念\u003e\r概念 # 顾名思义面向对象编程即是将真实事物在代码中抽象地表达出来，以现实世界中解决问题的思路来解决程序上的问题。在C#中，事物的类型即为类(class)，类中定义了该事物的数据和操作数据的方法，每个事物对应着一个对象(object)。面向着对象编程即为OOP(Object-Oriented Programing)。\nOOP最大的特点即“面向对象”，整个编程的流程都是围绕着类与对象的。\n举例说明： 以经典的银行存取款例子来讲，假定一个文件中保存着你银行的余额，当你需要编写一个程序对该文件进行操作，提供存取款的功能时，传统面向过程编程的流程应该是：\n打开文件，读取余额并创建一个变量来缓存。 若要存款，则输入金额 在余额变量上加上输入的金额 将余额写入到文件 若要取款，则输入金额 在余额变量上减去输入的金额 将余额写入到文件 面向对象编程的流程应该是：\n定义一个ATM类，拥有余额字段，存款方法，取款方法 完善类方法，存款方法将输入的金额加到余额字段上，然后写入文件。取款方法将余额减去输入的金额，然后写入文件 打开文件，读取余额并创建一个ATM对象，使用余额初始化该对象。 若要存款，则调用ATM对象的存款方法 若要取款，则调用ATM对象的取款方法 OOP的优点：\n面向对象编程所作的流程明显更符合人类实际思考方式，这样能提高代码的可读性，使代码更容易理解和维护。 类与对象的封装增强了代码的复用性，减少重复的工作和开发。 面向对象增强了程序的模块化程度，减少模块之间的耦合性，提高程序灵活性和扩展性。 类的多态性实现了不同对象对同一事件的不同响应，增强了程序的多样性。 面向对象的特征\u003e\r面向对象的特征 # 抽象\u003e\r抽象 # 抽象指将同类对象中提取出共性的特性，然后形成一个类(class)\n在C#中，类与类直接只能单一继承，不能继承多个类。\n下面的代码提供了一个类的示例，将一个姓名属性和更改姓名的方法封装到一个Person类中：\npublic class Person\r{\r//姓名属性\rpublic string Name { get; }\r//方法\rpublic void ChangeName(string name)\r{\rName = name;\r}\r} 在编程时，可以使用该类作为一个Person对象，并可以读取和更改其姓名\n抽象的好处：\n抽象化模拟了现实世界的事物和行为，提高了代码可读性。 增强了代码模块化程度 降低了代码的耦合和复杂度 封装\u003e\r封装 # 封装指隐藏类/对象内部的状态和功能，仅通过一组公共的成员来进行访问\n对类中的成员添加访问修饰符以指定成员的访问级别。\nC#中访问修饰符有四种:\nprivate:私有，只有当前类内部的才能访问\npublic:共有，公开访问，类的内外都可以访问\nprotected:保护，只有继承自该类的类可以访问\ninternal:内部，类的内外都可以访问，但仅限当前程序集\n其中，internal修饰符可以与其他三个叠加使用，如internal public即是在当前程序集中的类内外都可以访问。\n不指定访问修饰符的 下面的代码举出了访问修饰符的例子：\npublic class Person\r{\r//私有修饰符\rprivate string name;\rpublic string GetName()\r{\r//在类的内部可以访问\rreturn name;\r}\r}\rpublic class Program\r{\rstatic void Main(string[] args)\r{\rPerson p = new Person();\rp.name;\r}\r} 使用访问修饰符限制了类中成员的访问级别，实现隐藏成员的效果，达到封装的目的。\n封装的好处:\n类的封装可以保护类内部的数据和代码不被外部访问，提高代码的安全性 封装隐藏了类中方法/属性的实现细节，只向外暴露简单的成员，外部调用时只需要知道该成员是干什么用的，而无需知道如何实现的，简化了操作。 在修改一个类的代码时，不会影响到其他类，除非修改的是公共成员并且该成员被其他类所调用 继承\u003e\r继承 # 根据现有抽象创建新的抽象，说人话就是在原有类的基础上进行拓展，保留原有类的所有能力，在新的一个类上创建新的功能，此操作被称为 “继承”，原有的类被称为 “父类” 或 “基类” ，继承父类的新类被称为 “子类” 或 “派生类” ，子类继承父类的行为被称为 “派生”，可以说 “子类”继承自“父类”，而“父类”派生出“子类”。\n一般，定义复杂且多种类对象时，会把它们共性的特征集成到一个父类中，将它们独有的特征划分到子类。\n下面的代码展示了类的继承关系：\n//基类\rpublic class Person\r{\rpublic string Name { get; }\rpublic void ChangeName(string name)\r{\rName = name;\r}\r}\r//派生类，继承了Person类\rpublic class Employee : Person\r{\rpublic string Company { get; }\rpublic void ChangeCompany(string company)\r{\rCompany = company;\r}\r}\r//派生类，继承了Person类\rpublic class Student : Person\r{\rpublic string School { get; init; }\r}\rpublic class 上述代码的Employee类继承自Person类，Studnet类也继承自了Person类，它们都会继承Person类的Name属性和ChangeName方法，但它们也有自己独有的属性和方法。\nbase关键字\n在子类中使用base关键字可以访问到父类的公开或保护内容\npublic class Employee : Person\r{\r...\rpublic string GetName()\r{\r//使用base关键字访问父类的公开属性\rreturn base.Name;\r}\r//使用base关键字访问父类的构造函数\rpublic Employee() : base()\r{}\r} 继承的好处:\n优化类之间的关系，减少冗余，提高代码的复用性，减少错误的可能。 提供 “多态性” 多态\u003e\r多态 # 多态也是面向对象的核心，它指跨多个抽象以不同方式实现继承属性或方法的能力。多态的实现依赖于继承，所以必须要定义多个类并有继承关系，派生类可以各自对父类的方法实现进行修改，在调用时表现出不同的行为，大大增加编程的灵活度。在使用类时，使用多个派生类实例化出多个对象，对这些对象调用同样的基类方法，但却表现出不同的行为，这便是多态。\n下面是实现多态必要的一些概念：\n抽象类\n将对象或已有的类更加抽象化成为一个新的类，以至于无法具体化（无法创建出该类的对象，因为过于抽象而缺少某些创建类所必要的数据或方法）。这样的类被称为抽象类，在类修饰符class前加上abstract修饰符将定义的类转换为抽象类，抽象类无法被实例化，只能称为其他类的基类。\n抽象类可以有构造函数，但是不能够使用new实例化，构造函数仅供子类使用。 虚方法\n有时将已有类的提取成基类后，会遇到部分子类对与某些方法的实现方式不一致。在类中定义方法时加上virtual关键字，可让子类使用override关键字重写基类方法的实现。\n举一个现实中的例子：在以前，所有轿车都是由燃油驱动的，它们有着“移动”行为，并且该都是以燃油驱动。但随着时代变化，出现了电力驱动的轿车，即使驱动原理不一样了，但它们还是有着“移动”行为。\n从编程方面来看，轿车类Car有着Move方法，该方法是“由燃油驱动的”，但出现了新的类ElectricCar电动车类，它继承自Car类，但是它对Move方法的实现却不一样，它是“电力驱动的”。此时，ElectricCar重写了基类的Move方法，使用自己的方法重新实现了Move方法。\n下面的类定义了一个轿车类，有着用燃油驱动的Move方法：\npublic class Car\r{\r//使用virtual关键字定义虚方法\rpublic virtual void Move()\r{\r//用燃油驱动\r...\r}\r} 有一个类ElectricCar继承了Car类，并重写了父类的Move方法：\npublic class ElectricCar : Car\r{\r//使用override关键字重写父类的虚方法\rpublic override void Move()\r{\r//用电力驱动\r...\r}\r} 此时使用Car类和ElectricCar类分别实例化出对象，调用Move方法，它们表现出的行为将不一致。\n...\rCar c = new Car();\r//燃油驱动\rc.Move();\rElectricCar ec = new ElectricCar();\r//电力驱动\rec.Move();\r... 在类中使用virtual关键字在方法前标注，来声明一个虚方法。 在派生类中使用override关键字对父类中的虚方法进行重写，修改方法的实现过程。 如果不想完全重写虚方法，只是想要在父类的方法基础上添加代码，可以在重写时用base关键字调用父类方法。 抽象方法\n抽象方法类似于虚方法，子类可以重写方法的实现。但是有时子类对方法的实现各不相同，无法统一出一个父类的实现方法，这个方法便被抽象化成为一个抽象方法。\n抽象方法在类的方法前使用abstract关键字定义，抽象方法没有方法体，仅定义了方法名，返回值和参数。在子类同样使用override对父类的抽象方法进行重写。\n定义了抽象方法的类必须为抽象类，因为这个类有方法没有被实现，无法实例化。\n若派生类的基类是带有抽象方法的抽象类，除非该派生类也是一个抽象类，不然就必须重写所有的抽象方法。\n举一个现实中的例子：所有飞机都可以飞行，但若按照动力装置来分类，飞机分为螺旋桨式飞机和喷气式飞机，它们对飞行的实现方式不一致，无法统一出一个飞行的实现。但即便如此，它们都实现了飞行这一行为。\n以编程方面来看，定义一个基类为Plane，并有飞行方法，并有子类JetPlane继承并重写了该方法。\n//带有抽象方法的类必须为抽象类\rpublic abstract class Plane\r{\r//使用abstract关键字声明了一个抽象方法，没有方法体。\rpublic abstract void Fly();\r}\rpublic class JetPlane : Plane\r{\r//使用override关键字重写了父类的抽象方法。\rpublic override void Fly()\r{\r...\r}\r} 抽象方法不需要方法实现，只需要定义名称，参数和返回值即可，但该类的派生类必须提供重写该抽象方法。 抽象方法的访问修饰符不能为private，因为抽象方法需要子类的实现。 若一个类拥有抽象方法，它就必须被修饰为抽象类，因为抽象方法需要一个子类提供实现。 接口\n抽象的极限是只包含方法，类中没有任何数据，只定义了该类的行为，这样抽象到极限的类被称为 “接口”。而继承了该类的类也不叫派生类了，它们被称为 “实现类”，而继承这一操作名也变为了 “实现”，即某类实现了某接口，定义接口的关键字不是class，变为了interface。 接口类似于抽象类，但比抽象类更加抽象，无法定义数据，只能定义行为，而且实现接口的类都必须实现接口中定义的所有成员。\n在C#中，接口只能定义方法，属性，索引器和事件。\n在C#中，类只能继承一个类，但允许实现多个接口，在程序中可以让类实现多个接口，以表现出各类不同的行为。在对类的功能进行拓展时，也可以添加实现的接口来让类实现相应的方法。\n下面的代码展示了接口和实现类的定义：\n//使用interface关键字定义接口\rpublic interface IMoveable\r{\r//定义接口属性\rVector2 Position { get; }\r//定义接口方法，无需方法体\rvoid Move(int x, int y);\r} public class Car : IMoveable\r{\r//实现接口中的属性和方法\rpublic Vector2 Position { get; }\rpublic void Move(int x, int y)\r{\rPosition.x = x;\rPosition.y = y;\r}\r} 接口定义的成员都不需要实现，实现类必须实现接口的所有成员。 接口成员可以不加访问修饰符，默认会赋予public，接口成员的访问修饰符不能为private，因为私有的接口方法没有意义。 新版本特性\n在高版本的C#，接口中的方法可以有方法体，接口中也可以定义静态抽象成员和虚拟成员，具体参考官方文档：\r接口\n利用继承和重写，让不同派生类对象在同样的调用方式下表现出不同的行为，表现出了对象的多态性，允许程序员更加灵活的方式组件模块，编写代码。 多态性的好处：\n增强了代码的通用性和简洁性，因为多态允许不同的对象执行相同的操作，但调用的方法却是同一个，这意味着程序员不需要写多个专门针对不同对象类型的方法。 增强了代码的可扩展性，当在一个较为完整的程序中添加新的对象类型，只需要选择要继承的类，实现需要的接口即可，不需要花费大量的事件思考类中有哪些成员。 面向对象七大原则\u003e\r面向对象七大原则 # 开闭原则 单一原则 接口隔离原则 里氏替换原则 依赖倒置原则 迪米特法则 聚合复用原则 参考内容\nStephen Prata. C++ Primer Plus.\nC#面向对象 https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/oop C#接口 https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface\nC#默认接口方法 https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods\nC#面向对象（三）：多态 https://www.cnblogs.com/qixinbo/p/8244583.html 面向对象大原则 https://zhuanlan.zhihu.com/p/89833731\n","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B-csharp/","section":"Posts","summary":"面向对象的编程\u003e\r面向对象的编程 # 概念\u003e\r概念 # 顾名思义面向对象编程即是将真实事物在代码中抽象地表达出来，以现实世界中解决问题的思路来解决程序上的问题。在C#中，事物的类型即为类(class)，类中定义了该事物的数据和操作数据的方法，每个事物对应着一个对象(object)。面向着对象编程即为OOP(Object-Oriented Programing)。","title":"面向对象的编程（C#）"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/.net/","section":"Categories","summary":"","title":".NET"},{"content":".NET 表达式树\u003e\r.NET 表达式树 # https://zhuanlan.zhihu.com/p/247937380 https://cloud.tencent.com/developer/article/1817790\n.NET Expression表达式树将代码抽象成了一颗对象树，树上的每一个节点都是一个代码表达式，它的构造类似编译原理中的抽象语法树（AST）。\n可以使用lambda表达式进行声明表达式树，编译器将会自动转换，但是该lambda表达式不能是语句（即表达式只能有一句，不能用{}组成多句）。\n表达式树可以转换为委托，在一些linq场景可以通过构建表达式树来动态拼接一些linq查询条件。\n表达式树入门\u003e\r表达式树入门 # 一个表达式树是类似以下的结构\n表达式C | +-----+-----+ | | 表达式A 表达式B 比如简单的lambda表达式x =\u0026gt; x + 1可以用转化为以下表达式\nx + 1 | +---+---+ | | x 1 其中叶子节点x为变量表达式，叶子节点1为常量表达式，x+1节点为二叉表达式，使用了+运算符\n在C#中，表达式树可以通过Expression及其派生类的各种方法手动构建，Exression类常用的静态方法如下：\nExpression.Constant() 创建一个常量表达式。 Expression.Variable() 创建一个变量表达式。 Expression.New() 创建一个实例化表达式。 Expression.Assaign() 创建一个赋值表达式。 Expression.Equal() 创建一个相等比较表达式。 Expression.Call() 创建一个方法调用表达式。 Expression.Condition() 创建一个分支逻辑表达式。 Expression.Loop() 创建一个循环逻辑表达式。 Expression.Add()/Subtract()/Multiply()/Divide() 加/减/乘/除表达式\n\u0026hellip; 使用C#代码构造简单的表达式树\u003e\r使用C#代码构造简单的表达式树 # x =\u0026gt; x + 1\npublic static void Example1() { var param1 = Expression.Variable(typeof(int), \u0026#34;x\u0026#34;);//声明变量表达式，类型为int，参数名为\u0026#34;x\u0026#34; var const1 = Expression.Constant(1);//常量表达式 var biExpr = Expression.Add(param1, const1);//声明进行加法运算的二叉表达式，左节点为x,右节点为1 //x =\u0026gt; x + 1表达式树就构成了 //使用Expression.Lambda方法可以将表达式树转换为lambda表达式树，在类型参数中可以指定转换的委托类型 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;int, int\u0026gt;\u0026gt;(biExpr, param1);//lambda输入参数为x变量 //使用LambdaExpression.Compile方法将转换好的lambda表达式树编译成委托 Func\u0026lt;int,int\u0026gt; func = lambdaExpr.Compile(); //调用编译出的委托 Console.WriteLine(func(5)); } 更复杂一些的表达式树\u003e\r更复杂一些的表达式树 # (a,b,c) =\u0026gt; (a + b + c) / 3\npublic static void Example2() { var param1 = Expression.Variable(typeof(int), \u0026#34;a\u0026#34;); var param2 = Expression.Variable(typeof(int), \u0026#34;b\u0026#34;); var param3 = Expression.Variable(typeof(int), \u0026#34;c\u0026#34;); var const1 = Expression.Constant(3.0f,typeof(float)); var biExpr1 = Expression.Add(param1, param2);//构造参数1，2，生成加法表达式树1 var biExpr2 = Expression.Add(biExpr1, param3);//构造加法表达式树1和参数3，生成加法表达式树2 var biExpr3 = Expression.Convert(biExpr2, typeof(float));//两整形相除不会保留小数，转化为浮点型 var biExpr4 = Expression.Divide(biExpr3, const1);//构造加法表达式树2和常量表达式1，生成除法表达式树3 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;int,int,int,float\u0026gt;\u0026gt;(biExpr4, param1,param2,param3);//根据表达式树3和三个参数，将表达式树转换为lambda表达式树 var func = lambdaExpr.Compile(); Console.WriteLine(func(2, 3, 3)); } 方法调用表达式\u003e\r方法调用表达式 # (str,value) =\u0026gt; !str.IsNullOrWhiteSpace(str) \u0026amp;\u0026amp; str.Contains(value)\npublic static void Example3() { var param1 = Expression.Variable(typeof(string), \u0026#34;str\u0026#34;); var param2 = Expression.Variable(typeof(string), \u0026#34;value\u0026#34;); //使用反射获取静态方法，并与参数表达式构造成方法调用表达式 var callExpr1 = Expression.Not(Expression.Call(typeof(string).GetMethod(nameof(string.IsNullOrWhiteSpace), new Type[]{typeof(string)})!, param2)); //使用反射获取实例方法，实例方法需要指定调用实例的表达式 var callExpr2 = Expression.Call(param1, typeof(string).GetMethod(nameof(string.Contains), new[] {typeof(string)} )!, param2); var biExpr1 = Expression.AndAlso(callExpr1, callExpr2);//与运算 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;string,string,bool\u0026gt;\u0026gt;(biExpr1, param1,param2); var func = lambdaExpr.Compile(); Console.WriteLine(func(\u0026#34;Azusa\u0026#34;, \u0026#34;s\u0026#34;)); } 未完待续。。。\n","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/net-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E5%85%A5%E9%97%A8/","section":"Posts","summary":".NET 表达式树\u003e\r.","title":".NET 表达式树入门"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/linq/","section":"Tags","summary":"","title":"Linq"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/asp-.net-core/","section":"Tags","summary":"","title":"ASP .NET Core"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/swagger/","section":"Tags","summary":"","title":"Swagger"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/web-api/","section":"Tags","summary":"","title":"Web API"},{"content":"Swagger文档\u003e\rSwagger文档 # 在ASP .NET Core项目中配置Swagger服务，在Swagger页面的接口中显示C#代码的注释。\nSwagger上的注释\r微软官方文档\n先决条件： 项目需要在Nuget中安装Swashbuckle.AspNetCore包（Visual Studio中一般会在ASP .NET Core项目中自动安装）\n生成并导出XML文档\u003e\r生成并导出XML文档 # 首先需要生成项目的XML文档。以 Visual Studio 为例，在项目属性-输出中勾选“生成包含API文档的文件”，并指定输出目录：\nVS中生成XML文档\r接着生成项目，会在指定目录下输出XML文档：\n输出的XML文档\r配置Swagger服务\u003e\r配置Swagger服务 # 在ASP .NET Core入口函数中配置服务\nprogram.cs\r//安装Nuget包后即可使用AddSwaggerGen方法添加Swagger服务\rservices.AddSwaggerGen(options =\u0026gt;\r{\r//定义Swagger文档，可多次定义以区分版本\r//此时定义的文档名为v1\roptions.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo()\r{\r//添加一些API信息，将会呈现在Swagger页面上\rVersion = \u0026#34;v1\u0026#34;,\rTitle = \u0026#34;用户信息控制器\u0026#34;,\r});\r//指定XML文档的目录\roptions.IncludeXmlComments($\u0026#34;{Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}\\\\{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;, true);\r...\r}); 配置Swagger中间件\u003e\r配置Swagger中间件 # 在ASP .NET Core入口函数中配置中间件\nprogram.cs ...\rvar app = builder.Build();\r//此时在开发环境下才会添加Swagger中间件\rif (app.Environment.IsDevelopment())\r{\r//添加Swagger中间件\rapp.UseSwagger();\r//添加SwaggerUI中间件，在参数中指定Swagger终结点，终结点错误将会导致接口无法正常显示\r//此时使用终结点是步骤2中声明的名为\u0026#34;v1\u0026#34;文档，如果定义了多个文档版本，则需要指定多个终结点\rapp.UseSwaggerUI(c =\u0026gt; c.SwaggerEndpoint(\u0026#34;/swagger/v1/swagger.json\u0026#34;, \u0026#34;Gehenna.WebAPI v1\u0026#34;));\r} 如果使用目录及 IIS 或反向代理，请使用 ./ 前缀将 Swagger 终结点设置为相对路径。 例如 ./swagger/v1/swagger.json。\n使用 /swagger/v1/swagger.json 指示应用在 URL 的真实根目录中查找 JSON 文件（如果使用，加上路由前缀）。例如，请使用 https://localhost:\u0026lt;port\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/v1/swagger.json 而不是 https://localhost:\u0026lt;port\u0026gt;/\u0026lt;virtual_directory\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/v1/swagger.json。\n配置完成\u003e\r配置完成 # 在API控制器类或终结点方法上添加XML注释。\n给控制器上添加注释\r给控制器操作方法添加注释\r配置完成后，访问https://localhost:\u0026lt;port\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/index.html页面上即可进入Swagger界面。\n页面的标题文字将显示配置Swagger服务时提供的数据。\nSwagger页面标题\r页面右上方的下拉框可以选择在步骤2/3中定义的Swagger的版本\nSwagger版本\r页面中将会显示控制器，API终结点方法的注释 接口注释\r如果给方法参数添加了注释，Swagger也会显示出来 方法参数的注释\r如果请求/响应的数据模型有添加注释，点击scheme显示 请求/响应模型注释\r在使用泛型作为API响应数据模型时显示注释\u003e\r在使用泛型作为API响应数据模型时显示注释 # //待补充\n参考文章：https://learn.microsoft.com/zh-cn/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-7.0\u0026amp;tabs=visual-studio\n","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%9C%A8asp-.net-core%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEswagger%E6%96%87%E6%A1%A3/","section":"Posts","summary":"Swagger文档\u003e\rSwagger文档 # 在ASP .","title":"在ASP .NET Core项目配置Swagger文档"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/javascript/","section":"Tags","summary":"","title":"Javascript"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/signalr/","section":"Tags","summary":"","title":"SignalR"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/websocket/","section":"Tags","summary":"","title":"Websocket"},{"content":"在使用SignalR向.NET后端进行实时通信时，时常会使用 AccessToken 进行用户授权。提供用户认证可以提高后端接口的安全性，并且可以利用SignalR的用户认证机制来向指定用户的所有SignalR连接发送消息。\n后端用户授权服务\u003e\r后端用户授权服务 # 在 ASP.NET Core 中添加授权机制：\u003e\r在 ASP.NET Core 中添加授权机制： # Program.cs ... services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //此处使用JWTBearer进行授权验证 .AddJwtBearer(options =\u0026gt; { var secretKey = configurations.GetRequiredSection(\u0026#34;Jwt\u0026#34;).Get\u0026lt;JwtOption\u0026gt;().SecretKey??throw new ConfigurationErrorsException(\u0026#34;Jwt密钥未配置\u0026#34;); options.TokenValidationParameters = new() { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)), }; }); ... //添加认证机制需要引用Authentication与Authorization两个中间件 app.UseAuthentication(); app.UseAuthorization(); ... 在SignalR集线器类上添加Authorize特性\u003e\r在SignalR集线器类上添加Authorize特性 # 详细的授权信息与不同的授权规则参考\rASP.NET Core授权\n//添加授权 [Authorize] public class ChatHub : Hub { public override async Task OnConnectedAsync() { await base.OnConnectedAsync(); //在Hub类的Context.User属性中可以获取到SignalR通过websocket握手获取到的用户授权信息 await Console.Out.WriteLineAsync(Context.User.Identity.Name); } ... } 这样就为ASP .NET Core提供了基本的用户授权机制，在应用的终结点(endPoints)上添加[Autorize]特性来对此终结点进行用户授权。\n在客户端配置SignalR连接的访问令牌\u003e\r在客户端配置SignalR连接的访问令牌 # C#客户端\u003e\rC#客户端 # ... _connection = new HubConnectionBuilder() .WithAutomaticReconnect() //在WithUrl方法的configureHttpConnection参数中配置 .WithUrl(HubUrl, options =\u0026gt; { //为AccessTokenProvider提供获取访问令牌的委托 //此处为应当查找并获取用户访问令牌的逻辑 options.AccessTokenProvider = () =\u0026gt; Task.FromResult(authorizationToken); }); .ConfigureLogging(builder =\u0026gt; builder.AddConsole()) .Build(); await _connection.StartAsync(); ... Javascript客户端\u003e\rJavascript客户端 # ... this.hubConnection = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;this.hubUrl\u0026#34;,{ //为withUrl方法参数2的accessTokenFactory属性提供获取访问令牌的方法 accessTokenFactory: () =\u0026gt; this.getAccessToken(), skipNegotiation: true, transport: signalR.HttpTransportType.WebSockets }) .build(); await this.hubConnection.start(); ... 踩坑注意\u003e\r踩坑注意 # 在Javascript客户端，即使配置了访问令牌，在对后端SignalR集线器进行访问时服务器仍然会响应 401 Unauthorized 或是客户端抛出 SignalR Error: Failed to complete negotiation with the server 异常，若排除了Javascript客户端配置问题或是CORS跨域访问问题，则有可能是因为Javascript websocket API不支持设置请求报文头的原因。\n客户端使用HTTP协议向服务器进行访问令牌验证常用的方式是在报文头中添加 Authorization 标头，并提供访问令牌字符串。 请求标头中的Authorization项\r在SignalR进行Websocket连接前会进行协商(negotiation)，若客户端在建立SignalR连接时配置了访问令牌，则会在请求时附带上访问令牌。\n但在SignalR Javascript客户端进行协商时，访问令牌并不是添加在报文头中，而是以查询字符串的形式发送请求。 访问令牌放在了查询字符串中\rASP.NET Core并不会自动对查询字符串中的访问令牌进行授权，所以此时服务器将会返回 401 Unauthorized ，而Javascript客户端会抛出 SignalR Error: Failed to complete negotiation with the server (无法完成与服务器的协商） 异常。\n解决方法：\u003e\r解决方法： # 在服务器端配置授权机制，在收到请求消息时手动进行授权处理。配置的方式有多种，较为简单的方式是直接在Authorization服务中添加事件：\nprogram.cs ... services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //使用JwtBearer作为认证令牌 .AddJwtBearer(options =\u0026gt; { var secretKey = configurations.GetRequiredSection(\u0026#34;Jwt\u0026#34;).Get\u0026lt;JwtOption\u0026gt;().SecretKey??throw new ConfigurationErrorsException(\u0026#34;Jwt密钥未配置\u0026#34;); options.TokenValidationParameters = new() { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)), }; //添加授权事件，在收到请求消息时进行处理 options.Events = new JwtBearerEvents() { OnMessageReceived = context =\u0026gt; { //从请求查询字符串中取出访问令牌 var accessToken = context.Request.Query[\u0026#34;access_token\u0026#34;]; //请求条件不符合则返回 if (!string.IsNullOrEmpty(accessToken) \u0026amp;\u0026amp; context.Request.Headers[\u0026#34;Upgrade\u0026#34;] == \u0026#34;websocket\u0026#34;) { //手动对上下文中的令牌属性赋值，剩下的授权由.NET自动完成 context.Token = accessToken; } return Task.CompletedTask; } }; }); ... 参考文章\nhttps://stackoverflow.com/questions/21260384/signalr-authenticating-with-access-token#comment32085907_21260384\n","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E4%B8%BAsignalr%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/","section":"Posts","summary":"在使用SignalR向.NET后端进行实时通信时，时常会使用 AccessToken 进行用户授权。提供用户认证可以提高后端接口的安全性，并且可以利用SignalR的用户认证机制来向指定用户的所有SignalR连接发送消息。","title":"为SignalR的连接配置用户认证"},{"content":"测试帖子\u003e\r测试帖子 # 使用Hugo超快速建站\nHugo首页\nhugo new site Azusa\u0026rsquo;s Archive\n","date":"2023年3月10日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/hellow-world/hello-world/","section":"Posts","summary":"测试帖子\u003e\r测试帖子 # 使用Hugo超快速建站","title":"Hello World"},{"content":"","date":"0001年1月 1日","permalink":"/Hugo-Blog-Blowfish-Theme/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001年1月 1日","permalink":"/Hugo-Blog-Blowfish-Theme/series/","section":"Series","summary":"","title":"Series"}]