[{"content":"","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"\r","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/","section":"Index","summary":"","title":"Index"},{"content":"","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/series/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/","section":"Series","summary":"","title":"复习 计算机图形学基础"},{"content":"\r二维几何变换 # 向量矩阵 # 基本几何变换都是相对于坐标原点和坐标轴进行的几何变换。\n在计算机中，若要对整个图形进行几何变换，只需要将该图形的所有顶点进行相同的几何变换即可。\n一般使用一个向量矩阵来存储图形的一个顶点，如： \\( P = \\begin{bmatrix} x \\\\ y \\end{bmatrix} \\)\n通过对图形每个顶点的向量矩阵进行各种计算，即可对该图形进行几何变换\n平移变换 # 对一个图形进行平移，只需对其顶点的向量矩阵加上各个轴的偏移量即可： 2D平移变换\r$$ P\u0026rsquo; = P + T \\\\ P = \\begin{bmatrix} x \\\\ y \\end{bmatrix} \\ \\ \\ T = \\begin{bmatrix} t_x \\\\ t_y \\end{bmatrix} \\\\ P\u0026rsquo; = \\begin{bmatrix} x+t_x \\\\ y+t_x \\end{bmatrix}= \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix} $$\n旋转变换 # 绕坐标原点的旋转变换 设旋转角度为 θ 旋转变换\r$$ P\u0026rsquo; = RP \\\\ R = \\begin{bmatrix} cos θ \u0026amp; -sin θ\\\\ sin θ \u0026amp; cos θ \\end{bmatrix} \\ \\ \\ P = \\begin{bmatrix} x \\\\ y \\end{bmatrix} \\\\ P\u0026rsquo; = \\begin{bmatrix} cos θ \u0026amp; -sin θ\\\\ sin θ \u0026amp; cos θ \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix}= \\begin{bmatrix} xcosθ-ysinθ \\\\ xsinθ+ycosθ \\end{bmatrix} $$\n如果某个顶点 \\(P_0(X_0,0_Y)\\) 要绕某个特定点 \\(P_r(X_r,Y_r)\\) 旋转θ度，只需要将该点设为原点，接着计算 \\(P_0\\) 点对 \\(P_r\\) 点的相对坐标 \\(P_t(X_t,Y_t)\\) ，使用 \\(P_t\\) 点进行绕坐标原点的旋转变换得出目标点 \\(P_1(X_1,Y_1)\\)，然后以该 \\(P_1\\) 点作为偏移量对 \\(P_0\\) 点进行平移变换即可。\n缩放变换 # 以坐标原点为基准点的缩放变换 设缩放率为 \\(S_x, S_y\\) 缩放变换\r$$ P\u0026rsquo; = SP \\\\ P = \\begin{bmatrix} x \\\\ y \\end{bmatrix} \\ \\ \\ S = \\begin{bmatrix} S_x \u0026amp; 0 \\\\ 0 \u0026amp; S_y \\end{bmatrix} \\\\ P\u0026rsquo; = \\begin{bmatrix} S_x \u0026amp; 0 \\\\ 0 \u0026amp; S_y \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} \\begin{bmatrix} S_x \\centerdot x \\\\ S_y \\centerdot y \\end{bmatrix} $$\n注意：\n这样的缩放变换以坐标原点为放缩参照点\n它不仅改变了物体的大小和形状，也改变了它离原点的距离\n对称变换 # 关于X轴的对称变换 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}= \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \\end{bmatrix}= \\begin{bmatrix} x \\\\ -y \\end{bmatrix} $$\n关于Y轴的对称变换 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}= \\begin{bmatrix} -1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix}= \\begin{bmatrix} x \\\\ -y \\end{bmatrix} $$\n关于对角线y=x对称变换 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}= \\begin{bmatrix} 0 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix}= \\begin{bmatrix} x \\\\ -y \\end{bmatrix} $$\n关于对角线y=-x对称变换 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}= \\begin{bmatrix} 0 \u0026amp; -1 \\\\ -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix}= \\begin{bmatrix} x \\\\ -y \\end{bmatrix} $$\n关于原点对称 # 即先对对角线y=x对称，再对对角线y=-x对称 $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}= \\begin{bmatrix} 0 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -1 \\\\ -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix}= \\begin{bmatrix} -1 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix}= \\begin{bmatrix} x \\\\ -y \\end{bmatrix} $$\n齐次坐标 # 根据上面的二维几何变换，可以得出，每个基本变换（平移、旋转、缩放等）都可以表示为下列形式： $$ P\u0026rsquo; = M_1P+M_2 $$ 其中P\u0026rsquo;和P表示为坐标的向量矩阵，\\(M_1\\) 是一个包含乘法系数的 2*2 的矩阵， \\(M_2\\) 是包含加法系数的 2*1 的矩阵。\n对于平移变换， \\(M_1\\) 是一个单位矩阵，只需要对 \\(M_2\\) 进行加法运算即可。 对于旋转，缩放或是对称变换，对 \\(M_1\\) 进行乘法运算。 如果要对图形进行复合变换，必须一步一步地计算图形顶点的向量矩阵的每一次变换。并且为了防止图形产生畸变，还要遵守\r“先缩放，再旋转，后平移”的原则。\n因此，更有效的方法是将不同类型的变换组合，从而直接从初始坐标得到最后的坐标位置，消除中间坐标值的计算，因此引入了齐次坐标。\n齐次坐标就是由 n+1 维向量表示一个 n 维向量。如果是2维几何变换，那就是用一个 3*3 的矩阵来表示原本 2*2 的矩阵。然后将所有的变换公式表达为矩阵乘法。\n将一个顶点的向量矩阵转换为齐次矩阵： $$ P = \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} $$ 其中第三个值 1 称为哑坐标，决定了坐标的缩放比，一个点的齐次坐标是不唯一的，例如，普通坐标系下的点 (2,3) 变换为齐次坐标可以是 (2,3,1)、(1,1.5,0.5)、(4,6,2) 等。如果坐标是无穷大，哑坐标可以表示为0。\n然后，利用齐次坐标，可以得到二维图形变换矩阵的通式： 齐次坐标\r由上图所示，将比例、反射、旋转和错切变换整合到 a,b,c,d 四个值中，将平移变换整合到 m,n 中，将投影变换转换到 p,q 中，将缩放变换转换到哑坐标 s 中。\n如果要对一个顶点进行几何变换，将该通式 T 与顶点的齐次坐标相乘即可： $$ \\begin{split} P\u0026rsquo; \u0026amp;= TP \\\\ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ H \\end{bmatrix}\u0026amp;= \\begin{bmatrix} a \u0026amp; c \u0026amp; m \\\\ b \u0026amp; d \u0026amp; n \\\\ p \u0026amp; q \u0026amp; s \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} \\end{split} $$\n使用齐次坐标的二维几何变换 # 平移变换 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; t_x \\\\ 0 \u0026amp; 1 \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} $$\n旋转变换 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} cosθ \u0026amp; -sinθ \u0026amp; 0 \\\\ sinθ \u0026amp; cosθ \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} $$\n缩放变换 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; s \\end{bmatrix} \\begin{bmatrix} x/s \\\\ y/s \\\\ 1 \\end{bmatrix} $$\n对称变换 # 关于x轴对称 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} $$\n关于y轴对称 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} $$\n关于对角线y=x的对称 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} $$\n关于对角线y=-x的对称 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0 \\\\ -1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} $$\n关于原点的对称 # $$ \\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} $$\n","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%9B%9B%E7%AB%A0/","section":"Posts","summary":"","title":"复习 计算机图形学基础 第四章"},{"content":"","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/","section":"Tags","summary":"","title":"计算机图形学"},{"content":"","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","section":"Categories","summary":"","title":"期末复习"},{"content":"\r直线裁剪 # 使用一个矩形窗口，对直线进行裁剪，保留矩形框内的直线段，移除矩形框外的。\nCohen-Sutherland裁剪算法 # 该算法的主要思想为：对于每条线段，分为3种情况处理：\n线段完全在窗口内，则不进行裁剪，称为“取” 线段完全在窗口外，则丢弃整条线段，称为“弃” 如果线段部分在窗口内而部分在窗口外，则将线段分割，窗口外的弃，窗口内的取 Cohen-Sutherland使用编码空间划分的方法快速确定直线与矩形窗口的位置关系，避免了频繁地对直线和矩形框取交点。如下图所示，将矩形窗口外的八个方向以及窗口内共9个区域使用一串区域编码来表示：\n区域编码\renum Code { INSIDE = 0, LEFT = 1, RIGHT = 2, BOTTOM = 4, TOP = 8, }; Code Encode(Vector2f\u0026amp; point, Rect\u0026amp; rect) { int c = INSIDE; if (point.x \u0026lt; rect.x_left) c = c | LEFT; else if (point.y \u0026gt; rect.x_right) c = c | RIGHT; if (point.y \u0026lt; rect.y_bottom) c = c | BOTTOM; else if (point.y \u0026gt; rect.y_top) c = c | TOP; return static_cast\u0026lt;Code\u0026gt;(c); } 区域编码示例\r对一条直线的两个端点进行区域编码，判断直线与矩形窗口的位置关系：\n如果两个端点的编码均为 0000，则代表整条线段都在矩形框内，取之。（比如图中的直线AB） 如果两个端点的编码的逻辑与不为0000，则这条线段完全在矩形框外，弃之。（比如图中的直线CD：0101 \u0026amp; 0100 = 0100） 然而上一步并不能去除所有的完全在矩形框外的直线（比如图中的KL），此时需要对剩余的直线进行可见性判定： 求出直线与矩形框的所有交点 如果没有交点，说明直线完全在矩形框外，弃之（如图中的KL） 判断交点个数： 如果有一个交点，说明直线一端在矩形框外，另一端在矩形框内（如图中的EF），此时，取交点以及直线位于矩形框内的端点成新的直线 如果有两个交点，说明直线两端都在矩形框外，线段贯穿矩形框（如图中的GH），此时，取两个交点为新的直线 Line Cohen_Sutherland(const Line\u0026amp; line, Rect\u0026amp; rect) { auto code1 = Encode(*line.begin, rect); auto code2 = Encode(*line.end, rect); auto result = line; //线段在切割范围外，返回空 if ((code1 \u0026amp; code2) != INSIDE) return {nullptr, nullptr}; //若两点均在切割范围内，则返回整条线段 while (code1 != INSIDE || code2 != INSIDE) { //端点在切割范围外 if ((code1 \u0026amp; code2) != INSIDE) break; //选取非范围内端点 auto code = code1 == INSIDE ? code2 : code1; auto p = new Vector2f(); //线段与左边缘相交 if ((code \u0026amp; LEFT) != INSIDE) { p-\u0026gt;x = rect.x_left; p-\u0026gt;y = line.begin-\u0026gt;y + (line.end-\u0026gt;y - line.begin-\u0026gt;y) * (rect.x_left - line.begin-\u0026gt;x) / (line.end-\u0026gt;x - line. begin-\u0026gt;x); //求交点 } //右边缘相交 else if ((code \u0026amp; RIGHT) != INSIDE) { p-\u0026gt;x = rect.x_right; p-\u0026gt;y = line.begin-\u0026gt;y + (line.end-\u0026gt;y - line.begin-\u0026gt;y) * (rect.x_right - line.begin-\u0026gt;x) / (line.end-\u0026gt;x - line. begin-\u0026gt;x); } //下边缘相交 else if ((code \u0026amp; BOTTOM) != 0) { p-\u0026gt;y = rect.y_bottom; p-\u0026gt;x = line.begin-\u0026gt;x + (line.end-\u0026gt;x - line.begin-\u0026gt;x) * (rect.y_bottom - line.begin-\u0026gt;y) / (line.end-\u0026gt;y - line .begin-\u0026gt;y); } //上边缘相交 else { p-\u0026gt;y = rect.y_top; p-\u0026gt;x = line.begin-\u0026gt;x + (line.end-\u0026gt;x - line.begin-\u0026gt;x) * (rect.y_top - line.begin-\u0026gt;y) / (line.end-\u0026gt;y - line. begin-\u0026gt;y); } //选取的为begin if (code == code1) { result.begin = p; //重新计算端点编码 code1 = Encode(*p, rect); } else { result.end = p; code2 = Encode(*p, rect); } } return result; } Liang-Barsky算法 # TODO # ","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0--5.-%E5%9B%BE%E5%83%8F%E8%A3%81%E5%89%AA/","section":"Posts","summary":"","title":"复习 计算机图形学基础 第三章 -- 5. 图像裁剪"},{"content":"反走样即抗锯齿，消除倾斜直线光栅化后的锯齿状效果。\n常用的反走样技术有三种：\n提高分辨率 简单区域采样 甲醛区域采样 简单区域采样 # 简单区域采样\r每个像素是一个具有一定面积的小区域，将直线段看作具有一定宽度的狭长矩形\n当矩形（直线段）与像素相交时，求出两者相交区域的面积，然后根据相交区域面积或距离的大小确定该像素的亮度值\n计算亮度值\r每个像素面积为单位面积,即为1\n相交区域面积是介于0、1之间的实数\n用它乘以像素的亮度值，即可得到该像素实际显示的亮度值\n如果背景和线条都是RGB有色图而非灰度图，那么可以对每个颜色分量使用以下公式来计算其值，\n其中targetColor为目标颜色分量值，foregroundColor为直线颜色，backgroundColor为背景颜色，f为直线（矩形框）与该像素相交的面积\n$$ targetColor = foregroundColor \\times f + (1-f) \\times backgroundColor $$\n","date":"2023年6月17日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0--4.-%E5%8F%8D%E8%B5%B0%E6%A0%B7/","section":"Posts","summary":"","title":"复习 计算机图形学基础 第三章 -- 4. 反走样"},{"content":"\r多边形填充算法 # 多边形扫描转换算法 # 概述 # 扫描线算法是确定水平扫描线与多边形的相交区间，把该区间内的所有像素一次性赋以新的颜色值。\n算法分为4个步骤：\n求交：计算扫描线与多边形所有边的交点 排序：按x轴排序所有交点 交点配对：每对交点代表扫描线与多边形的一个相交区域 区间填色：根据相交区域填色 以X轴为扫描线轴使用多边形扫描转换算法的步骤：\nX扫描线填充算法\r求角：扫描线 y=6 与多边形的边界交于 A,B,C,D 点，得到交点为 (2,6),(4,6),(8,6),(11,6) 排序：按照交点的x值排序，2-\u0026gt;4-\u0026gt;8-\u0026gt;11 配对：每两个交点表示了多边形的一块区域，此时有两块区域，[(2,6),(4,6)]和[(8,6),(11,6)] 把每个区域中的像素填充 按照上面的步骤，在Y轴上遍历扫描线，直到整个图形被填充\n具体算法实现步骤 # 构造边表（ET）\n构造一个列表，该列表称为边表，长度为该多边形的扫描线的数量（即多边形在y轴上的跨度），表中的每一个元素都是一个链表，代表着每一条扫描线（方程\\(y=n\\，n为扫描线所在y轴上的位置)，每条扫描线称为桶 将多边形中每条边的信息链入与该边最小y坐标(\\(y_{low}\\))相对应的桶中。也就是说，若某边的较低端点为(x,\\(y_{low}\\))，则该边就放在 \\(y=y_{low}\\) 这条扫描线对应的桶中 每条边的数据为链表的一个节点，内容包含三个值： 该边和对应扫描的初始交点（即较低端点）的x值 \\(x_{low}\\) 该边最大y坐标（即较高端点）的y值 \\(y_{high}\\) 该边的斜率的倒数 \\(\\frac{1}{k}\\) 同一个桶中的节点按照 \\(x_{low}\\) 从小到大排序，如果 \\(x_{low}\\) 相等，则按照 \\(\\frac 1 k\\)来排序 下面的例子构造了一个边表：\n多边形示例\r边 \\(y_{low}\\) \\(x_{low}\\) \\(y_{high}\\) \\(\\frac 1 k\\) p0p1 8 7 12 -1 p1p2 7 1 12 2/5 p2p3 1 3 7 -1/3 p3p4 1 3 5 3/4 p4p5 1 8 5 -1/2 p5p6 1 8 9 1/2 p6p0 8 7 9 5 最终构造的边表\r构造活动边表（AET） 根据构造的边表（ET），进行扫描转换。对于不同的扫描线，与其相交的边线也是不同的，当对某一条扫描线进行扫描转换时，我们只需要考虑与它相交的那些边线\n因此，需要建立一个只与当前扫描线相交的边记录链表，称之为活动边表（AET）\n构造一个链表，作为活动边表 按照y轴遍历每条扫描线，取出该扫描线在边表中对应的桶，放入活动边表，同时在边表中删除该桶，然后将活动边表中的每个节点按照 \\(x_{low}\\) 排序 如果桶中节点的 \\(y_{max}\\) 值小于或等于当前扫描线的y值，那么移除该节点 在当前活动边表中，取两两节点的 \\(x_{low}\\) 值，作为该扫描线的填充区域并填充多边形 将桶中每个节点的 \\(x_{min}\\) 值加上其 \\(\\frac 1 k\\)的值 重复2-5，遍历下一条扫描线，直到边表和活动边表都为空 对上述的多边形构造活动边表并填充：\n从 y=1 开始遍历扫描线，将边表中下标为1的桶加入活动边表并排序，取两两节点进行填充，最终填充范围是3-3和8-8：\r活动边表y=1\r将活动边表中所有节点的\\(x_{low}\\)加上\\(\\frac 1 k\\)的值。然后切换到下一条扫描线 y=2，边表中对应的桶为空，对AET排序并继续填充，此时填充范围为 3-4和8-9（如果\\(x_{low}\\)有小数则四舍五入）：\r活动边表y=2\r与上一步操作相同，此时扫描线 y=3 的填充范围为 2-5和7-9：\r活动边表y=3\ry=4，填充范围为 2-5和7-10：\r活动边表y=4\ry=5，此时要AET中的边 p2p4和p4p5 的 \\(y_{max}\\) 值等于扫描线的 y 值，将这两个节点移除。然后排序，继续填充，范围为 2-10：\r活动边表y=5\ry=6，填充范围 1-11：\r活动边表y=6\ry=7，AET中的 p2p3 节点的 \\(y_{max}\\) 等于7，将其移除，加入ET中的 p2p1 节点然后排序，计算填充范围 1-11：\r活动边表y=7\ry=8，加入ET中的 p0p1和p0p6 节点，排序，然后计算填充范围为：1-7和7-12：\r活动边表y=8\ry=9，移除AET中的 p0p6和p5p6 节点，排序，然后计算填充范围：2-6：\r活动边表y=9\r不断填充，最后在 扫描线 y=12时，AET和ET中的节点全部被移除，填充完毕：\r活动边表y=10-12\r填充完毕\r种子填充算法 # 在填充图像区域的内部找到一个像素（种子点）的基础上，通过邻近搜索向外扩散式填充。\n种子填充算法分为4连通和8连通方式，即进行邻近搜索时搜索 \u0026ldquo;上下左右\u0026quot;四个像素（四联通）或是\u0026quot;上下左右左上右上左下右下\u0026quot;八个像素，八联通算法相对于四连通跨越性更强（因为可以扫描对角方向）。\n种子填充算法\r基于堆栈而非递归的4连通种子填充算法实现步骤：\n初始化栈，并将种子点入栈 将栈顶点出栈 填充该点 检查上、下、左、右方的四个像素，如果像素不是边界点，且其颜色未被填充为目标颜色，则将其入栈 循环执行前三步，直到栈空 void FloodFill4(Vector2 startPoint, const GLubyte newColor[3], const GLubyte boundaryColor[3]) { stack\u0026lt;Vector2\u0026gt; _stack = stack\u0026lt;Vector2\u0026gt;(); _stack.push(startPoint); while (!_stack.empty()) { auto point = _stack.top(); _stack.pop(); cout \u0026lt;\u0026lt; \u0026#34;Position:\u0026#34; \u0026lt;\u0026lt; point.x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; point.y \u0026lt;\u0026lt; endl; GLubyte color[3]; glReadPixels(point.x, point.y, 1, 1,GL_RGB,GL_UNSIGNED_BYTE, color); //读取像素颜色 if (color[0] == boundaryColor[0] \u0026amp;\u0026amp; color[1] == boundaryColor[1] \u0026amp;\u0026amp; color[2] == boundaryColor[2] || color[0] == newColor[0] \u0026amp;\u0026amp; color[1] == newColor[1] \u0026amp;\u0026amp; color[2] == newColor[2]) //若与填充颜色/边界颜色相等则停止 { continue; } //绘制 DrawDot(point, newColor); //连通 _stack.push(Vector2(point.x - 1, point.y)); _stack.push(Vector2(point.x, point.y + 1)); _stack.push(Vector2(point.x + 1, point.y)); _stack.push(Vector2(point.x, point.y - 1)); } } 基于扫描线的种子填充算法 # 找到一个图形内的像素点（种子点），通过X轴扫描线对图像进行填充\n实现步骤为：\n初始化栈并将种子点入栈 栈顶点出栈，以该点的水平线作为当前的扫描线 从该点出发，沿着当前扫描线左右两方向填充，直到填充到边界。最左端的填充像素和最右端的分别记为 \\(X_l\\)和 \\(X_r\\) 在区间[\\(X_l,X_r\\)]范围内，搜索每个像素点的上方像素（一般是从左到右）是否未填充且不是边界。如果发现，则将上方每个未填充像素区间（可能有多个非连通的未填充区间）的最左边的（或是最右，依题意）像素入栈 和第4步一致，只不过搜索的是下方的像素点 重复2-5，直到栈空（依题意，第4步和第5步的顺序可能调换） 像素入栈顺序 - 每条扫描线从左到右扫描，先搜索上方像素，再搜索下方，每次选择未填充区间的最右像素点\r","date":"2023年6月16日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0--3.-%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85/","section":"Posts","summary":"","title":"复习 计算机图形学基础 第三章 -- 3. 区域填充"},{"content":"\rBresenham画圆算法 # Bresenham画圆算法\r设与当前圆周最近的像素点是 \\(P_{i-1}(x_i-1,y_i-1)\\)\n下一个与圆周最近的像素点只能是正右方的点 \\(H_i(xi_-1+1,y_i-1)\\) 或者是右下方的点 \\(L_i(x_i-1+1,y_i-1-1)\\)\n做判别式 \\(d_i\\) 的增量计算：\n\\(d_i\\) 的初值为 $$ Δ重点 \\ \\ d_0 = 3 - 2R $$\n若 \\(d_i\u0026lt;0\\) ，选择 \\(H_i\\) 点为下一个绘制的像素（X轴+1，Y轴不变），并递推出 \\(d_{i+1}\\)： $$ Δ重点 \\ \\ d_{i+1} = d_i+4x_i+6 $$\n若 \\(d_i\\geq0\\) ，选择 \\(L_i\\) 点为下一个绘制的像素（X轴+1，Y轴-1），并递推出 \\(d_{i+1}\\)： $$ Δ重点 \\ \\ d_{i+1} = d_i+4(x_i-y_i)+10 $$\n递推出1/8圆弧后，即可利用圆的对称性获得整个圆的点。\n注意，当绘制的圆圆心不为(0,0)时，先设圆心为(0,0)，然后将计算出的绘制点的坐标加上原来的圆心位置即可。\n例： 使用Bresenham算法画圆心(0,0)，半径R=5的圆，写出1/8圆弧的判定过程：\n根据圆心和半径可知，第一个点为 \\((0,5)\\)\n\\(d_1 = 3 - 2R = -7\\)\nX Y \\(d_i\\) 操作 0 5 -7 \\(d_i \u0026lt; 0\\)，y不变 1 5 -1 \\(d_i \u0026lt; 0\\)，y不变 2 5 9 \\(d_i \\geq 0\\)，y值-1 3 4 7 完成 中点画圆算法 # 中点画圆算法与Bresenham画圆算法类似，利用圆的对称性，只需要讨论1/8圆弧。\n中点画圆算法\r假设P为当前点亮象素，那么下一个点亮的象素可能是 \\(T(x_p+1, y_p)\\) 或 \\(S(x_p+1, y_p - 1)\\)\n如果忽略圆心位置，那么根据圆的方程，可以构造一个函数\\(F(x,y)\\)： $$ F(x,y)=x^2+y^2-r^2 $$\n将重点M的代入函数F，可推断出：\n若F(M)\u0026lt;0，M在圆内，此时下一个点取T； 若F(M)≥0，M在圆上或圆外，此时下一个点取S。 那么可以通过计算判别式 \\(d_i=F(M)\\) 来对下一个绘制像素进行选择\nd的初值为： $$ \\begin{split} Δ重点\\ \\ d_0\u0026amp;=F(0+1,r-0.5) \\\\ \u0026amp;=1+(r-0.5)^2-r^2 \\\\ \u0026amp;=1.25-r \\end{split} $$\n如果 \\(d_i\u0026lt;0\\)，则选择T为下一个绘制的像素（X轴+1，Y轴不变），并递推出 \\(d_{i+1}\\): $$ \\begin{split} Δ重点\\ \\ 𝑑_{i+1}=𝐹(𝑀)\u0026amp;=𝐹(𝑥_i+2,𝑦_i−0.5) \\\\ \u0026amp;=(𝑥_i+2)^2+(𝑦_i−0.5)^2−𝑟^2 \\\\ \u0026amp;=d_i+2𝑥_i+3 \\end{split} $$\n如果 \\(d_i \\geq 0\\)，则选择S为下一个绘制的像素（X轴+1，Y轴-1），并递推出 \\(d_{i+1}\\): $$ \\begin{split} Δ重点\\ \\ 𝑑_{i+1}\u0026amp;=𝐹(𝑥_i+2,𝑦_i−1.5) \\\\ \u0026amp;=(𝑥_i+2)^2+(𝑦_i−1.5)^2−𝑟^2 \\\\ \u0026amp;=𝑑_i+(2𝑥_i+3)+(−2𝑦_i+2)\\\\ \u0026amp;=𝑑_i+(2𝑥_i−2𝑦_i+5) \\end{split} $$\n递推出1/8圆弧后，即可利用圆的对称性获得整个圆的点。\n注意，当绘制的圆圆心不为(0,0)时，先设圆心为(0,0)，然后将计算出的绘制点的坐标加上原来的圆心位置即可。\n例：使用中点画圆算法画圆心(1,2)，半径R=5的圆：\n设圆心为(0,0)\n根据圆心和半径可知，第一个点为 \\((0,5)\\)\nX Y \\(d_i\\) 操作 0 5 -4.25 \\(d_i \u0026lt; 0\\)，y不变 1 5 -1.25 \\(d_i \u0026lt; 0\\)，y不变 2 5 3.75 \\(d_i \\geq 0\\)，y值-1 3 4 4.75 完成 ","date":"2023年6月16日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0--2.-%E5%9C%86%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/","section":"Posts","summary":"","title":"复习 计算机图形学基础 第三章 -- 2. 圆生成算法"},{"content":"\r数值微分法(DDA) # DDA算法是根据直线的微分方程来计算Δx或Δy生成直线的扫描转换算法。在一个坐标轴上以单位间隔对线段取样, 以决定另一个坐标轴方向上最靠近理想线段的整数值。\n设\\((x_0, y_0)\\)为直线段的始点, \\((x_n, y_n)\\)为直线段的终点，且端点坐标均为整数, 则直线的微分方程为\n$$ \\frac{dy}{dx} = \\frac{Δy}{Δx} = \\frac{y_n - y_0}{x_n - y_0} = k，(k即为直线的斜率) $$\n当 \\(|k| \\leq 1\\) 时，应当取x方向为步长方向，每次步进一个单位，则有： $$ x_{x+1} = x_i \\pm 1 $$\n$$ y_{y+1} = x_i \\pm k $$\n当 \\(|k| \u0026gt; 1\\) 时，应当取y方向为步长方向，则有： $$ x_{i+1} = x_i \\pm \\frac{1}{k} $$ $$ y_{i+1} = y_i \\pm 1 $$\n总结 首先求出直线斜率k:\\(\\frac{Δy}{Δx}\\)，根据k的大小决定画线的步进方向：\n如果 \\(|k|\\leq1\\)，则画线时以X轴为步进方向，每次x步进1，y步进k 如果 \\(|k| \u0026gt; 1\\)，那么画线时以Y轴为步进方向，每次x步进\\(\\frac{1}{k}\\)，y步进1 具体步进的方向为正半轴还是负半轴要取决于直线的斜率，在做题时只需要知道朝着目标点\\((x_n,y_n)\\)步进就行了。\nvoid LineDDA(int x1, int y1, int x2, int y2) { int dm=0; if (abs(x2-x1)\u0026gt;= abs(y2-y1)) //abs是求绝对值的函数 dm=abs(x2-x1); //x为计长方向 else dm=abs(y2-y1); //y为计长方向 float dx=(float)(x2-x1)/dm; //当x为计长方向时，dx的值为1 float dy=(float)(y2-y1)/dm; //当y为计长方向时，dy的值为1 float x=x1; //取整操作 float y=y1; //取整操作 for (int i=0; i\u0026lt; dm; i++) { setpixel( (int)(x+0.5), (int)(y+0.5));//在屏幕上绘制该点 x+=dx; y+=dy; } } Bresenham算法 # 在将直线光栅化时，假设直线的斜率 \\(k \\geq 0\\)，起点为 \\(P_0 (x_0,y_0)\\)，终点为 \\(P_n (x_n,y_n)\\)。\n从起点\\(P_0\\)开始，每次在水平方向上朝着终点\\(P_n\\)移动一个像素，由于受到斜率 k 的影响，直线每个像素的下一个要绘制的像素点要么是右边的点S，要么是右上的点T：\n右或是右上\rBresenham画线算法即是使用了这个判别方式：\n由上图所示，可知S的坐标为\\((x_{i+1},y_i)\\)，T的坐标为\\((x_{i+1},y_{i+1})\\)\n并且直线方程可以表示为 $$ y = kx+b $$\n因此有： $$ \\begin{cases} s \u0026amp;= y-y_i=k(x_i+1)+b-y_i \\\\ t \u0026amp;= y_i+1-y=Y_i+1-k(x_i+1)-b \\end{cases} $$\n如果 \\(t \\leq s\\)，则代表直线靠上方的点近一点，则下一个绘制的像素点应当选择右上方的，\n如果 \\(t \u0026gt; s\\)，则代表直线靠下方的点近一点，则下一个绘制的像素点应当选择右方的。\n注意这只适用于直线的斜率\\(k \\geq 0\\)的情况\n然后代入 \\(k = \\frac{dy}{dx}\\)，有\n$$ \\begin{split} dx(s-t)\u0026amp;=2dy(x_i+1)+2bdx-2y_idx-dx \\\\ \u0026amp;=2(x_idy-y_idx)+(2dy+2bdx-dx) \\end{split} $$\n因为 dx \u0026gt; 0，所以可以以 dx(s-t) 的正负作为选择S或T的依据，所以设 \\(d_i=dx(s-t)\\)\n将下标加一，有\n$$ \\begin{split} d_{i+1} \u0026amp;= 2(x_{i+1}dy-y_{i+1}dx)+(2dy+2bdx-dx) \\\\ \u0026amp;= d_i+2dy(x_{i+1}-x_i)-2dx(y_{i+1}-y_i) \\end{split} $$\n因为在水平方向上移动，所以 \\(x_{i+1}-x_i=1\\)，代入得 $$ d_{i+1}=d_i+2dy-2dx(y_{i+1}-y_i) $$ 这样就获得了一个递推公式，下一个\\(d_{i+1}\\)可以由前一个\\(d_i\\)递推得到\n通过计算当前点的$d_i$，可以判断向终点\\(P_n\\)移动时，下一个绘制的像素点应当选择右上方还是右方的。\n如果 \\(d_i \\geq 0\\) ，即 \\(t \\leq s\\)，下一个点选择右上方的，选择右上方的点满足了 \\(y_{i+1}-y_i=1\\)，所以将 \\(d_i\\) 改为 $$ Δ重点\\ \\ d_{i+1}=d_i+2(dy-dx) $$\n如果 \\(d_i\u0026lt;0\\) ，即 \\(s\u0026lt;t\\) 下一个点应当选择右方的，此时满足了 \\(y_{i+1}=y_i\\)，则有 $$ Δ重点\\ \\ d_{i+1}=d_i+2dy $$\n在开始绘制时，需要先知道 \\(d_i\\) 的初值 \\(d_0\\)，因为在开始绘制时，i=1，\\(b=y_1-kx_1\\)，可代入上文 \\(d_i\\)的公式得出： $$ \\begin{split} Δ重点\\ \\ d_0 \u0026amp;=dx(s-t) \\\\ \u0026amp;= 2(x_idy-y_idx) + (2dy + 2bdx-dx) \\\\ \u0026amp;= 2dy-dx \\end{split} $$ 从起点 \\(P_0\\) 开始向终点 \\(P_n\\) 移动，每次在X轴上步进一个像素，并求出当前的 \\(d_i\\) ，即可知道下一个点所在方位（右或右上）。\n注意，上面讨论的是直线斜率 \\(0 \\leq k \\leq 1\\)的情况，对于一般情况可做如下处理：\n当 \\(|k|\u0026gt;1\\) 时，将x、y和dx、dy对换，即以Y轴做增长方向，y总是增长1（或减少1，取决于dx，dy的符号）\n所以x的操作取决于 \\(d_i\\) 的符号： \\(d_i \\geq 0\\) 时，x增加1（或减少1）； \\(d_i \u0026lt; 0\\) 时，x不变。 需要根据dx和dy的符号来判断x或y每次步进应当加一还是减一，如果 dx(或dy) \u0026lt; 0 ，那么每次x轴步进（或y轴步进）就应当减一，在做题时，只需要知道朝终点方向步进就行了。 总结\n求出dy和dx的值，并计算斜率k\n判断步进方向：\n\\(|k|\\leq 1\\)时，X轴为步进方向 \\(|k|\u0026gt;1\\)，Y轴为步进方向 当\\(dx \u0026gt; 0\\) 时，朝X正半轴步进，反之则负半轴 当\\(dy \u0026gt; 0\\) 时，朝Y正半轴步进，反之则负半轴 设当前直线斜率 \\(|k| \\leq 1\\)，并且 dx,dy 均大于0。\n开始绘制直线，从原点开始 求判别式 \\(d_i\\) 的值，初值 \\(d_1\\) 为 \\(2dy-dx\\)，\n每次朝步进方向轴移动，此时是X轴，则x值+1\n根据 \\(d_i\\) 的值判断另一个轴（此时是Y轴）的状态：\n如果 \\(d_i \\geq 0\\) ，则y的值+1 如果 \\(d_i \u0026lt; 0\\) ，则y不变 下一次步进所用的 \\(d_{i+1}\\) 要由本次的 \\(d_i\\) 递推得到，所以计算 \\(d_{i+1}\\)：\n如果当前的 \\(d_i \\geq 0\\) ，\\(d_{i+1}=d_i+2(dy-dx)\\) 如果当前的 \\(d_i \u0026lt; 0\\) ，\\(d_{i+1}=d_i+2dy\\) 注意，在做题时要根据终点的方向来判断每次步进是朝着正半轴（+1）还是负半轴（-1） 然后按照上面的顺序持续步进，直到抵达终点\n例： 从点 A(0,0) 到 B(5,4) 用 Bresenham 算法画一直线，写出绘制流程：\ndx = 5 - 0 = 5\ndy = 4 - 0 = 4\nk = dy / dx = 0.8\n即朝X轴步进，x和y都朝正半轴移动 每次步进选择的像素以及 $d_i$ 值如下表：\nX Y $d_i$ 操作 0 0 3 \\(d_i \\geq 0\\)，y值+1 1 1 1 \\(d_i \\geq 0\\)，y值+1 2 2 -1 \\(d_i \u0026lt; 0\\)，y值不变 3 2 7 \\(d_i \\geq 0\\)，y值+1 4 3 5 \\(d_i \\geq 0\\)，y值+1 5 4 3 抵达终点 void Bres_Line(int x1, int y1, int x2, int y2) { setpixel(x1,y1); int dx=abs(x2-x1),dy=abs(y2-y1); if ( dx==0 \u0026amp;\u0026amp; dy==0) return; int flag=0; if (dx\u0026lt;dy) //下面将斜率变换至0≤|k|≤1区间 { flag=1; swap_value(\u0026amp;x1, \u0026amp;y1); swap_value(\u0026amp;x2, \u0026amp;y2); swap_value(\u0026amp;dx, \u0026amp;dy); } int tx=(x2-x1) \u0026gt;0 ? 1:-1,ty=(y2-y1)\u0026gt;0 ? 1: -1; int curx=x1,cury=y1; int dS=2*dy,dT=2*(dy-dx),d=dS-dx; while (curx!=x2) { if (d\u0026lt;0) d+=dS; else cury+=ty, d+=dT; curx+=tx; if (flag) setpixel(cury, curx); else setpixel(curx, cury); } } 中点画线算法 # 中点画线算法与Bresenham算法类似，两者的规则有所不同，但是总体思想是一致的，并且效率也完全相同。\n中点画线算法\r假定直线斜率 0\u0026lt;k\u0026lt;1 ，且已确定当前处理过的像素点P(xp,yp)，则下一个与直线最接近的像素只能是P1或P2。设M为P1与P2的中点，Q为交点。现确定下一个要画的像素的位置。\n如果M在Q下方，则P2离直线近，取P2； 如果M在Q上方，则P1离直线近，取P1。 M与Q重合，P1、P2任取一点。 根据直线方程 $$ \\begin{split} 𝐹(𝑥,𝑦)\u0026amp;=𝑎𝑥+𝑏𝑦+𝑐=0 \\\\ 𝑎\u0026amp;=𝑦_0−𝑦_1\\\\ 𝑏\u0026amp;=𝑥_1−𝑥_0\\\\ 𝑐\u0026amp;=𝑥_0 𝑦_1−𝑥_1 𝑦_0 \\end{split} $$\n可知对于直线上的点，将坐标代入后 F(x,y) 将等于0；\n对于直线上方的点，F(x,y) \u0026gt; 0； 对于直线下方的点，F(x,y) \u0026lt; 0。 因此，如果要判断上图中的M点在Q点的上方还是下方，只需要把M点代入方程，并判断符号即可。M点是P1和P2的中点，所以它的坐标为\\((x_p+1,y_p+0.5)\\)。\n代入到直线方程中，可构造判别式： $$ \\begin{split} 𝑑\u0026amp;=𝐹(𝑥_𝑝+1, 𝑦_𝑝+0.5) \\\\ \u0026amp;=𝑎(𝑥_𝑝+1)+𝑏(𝑦_𝑝+0.5)+𝑐 \\end{split} $$\n当 \\(d_i \\geq 0\\) 时，即M点在Q点上方，那应该取P1点。并且，可以通过当前 \\(d_i\\) 的值递推出 \\(d_{i+1}\\) 的值： $$ \\begin{split} Δ重点\\ \\ d_{i+1}\u0026amp;=F(x_p+2, y_p+0.5) \\\\ \u0026amp;=a(x_p+2)+b(y_p+0.5)+c \\\\ \u0026amp;=a(x_p+1)+b(y_p+0.5)+c+a \\\\ \u0026amp;= d+a \\end{split} $$\n而当 \\(d_i \u0026lt; 0\\) 时，即M点在Q点下方，则应当取P2点，计算\\(d_{i+1}\\) 的值： $$ \\begin{split} Δ重点\\ \\ d_{i+1}\u0026amp;=F(x_p+2, y_p+1.5) \\\\ \u0026amp;=a(x_p+2)+ b(y_p+1.5)+c \\\\ \u0026amp;=a(x_p+1)+b(y_p+0.5)+c+a+b \\\\ \u0026amp;=d+a+b \\end{split} $$\n画线从(x0, y0)开始，所以 \\(d_i\\) 的初值应该是： $$ \\begin{split} Δ重点 \\ \\ d_0\u0026amp;=F(x_0+1,y_0+0.5) \\\\ \u0026amp;=a(x_0+1)+b(y_0+0.5)+c \\\\ \u0026amp;=F(x_0,y_0)+a+0.5b \\\\ \u0026amp;=a+0.5b \\end{split} $$\n用同样的推导过程，当直线斜率-1\u0026lt;k\u0026lt;0时：\n当d≥0，此时 \\(d_{i+1}=d-a\\) 当d\u0026lt;0，此时 \\(d_{i+1}=d-a+b\\) 当斜率|k|\u0026gt;1时，将x,y坐标互换以完成递推过程。在画点时再将x,y坐标互换。\n总结\n根据起点和终点的坐标，可以使用两点式 \\((y-y_1)/(x-x_1)=(y_2-y_1)/(x_2-x_1)\\) 求出其直线方程 \\(ax + by + c = 0\\) 计算 \\(d_i\\) 初值 \\(d_0 = a + 0.5b\\)，设当前直线斜率 0 \u0026lt; k \u0026lt; 1，开始在X正方向步进，每次1个像素点 根据 \\(d_i\\) 的值判断 y 的变化 若 \\(d_i \u0026lt; 0\\)，y的值+1 若 \\(d_i \\geq 0\\)，y不变 计算 \\(d_{i+1}\\)： 若 \\(d_i \u0026lt; 0\\)，\\(d_{i+1} = d_i+a\\) 若 \\(d_i \\geq 0\\)，\\(d_{i+1} = d_i+a+b\\) 如果直线斜率-1\u0026lt;k\u0026lt;0，将\\(d_{i+1}\\)的判别式更改为： 若 \\(d_i \u0026lt; 0\\)，\\(d_{i+1} = d_i-a\\) 若 \\(d_i \\geq 0\\)，\\(d_{i+1} = d_i-a+b\\) 如果直线斜率|k|\u0026gt;1，将x,y坐标互换以完成递推过程。在画点时再将x,y坐标互换。 例： 从点 A(0,0) 到 B(5,4) 用中点画线算法画一直线，写出绘制流程：\n直线方程为：\\(4x-5y=0\\) a = 4, b = -5\n\\(d_1\\) = a + 0.5b = 1.5\n每次步进选择的像素以及 \\(d_i\\) 值如下表：\nX Y \\(d_i\\) 操作 0 0 1.5 \\(d_i \\geq 0\\)，y值+1 1 1 0.5 \\(d_i \\geq 0\\)，y值+1 2 2 -0.5 \\(d_i \u0026lt; 0\\)，y值不变 3 2 3.5 \\(d_i \\geq 0\\)，y值+1 4 3 2.5 \\(d_i \\geq 0\\)，y值+1 5 4 1.5 抵达终点 void Mid_Line(int x1, int y1, int x2, int y2) { setpixel(x1,y1); int b=abs(x2-x1),a=-abs(y2-y1); if ( dx==0 \u0026amp;\u0026amp; dy==0) return; int flag=0; if (dx\u0026lt;dy) //下面将斜率变换至0≤|k|≤1区间 { flag=1; swap_value(\u0026amp;x1, \u0026amp;y1); swap_value(\u0026amp;x2, \u0026amp;y2); swap_value(\u0026amp;dx, \u0026amp;dy); } int tx=(x2-x1) \u0026gt;0 ? 1:-1,ty=(y2-y1)\u0026gt;0 ? 1: -1; int curx=x1,cury=y1; int d=a+b\u0026gt;\u0026gt;1; while (curx!=x2) { if (d\u0026gt;=0) d+=a; else cury+=ty, d+=a+b; curx+=tx; if (flag) setpixel(cury, curx); else setpixel(curx, cury); } } ","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0--1.-%E7%9B%B4%E7%BA%BF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/","section":"Posts","summary":"","title":"复习 计算机图形学基础 第三章 -- 1. 直线生成算法"},{"content":"","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/.net/","section":"Categories","summary":"","title":".NET"},{"content":"","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/c#/","section":"Tags","summary":"","title":"C#"},{"content":"详见 官方文档\nSpan\u0026lt;T\u0026gt; # Span是一种\r引用结构体(ref struct)，它提供任意内存的连续区域的类型安全和内存安全表示形式。Span通常用于充当数组，但与数组不同的是，Span 实例可以指向堆栈上托管的内存、本机内存或托管的内存。\n// 创建一个数组，并用Span指向这个数组。 // 注意这里的Span仅是指向了array的地址，并没有在堆上创建内存。 var array = new int[]{1,2,3,4,5}; var arraySpan = new Span\u0026lt;int\u0026gt;(array); for (int ctr = 0; ctr \u0026lt; arraySpan.Length; ctr++)//使用Length获取这串内存的长度，单位是int arraySpan[ctr] = 0; //使用[]运算符对特定位置的内存进行访问 foreach (var num in array) Console.Write(num); // 输出：00000 上面的例子声明了一个内容为 {1,2,3,4,5} 的int数组，并定义了一个Span\u0026lt;int\u0026gt;指向该数组。此时Span起到了类似于指针的作用，对一段连续的内存进行直接访问。\nSpan\u0026lt;T\u0026gt;和内存 # Span\u0026lt;T\u0026gt;不仅可以指向某个数组（即.NET运行时托管的内存），还可以指向本地内存或是堆栈，如以下代码所示：\n使用Marshal类分配一块本地内存（并非.NET运行时中的内存），并使用Span\u0026lt;byte\u0026gt;指向它：\n// 创建一块本机内存，并用Span指向它，对非.NET运行时托管内存进行操作是不安全代码，使用unsafe块 var native = Marshal.AllocHGlobal(100); Span\u0026lt;byte\u0026gt; nativeSpan; unsafe { nativeSpan = new Span\u0026lt;byte\u0026gt;(native.ToPointer(), 100); //将Span指向分配的本机内存 } byte data = 0; for (int ctr = 0; ctr \u0026lt; nativeSpan.Length; ctr++) nativeSpan[ctr] = data++; // 直接对内存进行操作 int nativeSum = 0; foreach (var value in nativeSpan) nativeSum += value; Console.WriteLine($\u0026#34;The sum is {nativeSum}\u0026#34;); Marshal.FreeHGlobal(native); //释放内存 // Output: The sum is 4950 使用\rstackalloc关键字在堆栈上分配一块内存，并用Span指向它：\nSpan\u0026lt;int\u0026gt; arraySpan = stackalloc int[5]; // 使用stackalloc关键字在堆栈上分配一个int数组 var n = 0; for (int ctr = 0; ctr \u0026lt; arraySpan.Length; ctr++) arraySpan[ctr] = n++; // 访问数组内的元素 foreach (var num in arraySpan) Console.Write(num); // 输出：01234 Span\u0026lt;T\u0026gt;和切片 # 使用Span\u0026lt;T\u0026gt;的构造函数，或是Span\u0026lt;T\u0026gt;对象的Slice方法，可以对连续内存的中的一部分区域进行操作：\nvar array = new int[]{1,2,3,4,5}; var arraySpan = new Span\u0026lt;int\u0026gt;(array, 1,3); //指向 array[1]~array[3]的内存 for (int ctr = 0; ctr \u0026lt; arraySpan.Length; ctr++) arraySpan[ctr] = 0; foreach (var num in array) Console.Write(num); // 输出：10005 Span\u0026lt;T\u0026gt;的切片操作常用于字符串，因为C#字符串的\r不可变性，对字符串的修改操作（如分割、拼接、修改内容、提取子串）并不是直接在原有字符串上进行操作，而是会返回新的字符串对象。因此频繁对字符串的修改操作会产生大量冗余内存给\r垃圾回收期(GC)增加压力，从而对性能产生影响。\npublic static (int year, int month, int day) StringToDate(string str) { var year = str.Substring(0,4); var month = str.Substring(4,2); var day = str.Substring(6,2); return (int.Parse(year), int.Parse(month), int.Parse(day)); } 上述的代码对一段 yyyyMMdd 格式的日期字符串进行分割处理，并返回包含整型 (年，月，日) 的元组。\n通过SubString方法分割字符串，并用int.Parse方法转换为整形。\n这个方法多次对字符串进行提取子串的操作，由于字符串不可变的特性，每次提取子串时都会产生新的字符串实例，在内存分析器中可以看出产生了三个新的字符串：\nSubString产生的新字符串对象\r所以，如果有大量与上述类似的字符串处理操作被执行，将会产生非常多的无用内存，而GC回收这些内存时会对性能产生大幅影响。所以对于大量的字符串处理操作，往往会选择使用\rStringBuilder类来避免产生过多垃圾。\n但因为string对象也是一段连续的内存，此时也可以使用Span\u0026lt;char\u0026gt;来对直接对字符串进行操作：\npublic static (int year, int month, int day) StringToDate(ReadOnlySpan\u0026lt;char\u0026gt; str) { var year = str.Slice(0,4); var month = str.Slice(4,2); var day = str.Slice(6,2); return (int.Parse(year), int.Parse(month), int.Parse(day)); } 方法将输入的字符串隐式转换为ReadOnlySpan\u0026lt;char\u0026gt;，并用Slice方法对这段内存进行切片，将切片的结果转换为int类型。\nSpan\u0026lt;T\u0026gt;的是对该段内存的直接操作，所以不像SubString，Slice方法并不会在堆上分配任何的内存，仅仅是返回一个指向了该段内存的Span\u0026lt;T\u0026gt;对象而已。\n可以看到内存中没有产生多余的字符串对象：\nSlice方法并不会产生新的字符串\r直接对对象的内存进行操作避免产生垃圾，这对大量的字符串处理操作有非常可观的性能优化。\n缺陷 # 虽然使用Span\u0026lt;T\u0026gt;可以对性能有很大的提升，但因为它是\r引用结构体类型，所以使用起来有较多的限制，比如：\nref struct 不能是数组的元素类型。 ref struct 不能是类或非 ref struct 的字段的声明类型。 ref struct 不能实现接口。 ref struct 不能被装箱为 System.ValueType 或 System.Object。 ref struct 不能是类型参数。 ref struct 变量不能由 Lambda 表达式或本地函数捕获。 ref struct 变量不能在 async 方法中使用。 但是，可以在同步方法中使用 ref struct 变量，例如，在返回 Task 或 Task 的方法中。 ref struct 变量不能在迭代器中使用。 这些限制决定了Span\u0026lt;T\u0026gt;不能在大多数场景中使用，但如果在编写某些方法时，对性能或是内存要求十分苛刻，那么使用Span\u0026lt;T\u0026gt;是个很不错的选择。\n","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/csharpspan%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"Posts","summary":"","title":"C# Span\u003c T \u003e的使用"},{"content":"","date":"2023年6月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/c#%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"C#基础"},{"content":"\r一个交互式计算机图形系统应具有计算、存储、对话、输入和输出等5个方面的功能 图形系统分为图形硬件和图形软件。 图形显示设备主要有彩色阴极射线管CRT和液晶显示器LCD。 图形显示方式随机扫描（画线设备）和光栅扫描（画点设备）。 光栅扫描显示系统主要包括：显示器，帧缓冲器和视频控制器。 计算 颜色数K 和 帧缓存器(显存)V(单位bit) 的大小之间的关系，分辨率为m*n，公式为： $$ 𝑉 \\geq m×n×log_2 K $$ ","date":"2023年6月14日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0/","section":"Posts","summary":"","title":"复习 计算机图形学基础 第二章"},{"content":"\rnull检查 # object? obj = null; if (obj == null) { Console.WriteLine(\u0026#34;object is null\u0026#34;); } 上述的代码是C#最基本，也是最常用的null检查，但在现代C#语言中，这种做法并不是最好的。\n被重载的==运算符 # 使用==或是!=运算符进行null检查时，如果遇到对象类型的==和!=运算符被重载的情况，可能得到意料之外的结果：\nclass User { public string Name { get; set; } public static bool operator ==(User left, User right) =\u0026gt; left.Name == right.Name; public static bool operator !=(User left, User right) =\u0026gt; !(left == right); } static void Main(string[] args) { var user1 = new User { Name = \u0026#34;Azusa\u0026#34; }; var user2 = new User { Name = \u0026#34;Hina\u0026#34; }; Console.WriteLine(user1 != null); //此时会抛出空引用异常，因为在 != 运算符中引用了 null 的 Name 属性 } 这样的行为可能会导致程序中隐藏的漏洞，比如上述的情况只有在运行时抛出异常才能察觉。（如果使用了C# 8.0的空引用类型，则会有编译器警告。实际上在主流的IDE中，重载前后的==运算符显示在编辑器中的颜色是不一致的，不过这不是很容易察觉到）\nReferenceEquals # 如果要确保我们的意图是“检查对象的引用是否为空”，而不是通过==或!=运算符来检查，则需要使用Object.ReferenceEquals()函数：\nif (ReferenceEquals(user1,null)) ... 使用ReferenceEquals函数保证了null检查不会被影响，因为这个函数真的就是检查两参数的引用是否相等，且不会被重载。\n有趣的是，当转到Object.ReferenceEquals()函数的实现时，发现内部还是调用了==运算符：\n[NonVersionable] public static bool ReferenceEquals(object? objA, object? objB) { return objA == objB; } 但因为接受的两个参数都被转换为了可空的object类型，所以调用的==运算符依然是没被重载的，object类型中定义的==运算符。\n既然如此，在使用==进行null检查时，可以加一步转换，来防止运算符被重载的情况。\nif ((object?)user1 == null) { Console.WriteLine(\u0026#34;object is null\u0026#34;); } 但这样的代码不够美观。\n模式匹配 # C# 7.0出现了模式匹配后，null检查出现了新的方法。使用is运算符进行\r常量模式匹配时可以接收null值，所以null检查变成了这样：\nif (user1 is null) { Console.WriteLine(\u0026#34;object is null\u0026#34;); } 如果使用的C#是9.0版本之后，则可以加上not运算符来实现非null检查：\nif (user1 is not null) { Console.WriteLine(\u0026#34;object is not null\u0026#34;); } 这样的代码看起来更直观了。实际上，这也是微软官方推荐的做法：\rnull检查\n在C#内部，实际上使用is进行null检查时，也是先把对象转换为了object类型。\n总结 # 所以，在进行null检查时，模式匹配obj is null是最推荐的做法，但如果语言版本不满足(\u0026lt;7.0)，进行null检查则要更加谨慎，object.ReferenceEquals()函数是最安全的做法，而使用==运算符进行检查是比较危险的，因为运算符可能被重载，得到意料之外的结果。\n","date":"2023年6月14日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/csharp%E6%AD%A3%E7%A1%AE%E7%9A%84null%E6%A3%80%E6%9F%A5/","section":"Posts","summary":"","title":"C# 正确的null检查"},{"content":"\r第一章 # 图形与图像的区别 # 内容 图形 图像 基本元素 点、线、面等几何元素，比如直线，圆，多边形。。。 像素 存储数据 各个矢量的参数 各个像素的灰度或颜色 处理方式 旋转，扭曲或拉伸等 对比度增强，边缘检测等 缩放结果 不会失真，适应不同分辨率 放大会失真 其他 图形不是客观存在的，是根据客观事物而主观形成 对客观事物的真实描述 实例 工程图纸 照片 应用领域 计算机辅助设计 图像处理 计算机图形学概念 # 研究通过计算机将信息、数据转换为图形，并在专门显示设备上显示的原理、方法和技术的学科。\nOpenGL中基本的图元，常用的函数 # 基本函数 # glutInit(int *argc,char **argv)// 使用外部参数初始化GLUT glutInitDisplayMode(unsigned int mode) // 使用GLUT的枚举值初始化显示模式，指定缓冲区模式和颜色格式，使用按位或来同时设置 glutInitWindowPosition(int x,int y) //指定了窗口左上角的屏幕位置 glutInitWindowSize(int width,int size) //指定了窗口的大小（以像素为单位） glutCreateWindow(char *string) //创建一个支持OpenGL渲染环境的窗口。在调用glutMainLoop()函数之前，这个窗口并没有显示。 glutDisplayFunc(void(*func)(void)) //OpenGL绘制回调函数，将绘制函数作为参数 glutMainLoop(void) //开始OpenGL绘制循环 输入事件处理 # glutReshapeFunc(void(*func)int w,int h) //注册当前窗口大小变化时的回调函数 glutKeyboardFunc(void(*func)(unsigned char key,int x,int y)) //注册当前窗口的键盘回调函数 glutMouseFunc(void (*func) (int button, int state, int x, int y)); glutMouseFunc为注册当前窗口的鼠标回调函数，func为注册的鼠标回调函数,这个函数完成鼠标事件的处理，button为鼠标的按键,为以下定义的常量：\nGLUT_LEFT_BUTTON 鼠标左键 GLUT_MIDDLE_BUTTON 鼠标中键 GLUT_RIGHT_BUTTON 鼠标右键 state为鼠标按键的动作：\nGLUT_UP 鼠标释放 GLUT_DOWN 鼠标按下 绘制函数 # 清除窗口 下面两行代码把一个RGBA模式的窗口清除为黑色\nglClearColor(0.0, 0.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT); 指定绘制颜色 在绘制前使用下列函数指定绘制颜色\nglColor3f(float r, float g, float b); //三个参数的范围为0-1 glColor3ub(unsigned char r, unsigned char g, unsigned char b) // 三个参数的范围为0-255 完成绘制\nglFlush() 如果使用双缓冲区模式，则需要交换缓冲区\nglutSwapBuffers() 绘制\n使用glBegin(unsigned int mode)函数指定图元并开始绘制\n使用glVertex..函数绘制顶点，满足了顶点的数量则会自动根据顶点生成图元对应的图形\n使用glEnd()函数结束绘制\nOpenGL几何图元\n模式 图元类型 GL_POINTS 将每个顶点绘制为点 GL_LINES 将每两个顶点绘制为一条线 GL_LINE_STRIP 将指定的顶点用于创建线条。第一个顶点之后的每个顶点指定的是线条延伸到的下一个点 GL_LINE_LOOP 与GL_LINE_STRIP类似，但是绘制完后起始顶点会和终结顶点连接 GL_TRIANGLES 将每三个顶点绘制为一个三角形 GL_TRIANGLE_STRIP 将指定的顶点用于创建三角条。指定前三个顶点之后，后继的每个顶点与它前面两个顶点一起用来构造下一个三角形。每个顶点三元组（在最初的组之后）会自动重新排列以确保三角形绕法的一致性 GL_TRIANGLE_FAN 将指定的顶点用于构造三角扇形。第一个顶点充当原点，第三个顶点之后的每个顶点与它的前一个顶点还有原点一起组合 GL_QUADS 将每四个顶点绘制为一个四边形 GL_QUADS_STRIP 将指定的顶点用于构造四条形边。在第一对顶点之后，每对顶点定义一个四边形。和GL_QUADS的顶点顺序不一样，每对顶点以指定顺序的逆序使用，以便保证绕法的一致 GL_POLYGON 将指定的顶点用于构造一个凸多边形。多边形的边缘决不能相交。最后一个顶点会自动连接到第一个顶点以确保多边形是封闭的 图元示例\r","date":"2023年6月13日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%80%E7%AB%A0/","section":"Posts","summary":"","title":"复习 计算机图形学基础 第一章"},{"content":" 本文内容参考\r微软官方文档\n“模式匹配”是一种测试表达式是否具有特定特征的方法。在代码中使用模式匹配可以有效提高开发效率和代码可读性。C#从7.0开始支持模式匹配，并支持以下匹配方式：\n声明模式：用于检查表达式的运行时类型，如果匹配成功，则将表达式结果分配给声明的变量。 类型模式：用于检查表达式的运行时类型。 在 C# 9.0 中引入。 常量模式：用于测试表达式结果是否等于指定常量。 关系模式：用于将表达式结果与指定常量进行比较。 在 C# 9.0 中引入。 逻辑模式：用于测试表达式是否与模式的逻辑组合匹配。 在 C# 9.0 中引入。 属性模式：用于测试表达式的属性或字段是否与嵌套模式匹配。 位置模式：用于解构表达式结果并测试结果值是否与嵌套模式匹配。 var 模式：用于匹配任何表达式并将其结果分配给声明的变量。 弃元模式：用于匹配任何表达式。 列表模式：测试序列元素是否与相应的嵌套模式匹配。 在 C# 11 中引入。 在C#代码中，可以使用is,or,not,and和switch表达式进行模板匹配，详见：\n模式匹配 - 模式中的 is 和 switch 表达式，以及 and、or 和 not 运算符\n声明和类型模式 # 条件语句 # 检查对象的类型是否与给定的一致（C# 9.0以上）：\nobject greeting = \u0026#34;Hello, World!\u0026#34;; if (greeting is string) // 如果greeting是string类型 { Console.WriteLine((string)greeting); } 声明模式，匹配时进行声明，省去了一步类型转换：\nif (greeting is string message) // 如果greeting类型为string，则将其以string类型赋值到message上 { Console.WriteLine(message); } (其实是做了这一步转换\nvar message = greeting as string; if (message is not null) ... 可以对其进行null检查，在进行上述的类型匹配也会自动进行null检查\nstring? str = \u0026#34;hello world!\u0026#34;; if (str is not null) { Console.WriteLine(str); } 使用模式匹配来进行null检查可以有效避免==和!=运算符被对象的类型重载而返回不正确值的情况\n加上与或表达式：\nobject a = 1; object b = 1.22f; if (a is int and b is float) ...//true if (a is float or b is float) ...//true 注意，如果对象派生，实现，或是存在任何到匹配类型的\r隐式引用转换，表达式都会为true\nvar list = new List\u0026lt;int\u0026gt;{1,2,3}; if (list is IEnumerable) // list实现IEnumerable接口 { Console.WriteLine(\u0026#34;list is Enumerable!\u0026#34;); } Switch表达式 # 使用\rswitch 关键字的模式匹配表达式\nC#将Switch语句融合进了模板匹配，上述的类型匹配可以使用Switch表达式来实现：\nobject obj = DateTime.Now; string type = obj switch { int =\u0026gt; \u0026#34;int\u0026#34;, string =\u0026gt; \u0026#34;string\u0026#34;, float =\u0026gt; \u0026#34;float\u0026#34;, DateTime =\u0026gt; \u0026#34;DateTime\u0026#34;, null =\u0026gt; \u0026#34;null\u0026#34;, _ =\u0026gt; \u0026#34;Unknown Type\u0026#34; }; Console.WriteLine(\u0026#34;object type is \u0026#34; + type); 并非switch表达式，正常的switch语句也是可行的\nstring type; switch (obj) { case int: type = \u0026#34;int\u0026#34;; break; case string: type = \u0026#34;string\u0026#34;; break; case float: type = \u0026#34;float\u0026#34;; break; case DateTime: type = \u0026#34;DateTime\u0026#34;; break; case null: type = \u0026#34;null\u0026#34;; break; default: type = \u0026#34;Unknown type\u0026#34;; break; } 但很显然switch表达式更加精练\n常量模式 # 模板匹配可以对常量值进行匹配\nstring str = \u0026#34;hello\u0026#34;; if (str is \u0026#34;hello\u0026#34;) { Console.WriteLine(\u0026#34;str is \\\u0026#34;hello\\\u0026#34;\u0026#34;); } 关系模式 # 从 C# 9.0 开始，可使用关系模式将表达式结果与常量进行比较\nint i = Random.Shared.Next(10); if (i is \u0026gt; 5) { Console.WriteLine(\u0026#34;i \u0026gt; 5\u0026#34;); } 感觉有点蠢？用上switch就不一样了\nConsole.WriteLine(Classify(13)); // output: Too high Console.WriteLine(Classify(double.NaN)); // output: Unknown Console.WriteLine(Classify(2.4)); // output: Acceptable static string Classify(double measurement) =\u0026gt; measurement switch { \u0026lt; -4.0 =\u0026gt; \u0026#34;Too low\u0026#34;, \u0026gt; 10.0 =\u0026gt; \u0026#34;Too high\u0026#34;, double.NaN =\u0026gt; \u0026#34;Unknown\u0026#34;, _ =\u0026gt; \u0026#34;Acceptable\u0026#34;, }; \u0026ldquo;在关系模式中，可使用关系运算符\u0026lt;、\u0026gt;、\u0026lt;= 或 \u0026gt;= 中的任何一个。 关系模式的右侧部分必须是常数表达式。 常数表达式可以是 integer、floating-point、char 或 enum 类型。\u0026rdquo;\n逻辑模式 # C# 9.0 以上，可以使用and,or,not关键字来创造\u0026rsquo;与\u0026rsquo;，\u0026lsquo;或\u0026rsquo;，\u0026lsquo;非\u0026rsquo;的逻辑\nif (input is not null) { // ... } 运行的优先级也是 not \u0026gt; and \u0026gt; or，并且从右开始扫描\n括号模式 # 使用括号强调或改变模式匹配优先级：\nif (input is not (float or double)) { return; } 属性模式 # 将对象的属性或是字段进行匹配：\nstatic bool IsConferenceDay(DateTime date) =\u0026gt; date is { Year: 2020, Month: 5, Day: 19 or 20 or 21 }; 属性模式可以用一串优雅的模式匹配代替复杂的条件语句，还能结合声明模式和类型模式：\nstatic string TakeFive(object input) =\u0026gt; input switch { string { Length: \u0026gt;= 5 } s =\u0026gt; s.Substring(0, 5), //结合了声明模式，类型模式，逻辑模式，常量模式和属性模式 string s =\u0026gt; s, ICollection\u0026lt;char\u0026gt; { Count: \u0026gt;= 5 } symbols =\u0026gt; new string(symbols.Take(5).ToArray()), ICollection\u0026lt;char\u0026gt; symbols =\u0026gt; new string(symbols.ToArray()), null =\u0026gt; throw new ArgumentNullException(nameof(input)), _ =\u0026gt; throw new ArgumentException(\u0026#34;Not supported input type.\u0026#34;), }; 属性模式是可以嵌套的，对于匹配的属性类型，还可以继续进行模式匹配：\npublic record Point(int X, int Y); public record Segment(Point Start, Point End); static bool IsAnyEndOnXAxis(Segment segment) =\u0026gt; segment is { Start: { Y: 0 } } or { End: { Y: 0 } }; 对属性嵌套进行模式匹配有些麻烦，C# 10.0 以上可以使用\u0026quot;扩展属性模式\u0026quot;，即成员运算符来对属性进行匹配，可将上述示例中的方法重构为以下等效代码：\nstatic bool IsAnyEndOnXAxis(Segment segment) =\u0026gt; segment is { Start.Y: 0 } or { End.Y: 0 }; “优雅，实在太优雅了\u0026quot;（指属性模式\n位置模式 # 位置模式可以匹配\r元组中的元素：\nvar location = (5, 10); if (location is (5, 10)) ... 位置模式也可以和其他各种模式结合：\nif (location is (\u0026gt;5, \u0026lt;10)) ... 这使得switch表达式可以结合元组一次匹配任意个对象：\nstatic int[] Encode(int x, int y) =\u0026gt; (x, y) switch { (\u0026lt; left, \u0026gt; top) =\u0026gt; new[] { 1, 0, 0, 1 }, (\u0026lt; left, \u0026lt; bottom) =\u0026gt; new[] { 0, 1, 0, 1 }, (\u0026gt; right, \u0026gt; top) =\u0026gt; new[] { 1, 0, 1, 0 }, (\u0026gt; right, \u0026lt; bottom) =\u0026gt; new[] { 0, 1, 1, 0 }, (_, \u0026gt; top) =\u0026gt; new[] { 1, 0, 0, 0 }, (_, \u0026lt; bottom) =\u0026gt; new[] { 0, 1, 0, 0 }, (\u0026lt; left, _) =\u0026gt; new[] { 0, 0, 0, 1 }, (\u0026gt; right, _) =\u0026gt; new[] { 0, 0, 1, 0 }, _ =\u0026gt; new[] { 0, 0, 0, 0 } }; 如果对象声明了\r解构函数，可以直接对其使用位置匹配：\npublic readonly struct Point { public int X { get; } public int Y { get; } public Point(int x, int y) =\u0026gt; (X, Y) = (x, y); public void Deconstruct(out int x, out int y) =\u0026gt; (x, y) = (X, Y); // 声明解构函数 static string Classify(Point point) =\u0026gt; point switch //对对象解构出的元组进行匹配 { (0, 0) =\u0026gt; \u0026#34;Origin\u0026#34;, //使用位置模式匹配point对象解构出的元组 (1, 0) =\u0026gt; \u0026#34;positive X basis end\u0026#34;, (0, 1) =\u0026gt; \u0026#34;positive Y basis end\u0026#34;, _ =\u0026gt; \u0026#34;Just a point\u0026#34;, }; } 结合关系模式，使用元组内元素的名称：\nvar numbers = new List\u0026lt;int\u0026gt; { 1, 2, 3 }; if (SumAndCount(numbers) is (Sum: var sum, Count: \u0026gt; 0)) //返回元组可以使用关系模式访问其元素 { Console.WriteLine($\u0026#34;Sum of [{string.Join(\u0026#34; \u0026#34;, numbers)}] is {sum}\u0026#34;); // output: Sum of [1 2 3] is 6 } static (double Sum, int Count) SumAndCount(IEnumerable\u0026lt;int\u0026gt; numbers) { int sum = 0; int count = 0; foreach (int number in numbers) { sum += number; count++; } return (sum, count); } var模式 # 可使用 var 模式来匹配任何表达式（包括 null），并将其结果分配给新的局部变量\nstatic bool IsAcceptable(int id, int absLimit) =\u0026gt; SimulateDataFetch(id) is var results \u0026amp;\u0026amp; results.Min() \u0026gt;= -absLimit \u0026amp;\u0026amp; results.Max() \u0026lt;= absLimit; static int[] SimulateDataFetch(int id) { var rand = new Random(); return Enumerable .Range(start: 0, count: 5) .Select(s =\u0026gt; rand.Next(minValue: -10, maxValue: 11)) .ToArray(); } 需要布尔表达式中的临时变量来保存中间计算的结果时，var 模式很有用。 当需要在 switch 表达式或语句的 when 大小写临界子句中执行更多检查时，也可使用 var 模式，如以下示例所示：\npublic record Point(int X, int Y); static Point Transform(Point point) =\u0026gt; point switch { var (x, y) when x \u0026lt; y =\u0026gt; new Point(-x, y), var (x, y) when x \u0026gt; y =\u0026gt; new Point(x, -y), var (x, y) =\u0026gt; new Point(x, y), }; static void TestTransform() { Console.WriteLine(Transform(new Point(1, 2))); // output: Point { X = -1, Y = 2 } Console.WriteLine(Transform(new Point(5, 2))); // output: Point { X = 5, Y = -2 } } 弃元模式 # 用_符号来在\rswitch表达式中充当default开关\n列表模式 # 从C# 11开始，可以使用列表模式匹配列表中的内容：\nint[] numbers = { 1, 2, 3 }; Console.WriteLine(numbers is [1, 2, 3]); // True Console.WriteLine(numbers is [1, 2, 4]); // False Console.WriteLine(numbers is [1, 2, 3, 4]); // False Console.WriteLine(numbers is [0 or 1, \u0026lt;= 2, \u0026gt;= 3]); // True 如前面的示例所示，当每个嵌套模式与输入序列的相应元素匹配时，列表模式就会匹配。 可使用列表模式中的任何模式。 若要匹配任何元素，请使用弃元模式，或者，如果还想捕获元素，请使用 var 模式，如以下示例所示：\nList\u0026lt;int\u0026gt; numbers = new() { 1, 2, 3 }; if (numbers is [var first, _, _]) //捕获第一个元素，丢弃后两个元素 { Console.WriteLine($\u0026#34;The first element of a three-item list is {first}.\u0026#34;); } 如果无需匹配整个序列，而是只需要匹配列表的头尾，可以使用切片模式..：\nConsole.WriteLine(new[] { 1, 2, 3, 4, 5 } is [\u0026gt; 0, \u0026gt; 0, ..]); // True 匹配前两个 Console.WriteLine(new[] { 1, 1 } is [_, _, ..]); // True 匹配前两个并弃元 Console.WriteLine(new[] { 1 } is [1, 2, ..]); // False 数量不一致，匹配错误 Console.WriteLine(new[] { 1, 2, 3, 4 } is [.., \u0026gt; 0, \u0026gt; 0]); // True 匹配最后两个 Console.WriteLine(new[] { 2, 4 } is [.., \u0026gt; 0, 2, 4]); // False 匹配最后三个 Console.WriteLine(new[] { 2, 4 } is [.., 2, 4]); // True Console.WriteLine(new[] { 1, 2, 3, 4 } is [\u0026gt;= 0, .., 2 or 4]); // True 匹配第一个和最后一个 Console.WriteLine(new[] { 1, 0, 0, 1 } is [1, 0, .., 0, 1]); // True 匹配前两个和最后两个 Console.WriteLine(new[] { 1, 0, 1 } is [1, 0, .., 0, 1]); // False 嵌套其他模式：\nvoid Validate(int[] numbers) { var result = numbers is [\u0026lt; 0, .. { Length: 2 or 4 }, \u0026gt; 0] ? \u0026#34;valid\u0026#34; : \u0026#34;not valid\u0026#34;; Console.WriteLine(result); } Validate(new[] { -1, 0, 1 }); // output: not valid Validate(new[] { -1, 0, 0, 1 }); // output: valid ","date":"2023年6月13日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/csharp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A6%82%E8%BF%B0/","section":"Posts","summary":"","title":"C#模式匹配概述"},{"content":" 本文章将举例介绍绝大多数C# 10的新特性，在.NET 6以上的项目支持这些特性。\n有些预览特性需要在项目配置文件(.csproj)中配置\u0026lt;LangVersion\u0026gt;preview\u0026lt;LangVersion/\u0026gt;才可生效\nC#10新增功能\n全局Using # 在任何一个C#类中使用global关键字修饰using指令，该using指令将会应用于整个项目\nglobalUsing.cs\n//这些using将会应用到整个项目 global using System.Collection.Generic; global using Newtonsoft.Json; ... 文件范围的命名空间 # 在C#文件中指定命名空间时可以不用花括号{}了，该命名空间将会应用于整个文件范围。但相反的，你无法在一个cs中定义多个命名空间中的内容（一般来说也不会这样做）。\nusing System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using Microsoft.IdentityModel.Tokens; namespace Azusa.Shared.Security;//不使用{}指定范围，整个文件都将被定义到该命名空间中。 public static class JwtTokenGenerator { ... } 常量内插字符串 # 你可以在const string中使用内插字符串了，你可以将用在某些只接受常量字符串的地方。\n... private const string BaseUrl = \u0026#34;localhost:7890\u0026#34;; public const string SignInUrl = $\u0026#34;{BaseUrl}/SignIn\u0026#34;;//你可以使用$内插常量字符串了 ... [HttpGet(SignInUrl)]//在这种地方适合使用常量字符串！ 泛型特性（注解） # C#特性也支持泛型了，传递类型参数更加方便，不需要typeof了。\npublic class UnitOfWorkAttribute\u0026lt;TDbContext\u0026gt; : Attribute where TDbContext : DbContext { ... } Lambda表达式改进 # var关键字可以推断lambda表达式的返回值了\nvar func = () =\u0026gt; \u0026#34;Nice\u0026#34;;//现在编译器可以推断出这个lambda是Func\u0026lt;string\u0026gt;了 var func1 = () =\u0026gt; null;//不过这样是不行的，因为null没有类型 var func2 = string? () =\u0026gt; null;//但是可以显式指定一下 特性也可以支持在lambda上标注了\nvar func3 = [UnitOfWorkAttribute\u0026lt;MyDbContext\u0026gt;()](long id) =\u0026gt; myDbCtx.Books.Find(id); 模式匹配属性扩展 # 在模式匹配的时候可以匹配对象的属性，并且用成员运算符.来匹配属性对象的属性\nif (book is Book{PubTime.Month:12})//用成员运算符来读取对象属性的属性 { ... } //以前得这样 if (book is Book { PubTime: { Month: 12 } }) { } 记录(record)结构体 # record类型也可以声明为结构体了，也是值类型。\npublic record struct Color(short Red, short Green, short Blue); 结构体的优化 # 在C#10以前，结构体的显式构造函数必须得给所有字段和自动属性赋值 比如这样一个结构体\npublic struct Color { public short Red { get; set; } public short Green { get; set; } public short Blue { get; set; } ... } 构造函数要么不写（隐式无参），要么写全（显式，并且所有自动属性和字段都得赋值）\n（很迷惑的操作，不知为何要这样设定）\n... public Color(short red, short green, short blue)//字段和自动属性都得赋值 { Red = red; Green = green; Blue = blue; } ... C#10以后，将接受赋值不完全的显式构造函数\npublic Color(short red, short green) { Red = red; Green = green; } 并且，C#10的结构体也支持with关键字\nvar color = new Color(122, 255, 255); var color1 = color with { Green = 12 }; 在同一析构中进行赋值和声明 # 可以通过析构对象来给变量赋值，或是\n(int x, int y) = point;//析构对象来初始化两个变量，注意这不是元组 int x1 = 0; int y1 = 0; (x1, y1) = point;//析构对象给现有变量赋值 在C#10以前初始化和赋值不能同时进行\nint x = 0; (x, int y) = point;//C#10以前会错误 但现在不会\n","date":"2023年4月12日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/csharp10%E6%96%B0%E7%89%B9%E6%80%A7/","section":"Posts","summary":"","title":"C#10新增功能"},{"content":"\r驾驶证 # 常规 # 年龄要求： c1,c2: 18+无上限 c6:20-60 货车：20+ 有效期： 6年-\u0026gt;10年-\u0026gt;长期 体检： 中大型公交牵引车每年体检 任何限时题目： 有90日选择90日，否则选择30日 驾驶证周期： 12月 驾驶证实习期： 12月 有效期： 准考证3年内，实习期需要3年驾龄司机陪同，延期审验3年 证件相关： # 车“登记”，证随意\n驾驶证遗失损毁补领，任意地点均可 证件带有“车”字需要在登记地处理 车辆变化除防撞杆，都需要登记 不得申请驾驶证时间 # 假1骗3毒3醉5逃逸犯罪终生\n满分教育 # 现场学习至少2天，网络学习至少3天，总计至少7天 扣满每12分学习7天，小车最多60天 扣满12分重学科目1，24-35重学科目1科目3，36+重学科目123 学习减分 # 实习期内不可以参与 酒驾处罚三个周期内不能参与 两次以上满分教育不能参与 每次参与最多减六分 网络学习30分钟减1分，现场学习1小时减2分，公益活动1小时减1分 证件车辆扣留 # 缺少 驾驶证|行驶证|保险标识|检验合格标识|车牌 扣留\n刑法 # 重大事故致人死亡 - 3年 致人死亡逃逸 - 3-7年 因逃逸致人死亡 - 7年+ 组织作弊形成犯罪 - 3-7年 其他拘役 选择题：有拘役则对，有刑结尾则错\n事故处理 # 有争议则报警 无争议则撤离，不撤离罚款200 救援 # 骨折要固定，不要移动 失血先止血，止血按压近心端 燃烧喷冷水，其他会感染 顺序通行 # 常规 # 右转让左转，左转让直行 超车从左侧 特殊路段不能超车 有特殊车辆不能超车 不走公交车道 会车时 # 山体外侧先行 环岛内先行 无障碍先行 主路车先行 下坡车先行 校车 # 两车道停车等待 三车道变最左道超车 车辆故障 # 开危险警报闪光灯 防止警报标志 50 - 100m，高速路150m+ 停车距离 # 路口5站3，题中带有“路/口”（路口，道口，危险狭窄路段）则50m，带有“站”（车站，加油站）则30m\n灯光 # 雾灯：除了雾天使用，其他都错 危险警报闪光灯：停车，故障，雾天，牵引故障车 左右转向：转弯，变道，停车时打右转向，闸道进道路打左转向 远光灯：照明不足 闪烁：超车，通过路口，通过人行道，急弯道路 其他情况均为近光灯 切换远近灯光距离为150m 速度和距离 # 特殊道路 # 无标识情况，特殊道路全部为30km/h 普通道路 # 无线：“城3公4”，有线：“城5公7”\n有中心线：城市50，公路70 无中心线：城市30，公路40 高速行驶能见度 # 能见度200m：车速小于60，行车距离100m 能见度100m：车速小于40，行车距离50m 能见度小于50m：车速小于20，尽快离开 高速速度 # 100km/h：距离100m \u0026lt;100km/h：距离50m 高速限速 # 有标识优先按标识\n3车道：左11-12，中9-11，右6-9 2车道：左10-12，右6-10 停车 # 停车 # 单条斜杠：禁止长时间停车 叉：禁止停车 地面标识 # 路沿上黄线：虚线禁止长时间停车，实线禁止停车 计分 # 扣分值仅为3分的幂\n超速 # 普通道路 # 超速20%-50%，扣3分 超速50%+，扣6分 高速公路翻倍 # 超速20%-50%，扣6分 超速50%+，口12分 其他 # 大型车在高速以外超速10%-20%，扣1分 高速低于最低时速，扣3分 超员 # 大型汽车 # 超出核定人数20%以下，扣6分 超出核定人数20%以上，扣12分 七座以上载客汽车 # 超出核定人数50%以下，扣6分 超出核定人数50%-100%，扣9分 超出核定人数100%以上，扣12分 其他载客汽车 # 超出核定人数20%-50%，扣3分 超出核定人数50%-100%，扣6分 超出核定人数100%以上，扣12分 超载 # 超载30%以下，扣1分 超载30%-50%以下，扣3分 超载50%以上，扣6分 安全检验 # 校车，大型车未定期安全检查，扣3分 其他车辆扣1分 道路行驶 # 普通道路 # 不按规定回车，掉头，逆行：3分 不规避行人：3分 不规避校车：3分 借道占道：3分 闯红灯：6分 高速公路 # 不按规定车道行驶：3分 倒车，逆行：12分 违法停车：9分 占用应急车道：6分 车牌 # 不按规定安装车牌号（并非伪造遮挡）：3分 故意遮挡，伪造车牌号：9分 驾驶证 # 驾驶证被暂扣期间驾驶机动车：6分 驾驶车型不符：9分 疲劳驾驶 # 载货汽车：6分 载客汽车：9分 其他1分考点 # 违反标线 不按规定使用灯光 未系安全带 载货车长宽高超出规定 擅自改装 其他3分考点 # 接听手机 故障，事故后没有摆放标识和使用灯光 没有对校车安全隐患检查 其他6分考点 # 事故逃逸，无死亡，轻伤 ","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%85%B3%E9%94%AE%E8%AF%8D%E8%AE%B0%E5%BD%95/","section":"Posts","summary":"","title":"科目一关键词记录"},{"content":"","date":"2023年3月19日","permalink":"/Hugo-Blog-Blowfish-Theme/categories/%E5%85%B6%E4%BB%96/","section":"Categories","summary":"","title":"其他"},{"content":"","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/oop/","section":"Tags","summary":"","title":"OOP"},{"content":" 在阅读前你需要先掌握C#类的语法并了解类与对象的基本概念。\n概念 # 顾名思义面向对象编程即是将真实事物在代码中抽象地表达出来，以现实世界中解决问题的思路来解决程序上的问题。在C#中，事物的类型即为类(class)，类中定义了该事物的数据和操作数据的方法，每个事物对应着一个对象(object)。面向着对象编程即为OOP(Object-Oriented Programing)。\nOOP最大的特点即“面向对象”，整个编程的流程都是围绕着类与对象的。\n举例说明： 以经典的银行存取款例子来讲，假定一个文件中保存着你银行的余额，当你需要编写一个程序对该文件进行操作，提供存取款的功能时，传统面向过程编程的流程应该是：\n打开文件，读取余额并创建一个变量来缓存。 若要存款，则输入金额 在余额变量上加上输入的金额 将余额写入到文件 若要取款，则输入金额 在余额变量上减去输入的金额 将余额写入到文件 面向对象编程的流程应该是：\n定义一个ATM类，拥有余额字段，存款方法，取款方法 完善类方法，存款方法将输入的金额加到余额字段上，然后写入文件。取款方法将余额减去输入的金额，然后写入文件 打开文件，读取余额并创建一个ATM对象，使用余额初始化该对象。 若要存款，则调用ATM对象的存款方法 若要取款，则调用ATM对象的取款方法 OOP的优点：\n面向对象编程所作的流程明显更符合人类实际思考方式，这样能提高代码的可读性，使代码更容易理解和维护。 类与对象的封装增强了代码的复用性，减少重复的工作和开发。 面向对象增强了程序的模块化程度，减少模块之间的耦合性，提高程序灵活性和扩展性。 类的多态性实现了不同对象对同一事件的不同响应，增强了程序的多样性。 面向对象的特征 # 抽象 # 定义 # 抽象指将同类对象中提取出共性的特性，然后形成一个类(class)\n在C#中，类与类直接只能单一继承，不能继承多个类。\n例子 # 下面的代码提供了一个类的示例，将一个姓名属性和更改姓名的方法封装到一个Person类中：\npublic class Person { //姓名属性 public string Name { get; } //方法 public void ChangeName(string name) { Name = name; } } 在编程时，可以使用该类作为一个Person对象，并可以读取和更改其姓名\n抽象的好处 # 抽象化模拟了现实世界的事物和行为，提高了代码可读性。 增强了代码模块化程度 降低了代码的耦合和复杂度 封装 # 定义 # 封装指隐藏类/对象内部的状态和功能，仅通过一组公共的成员来进行访问\n对类中的成员添加访问修饰符以指定成员的访问级别。\nC#中访问修饰符有四种:\nprivate:私有，只有当前类内部的才能访问\npublic:共有，公开访问，类的内外都可以访问\nprotected:保护，只有继承自该类的类可以访问\ninternal:内部，类的内外都可以访问，但仅限当前程序集\n其中，internal修饰符可以与其他三个叠加使用，如internal public即是在当前程序集中的类内外都可以访问。\n不指定访问修饰符的类默认为private\n例子 # 下面的代码举出了访问修饰符的例子：\npublic class Person { //私有修饰符 private string name; public string GetName() { //在类的内部可以访问 return name; } } public class Program { static void Main(string[] args) { Person p = new Person(); p.name; } } 使用访问修饰符限制了类中成员的访问级别，实现隐藏成员的效果，达到封装的目的。\n封装的好处 # 类的封装可以保护类内部的数据和代码不被外部访问，提高代码的安全性 封装隐藏了类中方法/属性的实现细节，只向外暴露简单的成员，外部调用时只需要知道该成员是干什么用的，而无需知道如何实现的，简化了操作。 在修改一个类的代码时，不会影响到其他类，除非修改的是公共成员并且该成员被其他类所调用 继承 # 定义 # 根据现有抽象创建新的抽象，说人话就是在原有类的基础上进行拓展，保留原有类的所有能力，在新的一个类上创建新的功能，此操作被称为 “继承”，原有的类被称为 “父类” 或 “基类” ，继承父类的新类被称为 “子类” 或 “派生类” ，子类继承父类的行为被称为 “派生”，可以说 “子类”继承自“父类”，而“父类”派生出“子类”。\n一般，定义复杂且多种类对象时，会把它们共性的特征集成到一个父类中，将它们独有的特征划分到子类。\n在C#中，类只能有一个基类，不能多重继承。\n例子 # 下面的代码展示了类的继承关系：\n//基类 public class Person { public string Name { get; } public void ChangeName(string name) { Name = name; } } //派生类，继承了Person类 public class Employee : Person { public string Company { get; } public void ChangeCompany(string company) { Company = company; } } //派生类，继承了Person类 public class Student : Person { public string School { get; set; } } 上述代码的Employee类继承自Person类，Studnet类也继承自了Person类，它们都会继承Person类的Name属性和ChangeName方法，但它们也有自己独有的属性和方法。\nbase关键字 # 在子类中使用base关键字可以访问到父类的公开或保护内容\npublic class Employee : Person { ... public string GetName() { //使用base关键字访问父类的公开属性 return base.Name; } //使用base关键字访问父类的构造函数，如果父类的构造函数有参数，可以在这里传递 public Employee() : base() {} } sealed关键字 # 如果不想让某个类被继承，在声明类时添加sealed关键字，它阻止其他类继承该类。\n//其他类若尝试继承Boss类将会有编译错误 public sealed class Boss : Person { ... } 继承的好处 # 优化类之间的关系，减少冗余，提高代码的复用性，减少错误的可能。 提供 “多态性” 多态 # 定义 # 多态也是面向对象的核心，它指跨多个抽象以不同方式实现继承属性或方法的能力。多态的实现依赖于继承，所以必须要定义多个类并有继承关系，派生类可以各自对父类的方法实现进行修改，在调用时表现出不同的行为，大大增加编程的灵活度。在使用类时，使用多个派生类实例化出多个对象，对这些对象调用同样的基类方法，但却表现出不同的行为，这便是多态。\n下面是实现多态必要的一些概念：\n抽象类 # 将对象或已有的类更加抽象化成为一个新的类，以至于无法具体化（无法创建出该类的对象，因为过于抽象而缺少某些创建类所必要的数据或方法）。这样的类被称为抽象类，在类修饰符class前加上abstract修饰符将定义的类转换为抽象类，抽象类无法被实例化，只能称为其他类的基类。\n抽象类可以有构造函数，但是不能够使用new实例化，构造函数仅供子类使用。 虚方法 # 有时将已有类的提取成基类后，会遇到部分子类对与某些方法的实现方式不一致。在类中定义方法时加上virtual关键字，可让子类使用override关键字重写基类方法的实现。\n举一个现实中的例子：以前的所有轿车都是由燃油驱动的，它们有着“移动”行为，并且该都是以\u0026quot;燃油驱动\u0026quot;。但随着时代变化，出现了电力驱动的轿车，即使驱动原理不一样了，但它们还是有着“移动”行为。\n从编程方面来看，轿车类Car有着Move方法，该方法是“由燃油驱动的”，但出现了新的类ElectricCar电动车类，它继承自Car类，但是它对Move方法的实现却不一样，它是“电力驱动的”。此时，可以将Car类中的Move方法标记为虚方法virtual，然后在派生类中重写该方法。\n下面的类定义了一个轿车类，有着用燃油驱动的Move方法：\npublic class Car { //使用virtual关键字定义虚方法 public virtual void Move() { //用燃油驱动 ... } } 有一个类ElectricCar继承了Car类，并重写了父类的Move方法：\npublic class ElectricCar : Car { //使用override关键字重写父类的虚方法 public override void Move() { //用电力驱动 ... } } 此时使用Car类和ElectricCar类分别实例化出对象，调用Move方法，它们表现出的行为将不一致。\n... Car c = new Car(); //燃油驱动 c.Move(); ElectricCar ec = new ElectricCar(); //电力驱动，该派生类重写了Move方法 ec.Move(); ... 在类中使用virtual关键字在方法前标注，来声明一个虚方法。 在派生类中使用override关键字对父类中的虚方法进行重写，修改方法的实现过程。 如果不想完全重写虚方法，只是想要在父类的方法基础上添加代码，可以在重写时用base关键字调用父类方法。 sealed关键字也适用于虚方法，它阻止派生类重写方法。 抽象方法 # 抽象方法类似于虚方法，子类可以重写方法的实现。但是有时子类对方法的实现各不相同，无法统一出一个父类的实现方法，这个方法便被抽象化成为一个抽象方法。\n抽象方法在类的方法前使用abstract关键字定义，抽象方法没有方法体，仅定义了方法名，返回值和参数。在子类同样使用override对父类的抽象方法进行重写。\n定义了抽象方法的类必须为抽象类，因为这个类有方法没有被实现，无法实例化。\n若一个类的基类是带有抽象方法的抽象类，除非该派生类也是一个抽象类，不然就必须重写所有的抽象方法。\n再举一个例子：三角形和矩形都属于“形状”，都可以求出其面积，但它们计算面积的公式是不一样的。\n从编程方面来看，三角形和矩形可以提取出一个父类Shape（形状）类，Shape类中有一虚方法Area用于计算形状的面积。三角形Triangle类和矩形Rectangle类都继承自Shape，并且重写了Area方法。\n但这样设计的问题是，Shape类过于抽象，创建成对象是没有意义的，而且无法实现Area方法，只能留空。\n此时就可以将Shape类的Area方法标记为抽象方法，并且将Shape类标记为抽象类。抽象类无法实例化，只能用来继承，抽象方法也不需要实现，只能用来重写。\n下面的代码对抽象方法进行了示例：\n//带有抽象方法的类必须为抽象类 public abstract class Shape { //使用abstract关键字声明了一个抽象方法，没有方法体。 public abstract float Area(); } public class Triangle : Shape { //使用override关键字重写了父类的抽象方法，如果没有重写该方法，将会有编译错误 public override float Area() { ... } } public class Rectangle : Shape { public override float Area() { ... } } 抽象方法不需要方法实现，只需要定义名称，参数和返回值即可，但该类的派生类必须提供重写该抽象方法。 抽象方法的访问修饰符不能为private，因为抽象方法需要子类的实现。 若一个类拥有抽象方法，它就必须被修饰为抽象类，因为抽象方法需要一个子类提供实现。 接口 # 类抽象的极限是只包含方法，类中没有任何数据，只定义了该类的行为，这样抽象到极限的类被称为 “接口”。而继承了该类的类也不叫派生类了，它们被称为 “实现类”，而继承这一操作名也变为了 “实现”，即某类实现了某接口，定义接口的关键字不是class，变为了interface。\n接口类似于抽象类，但比抽象类更加抽象，无法定义数据，只能定义行为，而且实现接口的类都必须实现接口中定义的所有成员。\n接口一般用来定义某些行为，而不是一类事物，比如C#中的IEnumerable（可枚举）接口。某个类实现了接口，就代表它能够实现这些行为。\n在C#中，接口只能定义方法，属性，索引器和事件。 在C#中，类只能继承一个类，但允许实现多个接口，在程序中可以让类实现多个接口，以表现出各类不同的行为。在对类的功能进行拓展时，也可以添加实现的接口来让类实现相应的方法。 在C#中，接口的命名应当以字母I开头。 下面的代码展示了接口和实现类的定义：\n//使用interface关键字定义接口 public interface IMoveable { //定义接口属性 Vector2 Position { get; } //定义接口方法，无需方法体 void Move(int x, int y); } public class Car : IMoveable { //实现接口中的属性和方法 public Vector2 Position { get; } public void Move(int x, int y) { Position.x = x; Position.y = y; } } 接口定义的成员都不需要实现，实现类必须实现接口的所有成员。 接口成员可以不加访问修饰符，默认会赋予public，接口成员的访问修饰符不能为private，因为私有的接口方法没有意义。 新版本特性\n在高版本的C#，接口中的方法可以有方法体，接口中也可以定义静态抽象成员和虚拟成员，具体参考官方文档：\r接口\n替换 # 向上转换(upcasting)\n在对对象进行操作时，派生类对象的引用可以替换基类的引用：\nPerson p1 = new Person();//实例化Person对象 Employee e1 = new Employee();//实例化Employee对象 p1 = e1;//替换 上述代码演示了替换的过程，Employee类是Person类的派生，将其分别实例化出p1对象和e1对象，并将p1对象的引用替换成了e1对象。\n虽然两对象是不同类型的，但这样的替换操作是合法的，并不会有错误或警告，像这样使用派生类引用替换成基类引用的操作称为向上转换(Upcasting)。因为Employee类继承了Person类的所有数据，所以对p1对象进行的任何操作，都适用于e1对象，而不会导致任何问题。向上转换是可传递的，也就是说如果有一个类继承了Employee类，该类的对象也可以替换p1对象，因为该类也间接地继承了Person类。\n向下转换 ***向下转换(Downcasting)***和向上转换相反，即基类的引用替换派生类的引用：\nPerson p2 = new Person(); Employee e2 = new Employee(); e2 = (Employee)p2;//向下转换 上述代码演示了向下转换，向下转换是强制转换，代码中使用括号来进行强制转换，这个操作通常来说是不允许的。一个派生类可以在基类的基础上派生出新的数据成员，但这些成员并不能适用于基类对象，例如Employee类有一属性为Company，而使用Person类实例化的对象是访问不到该属性的，所以向下转换是不安全的，上述代码在运行时会报运行时错误。\n但有一种情况例外，如果转换对象是向上转换过来的，那么就不会报运行错误，例如：\nPerson e3 = new Employee();//在实例化时进行向上转换 Employee e4 = (Employee)e3;//向下转换 代码中的e3对象本身是Employee类型，但通过向上转换成了Person类型的引用，向上转换并不会清除派生类中的数据成员，所以向下转换回Employee类型时并不会报错。\n向上和向下转换也适用于抽象类和接口。\nis和as关键字\n在有些情况，向下转换操作是不可避免的。若要进行向下强制转换，可以使用C语言风格的()来强制转换，如e2 = (Employee)p2;，要是p2无法转换成e2，则会抛出异常。所以在向下转换前，通常要进行检查。\nC#提供is关键字判断对象类型，并返回true或false，在转换前使用is进行判断：\n//检查p2的类型是否是`Employee` if(p2 is Employee) { e2 = (Employee)p2; ... } C#还提供了as关键字来进行向下转换，和()的不同是，使用as转换失败并不会报错，而是返回null：\ne2 = p2 as Employee;//使用as关键字进行转换，如果失败则会返回null if(e2 == null) ...//转换失败 else ...转换成功 替换带来的多态性\n在对象向上转换过后，如果调用的方法被转换前的类型重写过，则会调用重写后的方法：\nShape t1 = new Triangle(); Shape r1 = new Rectangle(); Console.WriteLine(t1.Area()); Console.WriteLine(r1.Area()); 代码中使用Triangle类型和Rectangle类型实例化出s1和r1对象，并上转型成Shape类型，因为两个类型都重写了基类的Area方法，在调用两个对象的Area方法时，将会各自调用转换前类型调用重写后的方法，即使它们转换成了Shape类型。\n替换操作看起来会导致方法调用的混乱，但这样其实很好地运用了类的多态性。里氏替换原则提到：\n\u0026ldquo;如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致。\u0026rdquo;\n替换操作对类的通用性提升是巨大的。例如，你可以对一组继承自同一个类型的对象进行操作，它们将表现出不同的行为：\nobject[] data = { 100, \u0026#34;Alice\u0026#34;, 0.98f, Math.PI, DateTime.Now }; foreach (var obj in data) { Console.WriteLine(obj); } 上述代码使用了多个不同类型的对象初始化一个object类型的数组，在循环中，Console.WriteLine方法接收一个object类型对象，并调用对象的ToString方法，因为数组中对象的类型都各自重写了ToString方法，它们的输出将会表现出不同的效果。\n多态性的好处 # 增强了代码的通用性和简洁性，因为多态允许不同的对象执行相同的操作，但调用的方法却是同一个，这意味着程序员不需要写多个专门针对不同对象类型的方法。 增强了代码的可扩展性，当在一个较为完整的程序中添加新的对象类型，只需要选择要继承的类，实现需要的接口即可，不需要花费大量的事件思考类中有哪些成员。 面向对象五大原则（SOLID原则） # 单一职责原则，Single Responsibility Principle (SRP) # \u0026ldquo;每个模块都只有一个引起它变化的原因。\u0026rdquo;\n即一个类只负责一个功能领域的职责。单一职责原则是实现高内聚低耦合的关键，不要把太多的功能封装到类中，否则将会增加耦合度，大大降低可维护性。\n单一职责是程序设计阶段时划分类的一个好方法，只有全面了解程序的功能，才能很好地分离职责。\n开闭原则，Open/Closed Principle # “开”指对扩展开放，“闭”指对修改关闭。\n编写模块时应当尽量设计出不需要修改的模块，在扩展新功能的时候，只需要编写新的代码而无需修改旧的代码。\n满足开闭原则可以最大化模块的复用性和扩展性。\n一些设计模式很好地实现了开闭原则：如面向接口编程(Interface Based Programming)，将功能抽象成稳定的接口，在扩展代码时添加接口和实现方法即可。或是面向切面编程(AOP)，将模块分为多个层，使用事件回调等方法在层直接注入处理的代码，在添加功能时只需在需要的层中添加代码即可。\n里氏替换原则，Liskov Substitution Principle (LSP) # \u0026ldquo;如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致。\u0026rdquo;\n换句话说，派生类必须可以替换其基类。\n什么叫“与期望的行为一致”?\n“在不了解派生类的情况下，仅通过接口或基类的方法，即可清楚的知道方法的行为，而不管哪种派生类的实现，都与接口或基类方法的期望行为一致。或者说接口或基类的方法是一种契约，使用方按照这个契约来使用，派生类也按照这个契约来实现。这就是与期望行为一致的替换。”\n在运用类的多态性时，不应当违背里氏替换原则。在派生类中重写方法时，应当保证每个派生类重写方法的最终目的都是一致的，即“与期望的行为一致”。\n例如Triangle类和Rectangle类都重写了Shape类的Area方法，它们都应当保证重写后能正确返回图形的面积，而不是返回周长。\n接口隔离原则，Interface Segregation Principle (ISP) # \u0026ldquo;客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。\u0026rdquo;\n接口不应过于臃肿，尽量细化接口，减少接口中方法的数量，降低类对单个接口的依赖性。\n接口越大，它越有可能包含并非所有实现类都能使用的到的方法。如果一个类和某个接口没有一致的目的，那就不要实现那个接口。\n依赖倒置原则，Dependency Inversion Principle (DIP) # \u0026ldquo;高级模块/类不应当依赖于低级的模块/类，首先两者都应当依赖于其抽象。其次，抽象不应当依赖于实现。最后，实现应当取决于抽象。\n说人话就是，当两个模块/类有依赖关系时，首先它们都应当继承自某个类或实现某个接口。然后，在对一个派生程度较低的类进行设计时，不应当依赖于一个派生程度较高的类，应该使用其基类或是接口等派生程度较低的类进行依赖。\n当一个类依赖于另一个类的一个明确的实现时，如果依赖类的实现改变了，当前类可能会被破坏。因此，在对一个功能进行依赖时，应当面向抽象编程，而不是面向实现。\n总结 # 面向对象为编程提供了一个很好的思路，遵循SOLID原则可以构建一个代码整洁，可读性高，且易于维护的应用程序，但过于追求这些繁文缛节可能会大幅增加代码量。规则是死的人是活的，在进行编程时必须权衡这些规则带来的代码质量和代码数量，毕竟，20行代码可比200行代码要少得多。\n参考内容\n类继承：Stephen Prata. C++ Primer Plus.\nC#面向对象：\rhttps://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/oop\nC#接口：\rhttps://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface\nC#默认接口方法：\rhttps://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods SOLID原则：\rhttps://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/\n里氏替换原则：\rhttps://zhuanlan.zhihu.com/p/268574641\n","date":"2023年3月17日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B-csharp/","section":"Posts","summary":"","title":"面向对象的编程（C#）"},{"content":"\r.NET 表达式树 # .NET Expression表达式树将代码抽象成了一颗对象树，树上的每一个节点都是一个代码表达式，它的构造类似编译原理中的抽象语法树（AST）。\n可以使用lambda表达式进行声明表达式树，编译器将会自动转换，但是该lambda表达式不能是语句（即表达式只能有一句，不能用{}组成多句）。\n表达式树可以转换为委托，在一些linq场景可以通过构建表达式树来动态拼接一些linq查询条件。\n表达式树入门 # 一个表达式树是类似以下的结构\n表达式C\r| +-----+-----+\r| |\r表达式A 表达式B 比如简单的lambda表达式x =\u0026gt; x + 1可以用转化为以下表达式\nx + 1\r|\r+---+---+\r| |\rx 1 其中叶子节点x为变量表达式，叶子节点1为常量表达式，x+1节点为二叉表达式，使用了+运算符\n在C#中，表达式树可以通过Expression及其派生类的各种方法手动构建，Exression类常用的静态方法如下：\nExpression.Constant() 创建一个常量表达式。 Expression.Variable() 创建一个变量表达式。 Expression.New() 创建一个实例化表达式。 Expression.Assaign() 创建一个赋值表达式。 Expression.Equal() 创建一个相等比较表达式。 Expression.Call() 创建一个方法调用表达式。 Expression.Condition() 创建一个分支逻辑表达式。 Expression.Loop() 创建一个循环逻辑表达式。 Expression.Add()/Subtract()/Multiply()/Divide() 加/减/乘/除表达式\n\u0026hellip; 使用C#代码构造简单的表达式树 # x =\u0026gt; x + 1\npublic static void Example1() { var param1 = Expression.Variable(typeof(int), \u0026#34;x\u0026#34;);//声明变量表达式，类型为int，参数名为\u0026#34;x\u0026#34; var const1 = Expression.Constant(1);//常量表达式 var biExpr = Expression.Add(param1, const1);//声明进行加法运算的二叉表达式，左节点为x,右节点为1 //x =\u0026gt; x + 1表达式树就构成了 //使用Expression.Lambda方法可以将表达式树转换为lambda表达式树，在类型参数中可以指定转换的委托类型 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;int, int\u0026gt;\u0026gt;(biExpr, param1);//lambda输入参数为x变量 //使用LambdaExpression.Compile方法将转换好的lambda表达式树编译成委托 Func\u0026lt;int,int\u0026gt; func = lambdaExpr.Compile(); //调用编译出的委托 Console.WriteLine(func(5)); } 更复杂一些的表达式树 # (a,b,c) =\u0026gt; (a + b + c) / 3\npublic static void Example2() { var param1 = Expression.Variable(typeof(int), \u0026#34;a\u0026#34;); var param2 = Expression.Variable(typeof(int), \u0026#34;b\u0026#34;); var param3 = Expression.Variable(typeof(int), \u0026#34;c\u0026#34;); var const1 = Expression.Constant(3.0f,typeof(float)); var biExpr1 = Expression.Add(param1, param2);//构造参数1，2，生成加法表达式树1 var biExpr2 = Expression.Add(biExpr1, param3);//构造加法表达式树1和参数3，生成加法表达式树2 var biExpr3 = Expression.Convert(biExpr2, typeof(float));//两整形相除不会保留小数，转化为浮点型 var biExpr4 = Expression.Divide(biExpr3, const1);//构造加法表达式树2和常量表达式1，生成除法表达式树3 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;int,int,int,float\u0026gt;\u0026gt;(biExpr4, param1,param2,param3);//根据表达式树3和三个参数，将表达式树转换为lambda表达式树 var func = lambdaExpr.Compile(); Console.WriteLine(func(2, 3, 3)); } 方法调用表达式 # (str,value) =\u0026gt; !string.IsNullOrWhiteSpace(str) \u0026amp;\u0026amp; str.Contains(value)\npublic static void Example3() { var param1 = Expression.Variable(typeof(string), \u0026#34;str\u0026#34;); var param2 = Expression.Variable(typeof(string), \u0026#34;value\u0026#34;); //使用反射获取静态方法，并与参数表达式构造成方法调用表达式 var callExpr1 = Expression.Not(Expression.Call(typeof(string).GetMethod(nameof(string.IsNullOrWhiteSpace), new Type[]{typeof(string)})!, param2)); //使用反射获取实例方法，实例方法需要指定调用实例的表达式 var callExpr2 = Expression.Call(param1, typeof(string).GetMethod(nameof(string.Contains), new[] {typeof(string)} )!, param2); var biExpr1 = Expression.AndAlso(callExpr1, callExpr2);//与运算 var lambdaExpr = Expression.Lambda\u0026lt;Func\u0026lt;string,string,bool\u0026gt;\u0026gt;(biExpr1, param1,param2); var func = lambdaExpr.Compile(); Console.WriteLine(func(\u0026#34;Azusa\u0026#34;, \u0026#34;s\u0026#34;)); } 一些实际的应用 # /// \u0026lt;summary\u0026gt; /// 推断实体属性的特性和名称，并根据搜索关键字构建过滤器表达式树 /// 注意，反射推断比较消耗性能 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;keyword\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static Expression\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt; BuildKeywordSearchExpression(string keyword) { //获取实体类所有公用|实例属性 var propInfos = typeof(TEntity).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.GetProperty); //获取所有具有SearchKeywordAttribute特性的属性，作为目标属性 var targetProps = propInfos.Where(info =\u0026gt; info.GetCustomAttribute\u0026lt;SearchKeywordAttribute\u0026gt;() is not null); //如果没有任何属性带SearchKeywordAttribute则按照属性名匹配，如果符合\u0026#34;name\u0026#34;或是\u0026#34;title\u0026#34;或是\u0026#34;content\u0026#34;，那就作为目标属性 if (!targetProps.Any()) targetProps = propInfos.Where(info =\u0026gt; info.Name.ToUpper() is \u0026#34;NAME\u0026#34; or \u0026#34;TITLE\u0026#34; or \u0026#34;CONTENT\u0026#34;); //没有任何属性能够匹配则异常 if (!targetProps.Any()) throw new ServerErrorException(\u0026#34;没有任何能够进行过滤查询的属性，请在属性上添加[SearchKeywordAttribute]启用过滤\u0026#34;); //检查属性是否为字符串类型 if (!targetProps.All(info =\u0026gt; info.PropertyType == typeof(string))) throw new ServerErrorException(\u0026#34;过滤属性必须是字符串\u0026#34;); //构建 e =\u0026gt; (e.Name || Title || Content || [property with attribute]).Contain(keyword) 表达式树 //参数e表达式 var entityExpr = Expression.Parameter(typeof(TEntity),\u0026#34;entity\u0026#34;); //常量关键词表达式 var keywordExpr = Expression.Constant(keyword); //所有目标属性的表达式 var propExprs = targetProps.Select(info =\u0026gt; Expression.Property(entityExpr,info)).ToArray(); //所有的属性调用.Contain(keyword)并且进行或运算 var firstProp = propExprs.First(); Expression resultExpr = Expression.Call(firstProp, typeof(string).GetMethod(nameof(string.Contains), new[] { typeof(string) })!, keywordExpr); for (int i = 1; i \u0026lt; propExprs.Length; i++) { var containsExpr = Expression.Call(propExprs[i], typeof(string).GetMethod(nameof(string.Contains), new[] { typeof(string) })!, keywordExpr); resultExpr = Expression.Or(resultExpr,containsExpr); } //构造成委托 var lambda = Expression.Lambda\u0026lt;Func\u0026lt;TEntity, bool\u0026gt;\u0026gt;(resultExpr, entityExpr); Console.WriteLine(lambda.ToString()); return lambda; } 上述代码根据所给的关键词，使用反射搜索类型参数中的TEntity类型的属性，探测带有SearchKeywordAttribute特性或是名为\u0026quot;Name\u0026quot;,\u0026quot;Title\u0026ldquo;或是\u0026rdquo;Content\u0026ldquo;的属性，并使用它们构造一个用于多个属性模糊查询的表达式树，返回一个Expression\u0026lt;Func\u0026lt;TEntity,bool\u0026gt;\u0026gt;表达式委托。\n这样的一个表达式可以自动地识别某个实体类的属性，并且根据这些属性通过Linq对IQuerable进行模糊查询，例如：\npublic class Post : IEntity\u0026lt;Guid\u0026gt;,IHasCreationTime,IHasModificationTime { public Guid Id { get; set; } [SearchKeyword] public string Title { get; set; } [SearchKeyword] public string Markdown { get; set; } public Guid? CategoryId { get; set; } public Category? Category { get; set; } public ICollection\u0026lt;Tag\u0026gt; Tags { get; set; } public DateTime CreationTime { get; set; } public DateTime? LastModificationTime { get; set; } private Post() { }//EFCore public Post(string title, string markdown = \u0026#34;\u0026#34;, Category? category = null, ICollection\u0026lt;Tag\u0026gt;? tags = null) { Id = SequentialGuidGenerator.Create(); Title = title; Markdown = markdown; Category = category; Tags = tags ?? new List\u0026lt;Tag\u0026gt;(); } } public Task\u0026lt;List\u0026lt;Post\u0026gt;\u0026gt; SearchAsync(string keyword) { return dbContext.Posts.Where(BuildKeywordSearchExpression(keyword)).ToListAsync(); } 方法中将根据实体属性上的特性自动生成 post =\u0026gt; post.Title.Contains(keyword) || post.Markdown.Contains(keyword) 表达式，并通过IQuerable和EFCore生成SQL语句对实体进行查询。\ninfo: 2023/4/24 23:30:37.812 RelationalEventId.CommandExecuted[20101] (Microsoft.EntityFrameworkCore.Database.Command) Executed DbCommand (22ms) [Parameters=[], CommandType=\u0026#39;Text\u0026#39;, CommandTimeout=\u0026#39;30\u0026#39;] SELECT [t].[Id], [t].[CategoryId], [t].[CreationTime], [t].[LastModificationTime], [t].[Markdown], [t].[Title] FROM [T_Posts] AS [t] WHERE (CASE WHEN [t].[Title] LIKE N\u0026#39;%net%\u0026#39; THEN CAST(1 AS bit) ELSE CAST(0 AS bit) END | CASE WHEN [t].[Markdown] LIKE N\u0026#39;%net%\u0026#39; THEN CAST(1 AS bit) ELSE CAST(0 AS bit) END) = CAST(1 AS bit) 参考文章\nhttps://masuit.com/1795?t=vou0ts7ora4g#%CE%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95 https://cloud.tencent.com/developer/article/1817790 ","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/net-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E5%85%A5%E9%97%A8/","section":"Posts","summary":"","title":".NET 表达式树入门"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/linq/","section":"Tags","summary":"","title":"Linq"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/asp-.net-core/","section":"Tags","summary":"","title":"ASP .NET Core"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/swagger/","section":"Tags","summary":"","title":"Swagger"},{"content":"","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/web-api/","section":"Tags","summary":"","title":"Web API"},{"content":"\rSwagger文档 # 在ASP .NET Core项目中配置Swagger服务，在Swagger页面的接口中显示C#代码的注释。\nSwagger上的注释\r微软官方文档\n先决条件： 项目需要在Nuget中安装Swashbuckle.AspNetCore包（一般会在ASP .NET Core项目创建时自动安装）\n生成并导出XML文档 # 首先需要生成项目的XML文档。以 Visual Studio 为例，在项目属性-输出中勾选“生成包含API文档的文件”，并指定输出目录：\nVS中生成XML文档\r接着生成项目，会在指定目录下输出XML文档：\n输出的XML文档\r配置Swagger服务 # 在 StartUp 中配置服务\nprogram.cs\n//安装Nuget包后即可使用AddSwaggerGen方法添加Swagger服务 services.AddSwaggerGen(options =\u0026gt; { //定义Swagger文档，可多次定义以区分版本 //此时定义的文档名为v1 options.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo() { //添加一些API信息，将会呈现在Swagger页面上 Version = \u0026#34;v1\u0026#34;, Title = \u0026#34;用户信息控制器\u0026#34;, }); //指定XML文档的目录 options.IncludeXmlComments($\u0026#34;{Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}\\\\{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;, true); ... }); 配置Swagger中间件 # 在ASP .NET Core入口函数中配置中间件\nprogram.cs\n... var app = builder.Build(); //此时在开发环境下才会添加Swagger中间件 if (app.Environment.IsDevelopment()) { //添加Swagger中间件 app.UseSwagger(); //添加SwaggerUI中间件，在参数中指定Swagger终结点，终结点错误将会导致接口无法正常显示 //此时使用终结点是步骤2中声明的名为\u0026#34;v1\u0026#34;文档，如果定义了多个文档版本，则需要指定多个终结点 app.UseSwaggerUI(c =\u0026gt; c.SwaggerEndpoint(\u0026#34;/swagger/v1/swagger.json\u0026#34;, \u0026#34;Gehenna.WebAPI v1\u0026#34;)); } 如果使用IIS 或反向代理的路径，请使用 ./ 前缀将 Swagger 终结点设置为相对路径。 例如 ./swagger/v1/swagger.json。\n使用 /swagger/v1/swagger.json 指示应用在 URL 的真实根目录中查找 JSON 文件（如果使用，加上路由前缀）。例如，请使用 https://localhost:\u0026lt;port\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/v1/swagger.json 而不是 https://localhost:\u0026lt;port\u0026gt;/\u0026lt;virtual_directory\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/v1/swagger.json。\n配置完成 # 在API控制器类或终结点方法上添加XML注释。\n给控制器上添加注释\r给控制器操作方法添加注释\r配置完成后，访问https://localhost:\u0026lt;port\u0026gt;/\u0026lt;route_prefix\u0026gt;/swagger/index.html页面上即可进入Swagger界面。\n页面的标题文字将显示配置Swagger服务时提供的数据。\nSwagger页面标题\r页面右上方的下拉框可以选择在步骤2/3中定义的Swagger的版本\nSwagger版本\r页面中将会显示控制器，API终结点方法的注释 接口注释\r如果给方法参数添加了注释，Swagger也会显示出来 方法参数的注释\r如果请求/响应的数据模型有添加注释，点击scheme显示 请求/响应模型注释\r在使用泛型作为API响应数据模型时显示注释 # //待补充\n参考文章：https://learn.microsoft.com/zh-cn/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-7.0\u0026amp;tabs=visual-studio\n","date":"2023年3月15日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E5%9C%A8asp-.net-core%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AEswagger%E6%96%87%E6%A1%A3/","section":"Posts","summary":"","title":"在ASP .NET Core项目配置Swagger文档"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/javascript/","section":"Tags","summary":"","title":"Javascript"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/signalr/","section":"Tags","summary":"","title":"SignalR"},{"content":"","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/tags/websocket/","section":"Tags","summary":"","title":"Websocket"},{"content":"在使用SignalR向.NET后端进行实时通信时，时常会使用 AccessToken 进行用户授权。提供用户认证可以提高后端接口的安全性，并且可以利用SignalR的用户认证机制来向指定用户的所有SignalR连接发送消息。\n后端用户授权服务 # 在 ASP.NET Core 中添加授权机制： # Program.cs ... services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //此处使用JWTBearer进行授权验证 .AddJwtBearer(options =\u0026gt; { var secretKey = configurations.GetRequiredSection(\u0026#34;Jwt\u0026#34;).Get\u0026lt;JwtOption\u0026gt;().SecretKey??throw new ConfigurationErrorsException(\u0026#34;Jwt密钥未配置\u0026#34;); options.TokenValidationParameters = new() { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)), }; }); ... //添加认证机制需要引用Authentication与Authorization两个中间件 app.UseAuthentication(); app.UseAuthorization(); ... 在SignalR集线器类上添加Authorize特性 # 详细的授权信息与不同的授权规则参考\rASP.NET Core授权\n//添加授权 [Authorize] public class ChatHub : Hub { public override async Task OnConnectedAsync() { await base.OnConnectedAsync(); //在Hub类的Context.User属性中可以获取到SignalR通过websocket握手获取到的用户授权信息 await Console.Out.WriteLineAsync(Context.User.Identity.Name); } ... } 这样就为ASP .NET Core提供了基本的用户授权机制，在应用的终结点(endPoints)上添加[Autorize]特性来对此终结点进行用户授权。\n在客户端配置SignalR连接的访问令牌 # C#客户端 # ... _connection = new HubConnectionBuilder() .WithAutomaticReconnect() //在WithUrl方法的configureHttpConnection参数中配置 .WithUrl(HubUrl, options =\u0026gt; { //为AccessTokenProvider提供获取访问令牌的委托 //此处为应当查找并获取用户访问令牌的逻辑 options.AccessTokenProvider = () =\u0026gt; Task.FromResult(authorizationToken); }); .ConfigureLogging(builder =\u0026gt; builder.AddConsole()) .Build(); await _connection.StartAsync(); ... Javascript客户端 # ... this.hubConnection = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;this.hubUrl\u0026#34;,{ //为withUrl方法参数2的accessTokenFactory属性提供获取访问令牌的方法 accessTokenFactory: () =\u0026gt; this.getAccessToken(), skipNegotiation: true, transport: signalR.HttpTransportType.WebSockets }) .build(); await this.hubConnection.start(); ... 踩坑注意 # 在Javascript客户端，即使配置了访问令牌，在对后端SignalR集线器进行访问时服务器仍然会响应 401 Unauthorized 或是客户端抛出 SignalR Error: Failed to complete negotiation with the server 异常，若排除了Javascript客户端配置问题或是CORS跨域访问问题，则有可能是因为Javascript websocket API不支持设置请求报文头的原因。\n客户端使用HTTP协议向服务器进行访问令牌验证常用的方式是在报文头中添加 Authorization 标头，并提供访问令牌字符串。 请求标头中的Authorization项\r在SignalR进行Websocket连接前会进行协商(negotiation)，若客户端在建立SignalR连接时配置了访问令牌，则会在请求时附带上访问令牌。\n但在SignalR Javascript客户端进行协商时，访问令牌并不是添加在报文头中，而是以查询字符串的形式发送请求。 访问令牌放在了查询字符串中\rASP.NET Core并不会自动对查询字符串中的访问令牌进行授权，所以此时服务器将会返回 401 Unauthorized ，而Javascript客户端会抛出 SignalR Error: Failed to complete negotiation with the server (无法完成与服务器的协商） 异常。\n解决方法： # 在服务器端配置授权机制，在收到请求消息时手动进行授权处理。配置的方式有多种，较为简单的方式是直接在Authorization服务中添加事件：\nprogram.cs ... services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) //使用JwtBearer作为认证令牌 .AddJwtBearer(options =\u0026gt; { var secretKey = configurations.GetRequiredSection(\u0026#34;Jwt\u0026#34;).Get\u0026lt;JwtOption\u0026gt;().SecretKey??throw new ConfigurationErrorsException(\u0026#34;Jwt密钥未配置\u0026#34;); options.TokenValidationParameters = new() { ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)), }; //添加授权事件，在收到请求消息时进行处理 options.Events = new JwtBearerEvents() { OnMessageReceived = context =\u0026gt; { //从请求查询字符串中取出访问令牌 var accessToken = context.Request.Query[\u0026#34;access_token\u0026#34;]; //请求条件不符合则返回 if (!string.IsNullOrEmpty(accessToken) \u0026amp;\u0026amp; context.Request.Headers[\u0026#34;Upgrade\u0026#34;] == \u0026#34;websocket\u0026#34;) { //手动对上下文中的令牌属性赋值，剩下的授权由.NET自动完成 context.Token = accessToken; } return Task.CompletedTask; } }; }); ... 参考文章\nhttps://stackoverflow.com/questions/21260384/signalr-authenticating-with-access-token#comment32085907_21260384\n","date":"2023年3月11日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/%E4%B8%BAsignalr%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/","section":"Posts","summary":"","title":"为SignalR的连接配置用户认证"},{"content":"\r测试帖子 # 使用Hugo超快速建站\nHugo首页\nhugo new site Azusa\u0026rsquo;s Archive\n","date":"2023年3月10日","permalink":"/Hugo-Blog-Blowfish-Theme/posts/hellow-world/hello-world/","section":"Posts","summary":"","title":"Hello World"},{"content":"","date":"0001年1月 1日","permalink":"/Hugo-Blog-Blowfish-Theme/authors/","section":"Authors","summary":"","title":"Authors"}]