---
title: "面向对象的编程（C#）"
date: 2023-03-17T15:31:41+08:00
tags: ["OOP","C#基础"]
categories: ["C#"]
---

## 面向对象的编程
### 概念
顾名思义面向对象编程即是将真实事物在代码中抽象地表达出来，以现实世界中解决问题的思路来解决程序上的问题。在C#中，事物的类型即为**类(class)**，类中定义了该事物的数据和操作数据的方法，每个事物对应着一个**对象(object)**。面向着对象编程即为**OOP(Object-Oriented Programing)**。

---

OOP最大的特点即“面向对象”，整个编程的流程都是围绕着类与对象的。  
举例说明：
以经典的银行存取款例子来讲，假定一个文件中保存着你银行的余额，当你需要编写一个程序对该文件进行操作，提供存取款的功能时，传统面向过程编程的流程应该是：
>- 打开文件，读取余额并创建一个变量来缓存。  
>- 若要存款，则输入金额  
>- 在余额变量上加上输入的金额  
>- 将余额写入到文件  
>- 若要取款，则输入金额  
>- 在余额变量上减去输入的金额  
>- 将余额写入到文件  
  
面向对象编程的流程应该是：
>- 定义一个ATM类，拥有余额字段，存款方法，取款方法  
>- 完善类方法，存款方法将输入的金额加到余额字段上，然后写入文件。取款方法将余额减去输入的金额，然后写入文件  
>- 打开文件，读取余额并创建一个ATM对象，使用余额初始化该对象。  
>- 若要存款，则调用ATM对象的存款方法  
>- 若要取款，则调用ATM对象的取款方法  

---

OOP的优点：  
>- 面向对象编程所作的流程明显更符合人类实际思考方式，这样能提高代码的可读性，使代码更容易理解和维护。
>- 类与对象的封装增强了代码的复用性，减少重复的工作和开发。
>- 面向对象增强了程序的模块化程度，减少模块之间的耦合性，提高程序灵活性和扩展性。
>- 类的**多态性**实现了不同对象对同一事件的不同响应，增强了程序的多样性。  

--- 

### 面向对象的特征
#### 抽象
抽象指将同类对象中提取出共性的特性，然后形成一个**类(class)**  
在C#中，类与类直接只能单一继承，不能继承多个类。  
下面的代码提供了一个**类**的示例，将一个姓名属性和更改姓名的方法封装到一个`Person`类中：
```
public class Person
{
    //姓名属性
    public string Name { get; }

    //方法
    public void ChangeName(string name)
    {
        Name = name;
    }
}
```
在编程时，可以使用该类作为一个`Person`对象，并可以读取和更改其姓名

*抽象的好处*：  
>- 抽象化模拟了现实世界的事物和行为，提高了代码可读性。
>- 增强了代码模块化程度
>- 降低了代码的耦合和复杂度

---  

#### 封装
封装指隐藏类/对象内部的状态和功能，仅通过一组公共的成员来进行访问   
对类中的成员添加访问修饰符以指定成员的访问级别。  
C#中访问修饰符有四种:  
`private`:私有，只有当前类内部的才能访问  
`public`:共有，公开访问，类的内外都可以访问  
`protected`:保护，只有**继承**自该类的类可以访问  
`internal`:内部，类的内外都可以访问，但仅限当前程序集  
其中，internal修饰符可以与其他三个叠加使用，如internal public即是在当前程序集中的类内外都可以访问。  
不指定访问修饰符的
下面的代码举出了访问修饰符的例子：
```
public class Person
{
    //私有修饰符
    private string name;

    public string GetName()
    {
        //在类的内部可以访问
        return name;
    }
}

public class Program
{
    static void Main(string[] args)
    {
        Person p = new Person();
        p.name;
    }
}
```
使用访问修饰符限制了类中成员的访问级别，实现隐藏成员的效果，达到封装的目的。

*封装的好处*:  
>- 类的封装可以保护类内部的数据和代码不被外部访问，提高代码的安全性  
>- 封装隐藏了类中方法/属性的实现细节，只向外暴露简单的成员，外部调用时只需要知道该成员是干什么用的，而无需知道如何实现的，简化了操作。
>- 在修改一个类的代码时，不会影响到其他类，除非修改的是公共成员并且该成员被其他类所调用  

---  

#### 继承
根据现有抽象创建新的抽象，说人话就是在原有类的基础上进行拓展，保留原有类的所有能力，在新的一个类上创建新的功能，此操作被称为 **“继承”**，原有的类被称为 **“父类”** 或 **“基类”** ，继承父类的新类被称为 **“子类”** 或 **“派生类”** ，子类继承父类的行为被称为 **“派生”**，可以说 **“子类”继承自“父类”，而“父类”派生出“子类”**。

一般，定义复杂且多种类对象时，会把它们共性的特征集成到一个父类中，将它们独有的特征划分到子类。  
下面的代码展示了类的继承关系：
```
//基类
public class Person
{
    public string Name { get; }

    public void ChangeName(string name)
    {
        Name = name;
    }
}

//派生类，继承了Person类
public class Employee : Person
{
    public string Company { get; }
    
    public void ChangeCompany(string company)
    {
        Company = company;
    }
}

//派生类，继承了Person类
public class Student : Person
{
    public string School { get; init; }
}

public class 
```
上述代码的`Employee`类继承自`Person`类，`Studnet`类也继承自了`Person`类，它们都会继承`Person`类的`Name`属性和`ChangeName`方法，但它们也有自己独有的属性和方法。

***base关键字***  
在子类中使用base关键字可以访问到父类的公开或保护内容
```
public class Employee : Person
{
    ...
    public string GetName()
    {
        //使用base关键字访问父类的公开属性
        return base.Name;
    }

    //使用base关键字访问父类的构造函数
    public Employee() : base()
    {}
}
```

*继承的好处*:
>- 优化类之间的关系，减少冗余，提高代码的复用性，减少错误的可能。
>- 提供 **“多态性”**


---  

#### 多态
多态也是面向对象的核心，它指跨多个抽象以不同方式实现继承属性或方法的能力。多态的实现依赖于**继承**，所以必须要定义多个类并有继承关系，派生类可以各自对父类的方法实现进行修改，在调用时表现出不同的行为，大大增加编程的灵活度。在使用类时，使用多个派生类实例化出多个对象，对这些对象调用同样的基类方法，但却表现出不同的行为，这便是多态。

下面是实现多态必要的一些概念：

- ***抽象类***  
    将对象或已有的类**更加抽象化**成为一个新的类，以至于无法具体化（无法创建出该类的对象，因为过于抽象而缺少某些创建类所必要的数据或方法）。这样的类被称为抽象类，在类修饰符`class`前加上`abstract`修饰符将定义的类转换为抽象类，抽象类无法被实例化，只能称为其他类的**基类**。   

    - 抽象类可以有构造函数，但是不能够使用new实例化，构造函数仅供子类使用。

- ***虚方法***  
    有时将已有类的提取成基类后，会遇到部分子类对与某些方法的实现方式不一致。在类中定义方法时加上`virtual`关键字，可让子类使用`override`关键字重写基类方法的实现。

    举一个现实中的例子：在以前，所有轿车都是由燃油驱动的，它们有着“移动”行为，并且该都是以燃油驱动。但随着时代变化，出现了电力驱动的轿车，即使驱动原理不一样了，但它们还是有着“移动”行为。  
    从编程方面来看，轿车类`Car`有着`Move`方法，该方法是“由燃油驱动的”，但出现了新的类`ElectricCar`电动车类，它继承自`Car`类，但是它对`Move`方法的实现却不一样，它是“电力驱动的”。此时，`ElectricCar`重写了基类的`Move`方法，使用自己的方法重新实现了`Move`方法。
    
    下面的类定义了一个轿车类，有着用燃油驱动的`Move`方法：
    ```
    public class Car
    {
        //使用virtual关键字定义虚方法
        public virtual void Move()
        {
            //用燃油驱动
            ...
        }
    }
    ```
    有一个类`ElectricCar`继承了`Car`类，并重写了父类的`Move`方法：
    ```
    public class ElectricCar : Car
    {
        //使用override关键字重写父类的虚方法
        public override void Move()
        {
            //用电力驱动
            ...
        }
    }
    ```

    此时使用`Car`类和`ElectricCar`类分别实例化出对象，调用`Move`方法，它们表现出的行为将不一致。
    ```
    ...
    Car c = new Car();
    //燃油驱动
    c.Move();
    ElectricCar ec = new ElectricCar();
    //电力驱动
    ec.Move();
    ...
    ```
    - 在类中使用`virtual`关键字在方法前标注，来声明一个虚方法。
    - 在派生类中使用`override`关键字对父类中的虚方法进行重写，修改方法的实现过程。
    - 如果不想完全重写虚方法，只是想要在父类的方法基础上添加代码，可以在重写时用`base`关键字调用父类方法。


- ***抽象方法***  
    抽象方法类似于**虚方法**，子类可以**重写**方法的实现。但是有时子类对方法的实现各不相同，无法统一出一个父类的实现方法，这个方法便被抽象化成为一个**抽象方法**。  
    抽象方法在类的方法前使用`abstract`关键字定义，抽象方法没有方法体，仅定义了方法名，返回值和参数。在子类同样使用`override`对父类的抽象方法进行重写。  
    定义了抽象方法的类必须为**抽象类**，因为这个类有方法没有被实现，无法实例化。  
    若派生类的基类是带有抽象方法的抽象类，除非该派生类也是一个抽象类，不然就必须重写所有的抽象方法。

    举一个现实中的例子：所有飞机都可以**飞行**，但若按照动力装置来分类，飞机分为螺旋桨式飞机和喷气式飞机，它们对**飞行**的实现方式不一致，无法统一出一个**飞行**的实现。但即便如此，它们都实现了**飞行**这一行为。  
    以编程方面来看，定义一个基类为Plane，并有飞行方法，并有子类JetPlane继承并重写了该方法。
    ```
    //带有抽象方法的类必须为抽象类
    public abstract class Plane
    {
        //使用abstract关键字声明了一个抽象方法，没有方法体。
        public abstract void Fly();
    }
    public class JetPlane : Plane
    {
        //使用override关键字重写了父类的抽象方法。
        public override void Fly()
        {
            ...
        }
    }

    ```

    - 抽象方法不需要方法实现，只需要定义名称，参数和返回值即可，但该类的派生类必须提供**重写**该抽象方法。  
    - 抽象方法的访问修饰符不能为`private`，因为抽象方法需要子类的实现。  
    - 若一个类拥有抽象方法，它就必须被修饰为**抽象类**，因为抽象方法需要一个子类提供实现。
    
    
- ***接口***  
    抽象的极限是只包含方法，类中没有任何数据，只定义了该类的行为，这样抽象到极限的类被称为 **“接口”**。而**继承**了该类的类也不叫**派生类**了，它们被称为 **“实现类”**，而继承这一操作名也变为了 **“实现”**，即某类**实现了**某接口，定义接口的关键字不是`class`，变为了`interface`。    
    接口类似于抽象类，但比抽象类更加抽象，无法定义数据，只能定义行为，而且实现接口的类都必须实现接口中定义的**所有成员**。  
    在C#中，接口只能定义*方法，属性，索引器和事件*。  
    在C#中，类只能继承一个类，但允许实现多个接口，在程序中可以让类实现多个接口，以表现出各类不同的行为。在对类的功能进行拓展时，也可以添加实现的接口来让类实现相应的方法。

    下面的代码展示了接口和实现类的定义：
    ```
    //使用interface关键字定义接口
    public interface IMoveable
    {
        //定义接口属性
        Vector2 Position { get; }
        //定义接口方法，无需方法体
        void Move(int x, int y);
    } 

    public class Car : IMoveable
    {
        //实现接口中的属性和方法
        public Vector2 Position { get;  }
        public void Move(int x, int y)
        {
            Position.x = x;
            Position.y = y;
        }
    }
    ```

    - 接口定义的成员都不需要实现，实现类必须实现接口的所有成员。
    - 接口成员可以不加访问修饰符，默认会赋予`public`，接口成员的访问修饰符不能为`private`，因为私有的接口方法没有意义。

    **新版本特性**  
    在高版本的C#，接口中的方法可以有方法体，接口中也可以定义静态抽象成员和虚拟成员，具体参考官方文档：[接口](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface)  


---

利用继承和重写，让不同派生类对象在同样的调用方式下表现出不同的行为，表现出了对象的多态性，允许程序员更加灵活的方式组件模块，编写代码。
*多态性的好处*：
>- 增强了代码的通用性和简洁性，因为多态允许不同的对象执行相同的操作，但调用的方法却是同一个，这意味着程序员不需要写多个专门针对不同对象类型的方法。
>- 增强了代码的可扩展性，当在一个较为完整的程序中添加新的对象类型，只需要选择要继承的类，实现需要的接口即可，不需要花费大量的事件思考类中有哪些成员。

### 面向对象七大原则
1. 开闭原则  
2. 单一原则  
3. 接口隔离原则
4. 里氏替换原则
5. 依赖倒置原则
6. 迪米特法则
7. 聚合复用原则

**参考内容**  
> Stephen Prata. C++ Primer Plus.  
> C#面向对象 https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/oop
> C#接口 https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface  
> C#默认接口方法 https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods  
> C#面向对象（三）：多态 https://www.cnblogs.com/qixinbo/p/8244583.html
> 面向对象大原则 https://zhuanlan.zhihu.com/p/89833731