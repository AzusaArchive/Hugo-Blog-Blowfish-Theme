---
title: "面向对象的编程（C#）"
date: 2023-03-17T15:31:41+08:00
tags: ["OOP","CSharp基础"]
categories: [".NET"]
---

> 在阅读前你需要先掌握C#类的语法并了解类与对象的基本概念。
## 概念
顾名思义面向对象编程即是将真实事物在代码中抽象地表达出来，以现实世界中解决问题的思路来解决程序上的问题。在C#中，事物的类型即为**类(class)**，类中定义了该事物的数据和操作数据的方法，每个事物对应着一个**对象(object)**。面向着对象编程即为**OOP(Object-Oriented Programing)**。

---

OOP最大的特点即“面向对象”，整个编程的流程都是围绕着类与对象的。  
举例说明：
以经典的银行存取款例子来讲，假定一个文件中保存着你银行的余额，当你需要编写一个程序对该文件进行操作，提供存取款的功能时，传统面向过程编程的流程应该是：
>- 打开文件，读取余额并创建一个变量来缓存。  
>- 若要存款，则输入金额  
>- 在余额变量上加上输入的金额  
>- 将余额写入到文件  
>- 若要取款，则输入金额  
>- 在余额变量上减去输入的金额  
>- 将余额写入到文件  
  
面向对象编程的流程应该是：
>- 定义一个ATM类，拥有余额字段，存款方法，取款方法  
>- 完善类方法，存款方法将输入的金额加到余额字段上，然后写入文件。取款方法将余额减去输入的金额，然后写入文件  
>- 打开文件，读取余额并创建一个ATM对象，使用余额初始化该对象。  
>- 若要存款，则调用ATM对象的存款方法  
>- 若要取款，则调用ATM对象的取款方法  

---

OOP的优点：  
>- 面向对象编程所作的流程明显更符合人类实际思考方式，这样能提高代码的可读性，使代码更容易理解和维护。
>- 类与对象的封装增强了代码的复用性，减少重复的工作和开发。
>- 面向对象增强了程序的模块化程度，减少模块之间的耦合性，提高程序灵活性和扩展性。
>- 类的**多态性**实现了不同对象对同一事件的不同响应，增强了程序的多样性。  

--- 

## 面向对象的特征
### 抽象
#### 定义
抽象指将同类对象中提取出共性的特性，然后形成一个**类(class)**  
在C#中，类与类直接只能单一继承，不能继承多个类。  

#### 例子
下面的代码提供了一个**类**的示例，将一个姓名属性和更改姓名的方法封装到一个`Person`类中：
```
public class Person
{
    //姓名属性
    public string Name { get; }

    //方法
    public void ChangeName(string name)
    {
        Name = name;
    }
}
```
在编程时，可以使用该类作为一个`Person`对象，并可以读取和更改其姓名

#### 抽象的好处  
>- 抽象化模拟了现实世界的事物和行为，提高了代码可读性。
>- 增强了代码模块化程度
>- 降低了代码的耦合和复杂度

---  

### 封装
#### 定义
封装指隐藏类/对象内部的状态和功能，仅通过一组公共的成员来进行访问   
对类中的成员添加访问修饰符以指定成员的访问级别。  
C#中访问修饰符有四种:  
`private`:私有，只有当前类内部的才能访问  
`public`:共有，公开访问，类的内外都可以访问  
`protected`:保护，只有**继承**自该类的类可以访问  
`internal`:内部，类的内外都可以访问，但仅限当前程序集  
其中，internal修饰符可以与其他三个叠加使用，如internal public即是在当前程序集中的类内外都可以访问。  
不指定访问修饰符的类默认为`private`  

#### 例子
下面的代码举出了访问修饰符的例子：
```
public class Person
{
    //私有修饰符
    private string name;

    public string GetName()
    {
        //在类的内部可以访问
        return name;
    }
}

public class Program
{
    static void Main(string[] args)
    {
        Person p = new Person();
        p.name;
    }
}
```
使用访问修饰符限制了类中成员的访问级别，实现隐藏成员的效果，达到封装的目的。

#### 封装的好处  
>- 类的封装可以保护类内部的数据和代码不被外部访问，提高代码的安全性  
>- 封装隐藏了类中方法/属性的实现细节，只向外暴露简单的成员，外部调用时只需要知道该成员是干什么用的，而无需知道如何实现的，简化了操作。
>- 在修改一个类的代码时，不会影响到其他类，除非修改的是公共成员并且该成员被其他类所调用  

---  

### 继承
#### 定义
根据现有抽象创建新的抽象，说人话就是在原有类的基础上进行拓展，保留原有类的所有能力，在新的一个类上创建新的功能，此操作被称为 **“继承”**，原有的类被称为 **“父类”** 或 **“基类”** ，继承父类的新类被称为 **“子类”** 或 **“派生类”** ，子类继承父类的行为被称为 **“派生”**，可以说 **“子类”继承自“父类”，而“父类”派生出“子类”**。

一般，定义复杂且多种类对象时，会把它们共性的特征集成到一个父类中，将它们独有的特征划分到子类。   

在C#中，类只能有一个基类，不能多重继承。  

#### 例子
下面的代码展示了类的继承关系：
```
//基类
public class Person
{
    public string Name { get; }

    public void ChangeName(string name)
    {
        Name = name;
    }
}

//派生类，继承了Person类
public class Employee : Person
{
    public string Company { get; }
    
    public void ChangeCompany(string company)
    {
        Company = company;
    }
}

//派生类，继承了Person类
public class Student : Person
{
    public string School { get; set; }
}

```
上述代码的`Employee`类继承自`Person`类，`Studnet`类也继承自了`Person`类，它们都会继承`Person`类的`Name`属性和`ChangeName`方法，但它们也有自己独有的属性和方法。

#### `base`关键字
在子类中使用base关键字可以访问到父类的公开或保护内容
```
public class Employee : Person
{
    ...
    public string GetName()
    {
        //使用base关键字访问父类的公开属性
        return base.Name;
    }

    //使用base关键字访问父类的构造函数，如果父类的构造函数有参数，可以在这里传递
    public Employee() : base()
    {}
}
```

#### `sealed`关键字
如果不想让某个类被继承，在声明类时添加sealed关键字，它阻止其他类继承该类。

```
//其他类若尝试继承Boss类将会有编译错误
public sealed class Boss : Person
{
    ...
}
```

#### 继承的好处
>- 优化类之间的关系，减少冗余，提高代码的复用性，减少错误的可能。
>- 提供 **“多态性”**


---  

### 多态
#### 定义
多态也是面向对象的核心，它指跨多个抽象以不同方式实现继承属性或方法的能力。多态的实现依赖于**继承**，所以必须要定义多个类并有继承关系，派生类可以各自对父类的方法实现进行修改，在调用时表现出不同的行为，大大增加编程的灵活度。在使用类时，使用多个派生类实例化出多个对象，对这些对象调用同样的基类方法，但却表现出不同的行为，这便是多态。

下面是实现多态必要的一些概念：

#### ***抽象类***
将对象或已有的类**更加抽象化**成为一个新的类，以至于无法具体化（无法创建出该类的对象，因为过于抽象而缺少某些创建类所必要的数据或方法）。这样的类被称为抽象类，在类修饰符`class`前加上`abstract`修饰符将定义的类转换为抽象类，抽象类无法被实例化，只能称为其他类的**基类**。   

- 抽象类可以有构造函数，但是不能够使用new实例化，构造函数仅供子类使用。

#### ***虚方法***
有时将已有类的提取成基类后，会遇到部分子类对与某些方法的实现方式不一致。在类中定义方法时加上`virtual`关键字，可让子类使用`override`关键字重写基类方法的实现。

举一个现实中的例子：以前的所有轿车都是由燃油驱动的，它们有着“移动”行为，并且该都是以"燃油驱动"。但随着时代变化，出现了电力驱动的轿车，即使驱动原理不一样了，但它们还是有着“移动”行为。  

从编程方面来看，轿车类`Car`有着`Move`方法，该方法是“由燃油驱动的”，但出现了新的类`ElectricCar`电动车类，它继承自`Car`类，但是它对`Move`方法的实现却不一样，它是“电力驱动的”。此时，可以将`Car`类中的`Move`方法标记为虚方法`virtual`，然后在派生类中重写该方法。

下面的类定义了一个轿车类，有着用燃油驱动的`Move`方法：
```
public class Car
{
    //使用virtual关键字定义虚方法
    public virtual void Move()
    {
        //用燃油驱动
        ...
    }
}
```
有一个类`ElectricCar`继承了`Car`类，并重写了父类的`Move`方法：
```
public class ElectricCar : Car
{
    //使用override关键字重写父类的虚方法
    public override void Move()
    {
        //用电力驱动
        ...
    }
}
```

此时使用`Car`类和`ElectricCar`类分别实例化出对象，调用`Move`方法，它们表现出的行为将不一致。
```
...
Car c = new Car();
//燃油驱动
c.Move();
ElectricCar ec = new ElectricCar();
//电力驱动，该派生类重写了Move方法
ec.Move();
...
```
- 在类中使用`virtual`关键字在方法前标注，来声明一个虚方法。
- 在派生类中使用`override`关键字对父类中的虚方法进行重写，修改方法的实现过程。
- 如果不想完全重写虚方法，只是想要在父类的方法基础上添加代码，可以在重写时用`base`关键字调用父类方法。
- `sealed`关键字也适用于虚方法，它阻止派生类重写方法。


#### ***抽象方法***
抽象方法类似于**虚方法**，子类可以**重写**方法的实现。但是有时子类对方法的实现各不相同，无法统一出一个父类的实现方法，这个方法便被抽象化成为一个**抽象方法**。  

抽象方法在类的方法前使用`abstract`关键字定义，抽象方法没有方法体，仅定义了方法名，返回值和参数。在子类同样使用`override`对父类的抽象方法进行重写。  

定义了抽象方法的类必须为**抽象类**，因为这个类有方法没有被实现，无法实例化。  

若一个类的基类是带有抽象方法的抽象类，除非该派生类也是一个抽象类，不然就必须重写所有的抽象方法。  


再举一个例子：三角形和矩形都属于“形状”，都可以求出其面积，但它们计算面积的公式是不一样的。  

从编程方面来看，三角形和矩形可以提取出一个父类`Shape`（形状）类，`Shape`类中有一**虚方法**`Area`用于计算形状的面积。三角形`Triangle`类和矩形`Rectangle`类都继承自`Shape`，并且重写了`Area`方法。  

但这样设计的问题是，`Shape`类过于抽象，创建成对象是没有意义的，而且无法实现`Area`方法，只能留空。   
此时就可以将`Shape`类的`Area`方法标记为**抽象方法**，并且将`Shape`类标记为抽象类。抽象类无法实例化，只能用来继承，抽象方法也不需要实现，只能用来重写。

下面的代码对抽象方法进行了示例：

```
//带有抽象方法的类必须为抽象类
public abstract class Shape
{
    //使用abstract关键字声明了一个抽象方法，没有方法体。
    public abstract float Area();
}
public class Triangle : Shape
{
    //使用override关键字重写了父类的抽象方法，如果没有重写该方法，将会有编译错误
    public override float Area()
    {
        ...
    }
}
public class Rectangle : Shape
{
    public override float Area()
    {
        ...
    }
}
```

- 抽象方法不需要方法实现，只需要定义名称，参数和返回值即可，但该类的派生类必须提供**重写**该抽象方法。  
- 抽象方法的访问修饰符不能为`private`，因为抽象方法需要子类的实现。  
- 若一个类拥有抽象方法，它就必须被修饰为**抽象类**，因为抽象方法需要一个子类提供实现。
    
    
#### ***接口***
类抽象的极限是只包含方法，类中没有任何数据，只定义了该类的行为，这样抽象到极限的类被称为 **“接口”**。而**继承**了该类的类也不叫**派生类**了，它们被称为 **“实现类”**，而继承这一操作名也变为了 **“实现”**，即某类**实现了**某接口，定义接口的关键字不是`class`，变为了`interface`。    

接口类似于抽象类，但比抽象类更加抽象，无法定义数据，只能定义行为，而且实现接口的类都必须实现接口中定义的**所有成员**。  

接口一般用来定义某些行为，而不是一类事物，比如C#中的`IEnumerable`（可枚举）接口。某个类实现了接口，就代表它能够实现这些行为。

> - 在C#中，接口只能定义*方法，属性，索引器和事件*。  
> - 在C#中，类只能继承一个类，但允许实现多个接口，在程序中可以让类实现多个接口，以表现出各类不同的行为。在对类的功能进行拓展时，也可以添加实现的接口来让类实现相应的方法。  
> - 在C#中，接口的命名应当以字母I开头。  

下面的代码展示了接口和实现类的定义：
```
//使用interface关键字定义接口
public interface IMoveable
{
    //定义接口属性
    Vector2 Position { get; }
    //定义接口方法，无需方法体
    void Move(int x, int y);
} 

public class Car : IMoveable
{
    //实现接口中的属性和方法
    public Vector2 Position { get;  }
    public void Move(int x, int y)
    {
        Position.x = x;
        Position.y = y;
    }
}
```

- 接口定义的成员都不需要实现，实现类必须实现接口的所有成员。
- 接口成员可以不加访问修饰符，默认会赋予`public`，接口成员的访问修饰符不能为`private`，因为私有的接口方法没有意义。

**新版本特性**  
在高版本的C#，接口中的方法可以有方法体，接口中也可以定义静态抽象成员和虚拟成员，具体参考官方文档：[接口](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface)  

#### 替换  
- ***向上转换(upcasting)***   
    在对对象进行操作时，派生类对象的引用可以替换基类的引用：  
    ```
    Person p1 = new Person();//实例化Person对象
    Employee e1 = new Employee();//实例化Employee对象
    p1 = e1;//替换
    ```
    上述代码演示了替换的过程，`Employee`类是`Person`类的派生，将其分别实例化出`p1`对象和`e1`对象，并将`p1`对象的引用替换成了`e1`对象。  

    虽然两对象是不同类型的，但这样的替换操作是合法的，并不会有错误或警告，像这样使用派生类引用替换成基类引用的操作称为***向上转换(Upcasting)***。因为`Employee`类继承了`Person`类的所有数据，所以对`p1`对象进行的任何操作，都适用于`e1`对象，而不会导致任何问题。向上转换是可传递的，也就是说如果有一个类继承了`Employee`类，该类的对象也可以替换`p1`对象，因为该类也间接地继承了`Person`类。   

- ***向下转换***
    ***向下转换(Downcasting)***和向上转换相反，即基类的引用替换派生类的引用：
    ```
    Person p2 = new Person();
    Employee e2 = new Employee();
    e2 = (Employee)p2;//向下转换
    ```
    上述代码演示了向下转换，向下转换是强制转换，代码中使用括号来进行强制转换，这个操作通常来说是不允许的。一个派生类可以在基类的基础上派生出新的数据成员，但这些成员并不能适用于基类对象，例如Employee类有一属性为`Company`，而使用`Person`类实例化的对象是访问不到该属性的，所以向下转换是不安全的，上述代码在运行时会报运行时错误。

    但有一种情况例外，如果转换对象是向上转换过来的，那么就不会报运行错误，例如：
    ```
    Person e3 = new Employee();//在实例化时进行向上转换
    Employee e4 = (Employee)e3;//向下转换
    ```
    代码中的`e3`对象本身是`Employee`类型，但通过向上转换成了`Person`类型的引用，向上转换并不会清除派生类中的数据成员，所以向下转换回`Employee`类型时并不会报错。  

    向上和向下转换也适用于抽象类和接口。

- ***is和as关键字***   
    在有些情况，向下转换操作是不可避免的。若要进行向下强制转换，可以使用C语言风格的`()`来强制转换，如`e2 = (Employee)p2;`，要是p2无法转换成e2，则会抛出异常。所以在向下转换前，通常要进行检查。  

    C#提供`is`关键字判断对象类型，并返回`true`或`false`，在转换前使用`is`进行判断：
    ```
    //检查p2的类型是否是`Employee`
    if(p2 is Employee)
    {
        e2 = (Employee)p2;
        ...
    }
    ```

    C#还提供了`as`关键字来进行向下转换，和`()`的不同是，使用`as`转换失败并不会报错，而是返回`null`：
    ```
    e2 = p2 as Employee;//使用as关键字进行转换，如果失败则会返回null
    if(e2 == null)
        ...//转换失败
    else
        ...转换成功
    ```

- ***替换带来的多态性***  
    在对象向上转换过后，如果调用的方法被转换前的类型重写过，则会调用重写后的方法：
    ```
    Shape t1 = new Triangle();
    Shape r1 = new Rectangle();
    Console.WriteLine(t1.Area());
    Console.WriteLine(r1.Area());
    ```
    代码中使用`Triangle`类型和`Rectangle`类型实例化出`s1`和`r1`对象，并上转型成`Shape`类型，因为两个类型都重写了基类的`Area`方法，在调用两个对象的`Area`方法时，将会各自调用转换前类型调用重写后的方法，即使它们转换成了`Shape`类型。  

    替换操作看起来会导致方法调用的混乱，但这样其实很好地运用了类的多态性。里氏替换原则提到：

    > "如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致。"   

    替换操作对类的通用性提升是巨大的。例如，你可以对一组继承自同一个类型的对象进行操作，它们将表现出不同的行为：
    ```
    object[] data = { 100, "Alice", 0.98f, Math.PI, DateTime.Now };
    foreach (var obj in data)
    {
        Console.WriteLine(obj);
    }
    ```
    上述代码使用了多个不同类型的对象初始化一个`object`类型的数组，在循环中，`Console.WriteLine`方法接收一个`object`类型对象，并调用对象的`ToString`方法，因为数组中对象的类型都各自重写了`ToString`方法，它们的输出将会表现出不同的效果。  


#### 多态性的好处
>- 增强了代码的通用性和简洁性，因为多态允许不同的对象执行相同的操作，但调用的方法却是同一个，这意味着程序员不需要写多个专门针对不同对象类型的方法。
>- 增强了代码的可扩展性，当在一个较为完整的程序中添加新的对象类型，只需要选择要继承的类，实现需要的接口即可，不需要花费大量的事件思考类中有哪些成员。
---

## 面向对象五大原则（SOLID原则）
### 单一职责原则，Single Responsibility Principle (SRP)  
> "每个模块都只有一个引起它变化的原因。"  

即一个类只负责一个功能领域的职责。单一职责原则是实现高内聚低耦合的关键，不要把太多的功能封装到类中，否则将会增加耦合度，大大降低可维护性。  

单一职责是程序设计阶段时划分类的一个好方法，只有全面了解程序的功能，才能很好地分离职责。  

### 开闭原则，Open/Closed Principle  
> “开”指对扩展开放，“闭”指对修改关闭。  

编写模块时应当尽量设计出不需要修改的模块，在扩展新功能的时候，只需要编写新的代码而无需修改旧的代码。  

满足开闭原则可以最大化模块的复用性和扩展性。  

一些设计模式很好地实现了开闭原则：如面向接口编程(Interface Based Programming)，将功能抽象成稳定的接口，在扩展代码时添加接口和实现方法即可。或是面向切面编程(AOP)，将模块分为多个层，使用事件回调等方法在层直接注入处理的代码，在添加功能时只需在需要的层中添加代码即可。  

### 里氏替换原则，Liskov Substitution Principle (LSP)
> "如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致。"    

换句话说，派生类必须可以替换其基类。  

什么叫“与期望的行为一致”?   
> *“在不了解派生类的情况下，仅通过接口或基类的方法，即可清楚的知道方法的行为，而不管哪种派生类的实现，都与接口或基类方法的期望行为一致。或者说接口或基类的方法是一种契约，使用方按照这个契约来使用，派生类也按照这个契约来实现。这就是与期望行为一致的替换。”*  

在运用类的多态性时，不应当违背里氏替换原则。在派生类中重写方法时，应当保证每个派生类重写方法的最终目的都是一致的，即“与期望的行为一致”。  
例如`Triangle`类和`Rectangle`类都重写了`Shape`类的`Area`方法，它们都应当保证重写后能正确返回图形的面积，而不是返回周长。

### 接口隔离原则，Interface Segregation Principle (ISP)
> "客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。"  

接口不应过于臃肿，尽量细化接口，减少接口中方法的数量，降低类对单个接口的依赖性。  
接口越大，它越有可能包含并非所有实现类都能使用的到的方法。如果一个类和某个接口没有一致的目的，那就不要实现那个接口。  

### 依赖倒置原则，Dependency Inversion Principle (DIP)  
> "高级模块/类不应当依赖于低级的模块/类，首先两者都应当依赖于其抽象。其次，抽象不应当依赖于实现。最后，实现应当取决于抽象。  

说人话就是，当两个模块/类有依赖关系时，首先它们都应当继承自某个类或实现某个接口。然后，在对一个派生程度较低的类进行设计时，不应当依赖于一个派生程度较高的类，应该使用其基类或是接口等派生程度较低的类进行依赖。  

当一个类依赖于另一个类的一个明确的实现时，如果依赖类的实现改变了，当前类可能会被破坏。因此，在对一个功能进行依赖时，应当面向抽象编程，而不是面向实现。  

---

## 总结  

面向对象为编程提供了一个很好的思路，遵循SOLID原则可以构建一个代码整洁，可读性高，且易于维护的应用程序，但过于追求这些繁文缛节可能会大幅增加代码量。规则是死的人是活的，在进行编程时必须权衡这些规则带来的代码质量和代码数量，毕竟，20行代码可比200行代码要少得多。

---

**参考内容**  
> 类继承：**Stephen Prata. C++ Primer Plus.**  
> C#面向对象：[https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/oop](https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/oop)  
> C#接口：[https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface)  
> C#默认接口方法：[https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods)    
> SOLID原则：[https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/](https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/)  
> 里氏替换原则：[https://zhuanlan.zhihu.com/p/268574641](https://zhuanlan.zhihu.com/p/268574641)